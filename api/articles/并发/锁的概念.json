{"title":"锁的概念","uid":"6f65c61888737e8d4204dac5a8495701","slug":"并发/锁的概念","date":"2024-12-03T15:13:49.000Z","updated":"2024-12-03T16:35:43.405Z","comments":true,"path":"api/articles/并发/锁的概念.json","keywords":null,"cover":"https://i.pinimg.com/474x/8b/cf/58/8bcf5852517ffb57d8fdd8fd009da50c.jpg","content":"<h2 id=\"导图\"><a href=\"#导图\" class=\"headerlink\" title=\"导图\"></a><a href=\"#%E5%AF%BC%E5%9B%BE\">导图</a></h2><p><img src=\"https://www.kaiven666.online/images/image-20241103134201150.png\" alt=\"image-20241103134201150\"></p>\n<h2 id=\"乐观锁-VS-悲观锁\"><a href=\"#乐观锁-VS-悲观锁\" class=\"headerlink\" title=\"乐观锁 VS 悲观锁\"></a><a href=\"#%E4%B9%90%E8%A7%82%E9%94%81-vs-%E6%82%B2%E8%A7%82%E9%94%81\">乐观锁 VS 悲观锁</a></h2><p>乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。</p>\n<p>先说概念。对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。</p>\n<p>而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。</p>\n<p>乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。</p>\n<p><img src=\"https://www.kaiven666.online/images/image-20241103134627824.png\" alt=\"image-20241103134627824\"></p>\n<p>根据从上面的概念描述我们可以发现：</p>\n<ul>\n<li><strong>悲观锁适合写操作多的场景</strong>，先加锁可以保证写操作时数据正确。</li>\n<li><strong>乐观锁适合读操作多的场景</strong>，不加锁的特点能够使其读操作的性能大幅提升。</li>\n</ul>\n<h2 id=\"自旋锁-VS-适应性自旋锁\"><a href=\"#自旋锁-VS-适应性自旋锁\" class=\"headerlink\" title=\"自旋锁 VS 适应性自旋锁\"></a><a href=\"#%E8%87%AA%E6%97%8B%E9%94%81-vs-%E9%80%82%E5%BA%94%E6%80%A7%E8%87%AA%E6%97%8B%E9%94%81\">自旋锁 VS 适应性自旋锁</a></h2><p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p>\n<p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p>\n<p>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p>\n<p><img src=\"https://www.kaiven666.online/images/image-20241103135118631.png\" alt=\"image-20241103135118631\"></p>\n<p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。</p>\n<p>自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p>\n<h2 id=\"无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁\"><a href=\"#无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁\" class=\"headerlink\" title=\"无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁\"></a><a href=\"#%E6%97%A0%E9%94%81-vs-%E5%81%8F%E5%90%91%E9%94%81-vs-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81-vs-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81\">无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</a></h2><p>这四种锁是指锁的状态，专门针对synchronized的。</p>\n<p>（后续的文章会详细讲解）</p>\n<p>总结而言： 偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。</p>\n<h2 id=\"公平锁-VS-非公平锁\"><a href=\"#公平锁-VS-非公平锁\" class=\"headerlink\" title=\"公平锁 VS 非公平锁\"></a><a href=\"#%E5%85%AC%E5%B9%B3%E9%94%81-vs-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81\">公平锁 VS 非公平锁</a></h2><p>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p>\n<p>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p>\n<h2 id=\"可重入锁-VS-非可重入锁\"><a href=\"#可重入锁-VS-非可重入锁\" class=\"headerlink\" title=\"可重入锁 VS 非可重入锁\"></a><a href=\"#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81-vs-%E9%9D%9E%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81\">可重入锁 VS 非可重入锁</a></h2><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Test &#123;</span><br><span class=\"line\">    public synchronized void func01(int arg)&#123;</span><br><span class=\"line\">        System.out.println(arg);</span><br><span class=\"line\">        func02(arg + 1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public synchronized void func02(int arg)&#123;</span><br><span class=\"line\">        System.out.println(arg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Test test = new Test();</span><br><span class=\"line\">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class=\"line\">        executorService.execute(() -&gt; test.func01(1));</span><br><span class=\"line\">        executorService.execute(() -&gt; test.func01(3));</span><br><span class=\"line\">        executorService.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果 synchronized 不是可重入锁的话，那么很明显上述代码会造成死锁。</p>\n<p>可重入锁的实现原理大致是这样的：内部维护了一个计数器，获取到锁的时候，判断一下计数器的值。如果计数器的值是0的话，那么执行+1操作；如果不是0的话，判断当前线程是否是获取到锁的线程，如果是的话，就执行+1操作。释放锁就是每执行完一个同步代码块后，将计数器的值-1，计数器的值为0时，释放锁。</p>\n<h2 id=\"独享锁-排他锁-VS-共享锁\"><a href=\"#独享锁-排他锁-VS-共享锁\" class=\"headerlink\" title=\"独享锁(排他锁) VS 共享锁\"></a><a href=\"#%E7%8B%AC%E4%BA%AB%E9%94%81-%E6%8E%92%E4%BB%96%E9%94%81-vs-%E5%85%B1%E4%BA%AB%E9%94%81\">独享锁(排他锁) VS 共享锁</a></h2><p><strong>独享锁也叫排他锁</strong>，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。</p>\n<p><strong>共享锁</strong>是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p>\n<p>（本文主要是介绍一下锁的概念上的东西，具体的实现请看后续章节）</p>\n<hr>\n","text":"导图 乐观锁 VS 悲观锁乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。 先说概念。对于同一个数...","permalink":"/post/并发/锁的概念","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"八股","slug":"八股","count":16,"path":"api/categories/八股.json"}],"tags":[{"name":"java","slug":"java","count":14,"path":"api/tags/java.json"},{"name":"并发框架","slug":"并发框架","count":7,"path":"api/tags/并发框架.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%BC%E5%9B%BE\"><span class=\"toc-text\">导图</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B9%90%E8%A7%82%E9%94%81-VS-%E6%82%B2%E8%A7%82%E9%94%81\"><span class=\"toc-text\">乐观锁 VS 悲观锁</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%87%AA%E6%97%8B%E9%94%81-VS-%E9%80%82%E5%BA%94%E6%80%A7%E8%87%AA%E6%97%8B%E9%94%81\"><span class=\"toc-text\">自旋锁 VS 适应性自旋锁</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%97%A0%E9%94%81-VS-%E5%81%8F%E5%90%91%E9%94%81-VS-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81-VS-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81\"><span class=\"toc-text\">无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%AC%E5%B9%B3%E9%94%81-VS-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81\"><span class=\"toc-text\">公平锁 VS 非公平锁</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81-VS-%E9%9D%9E%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81\"><span class=\"toc-text\">可重入锁 VS 非可重入锁</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%8B%AC%E4%BA%AB%E9%94%81-%E6%8E%92%E4%BB%96%E9%94%81-VS-%E5%85%B1%E4%BA%AB%E9%94%81\"><span class=\"toc-text\">独享锁(排他锁) VS 共享锁</span></a></li></ol>","author":{"name":"Ivan","slug":"blog-author","avatar":"https://yslcrush.obs.cn-south-1.myhuaweicloud.com/imag/m.jpg","link":"/","description":"离婚后看淡人生","socials":{"github":"https://github.com/FAKERSMILE","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/3494374914656981/favlist"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"Volatile详解","uid":"4dfa428c08a3d894cc1c145fbc03603c","slug":"并发/Volatile详解","date":"2024-12-03T15:19:43.000Z","updated":"2024-12-03T16:35:43.394Z","comments":true,"path":"api/articles/并发/Volatile详解.json","keywords":null,"cover":"https://i.pinimg.com/474x/98/2e/10/982e10486f83a19d5b91ba22cd9e23a3.jpg","text":"volatile的作用详解防重排序从一个经典的双检索单例模式开始： 1234567891011121314151617public class Singleto...","permalink":"/post/并发/Volatile详解","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"八股","slug":"八股","count":16,"path":"api/categories/八股.json"}],"tags":[{"name":"java","slug":"java","count":14,"path":"api/tags/java.json"},{"name":"并发框架","slug":"并发框架","count":7,"path":"api/tags/并发框架.json"}],"author":{"name":"Ivan","slug":"blog-author","avatar":"https://yslcrush.obs.cn-south-1.myhuaweicloud.com/imag/m.jpg","link":"/","description":"离婚后看淡人生","socials":{"github":"https://github.com/FAKERSMILE","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/3494374914656981/favlist"}}}}},"next_post":{"title":"线程基础","uid":"6245dd4deb5ec4d8e16e80935a8a30db","slug":"并发/线程基础","date":"2024-12-03T14:40:50.000Z","updated":"2024-12-03T16:35:43.382Z","comments":true,"path":"api/articles/并发/线程基础.json","keywords":null,"cover":"https://i.pinimg.com/236x/8b/44/3c/8b443cd6bca1516bfb6e156c5503c2c5.jpg","text":"线程状态的转换新建（New）创建后未启动。 可运行（Runable）可能正在运行，也可能等待CPU时间片。 阻塞（Blocking）等待获取一个排它锁，如果其他...","permalink":"/post/并发/线程基础","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"八股","slug":"八股","count":16,"path":"api/categories/八股.json"}],"tags":[{"name":"java","slug":"java","count":14,"path":"api/tags/java.json"},{"name":"并发框架","slug":"并发框架","count":7,"path":"api/tags/并发框架.json"}],"author":{"name":"Ivan","slug":"blog-author","avatar":"https://yslcrush.obs.cn-south-1.myhuaweicloud.com/imag/m.jpg","link":"/","description":"离婚后看淡人生","socials":{"github":"https://github.com/FAKERSMILE","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/3494374914656981/favlist"}}}}}}