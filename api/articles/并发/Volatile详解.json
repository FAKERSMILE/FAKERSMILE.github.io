{"title":"Volatile详解","uid":"4dfa428c08a3d894cc1c145fbc03603c","slug":"并发/Volatile详解","date":"2024-12-03T15:19:43.000Z","updated":"2024-12-03T16:35:43.394Z","comments":true,"path":"api/articles/并发/Volatile详解.json","keywords":null,"cover":"https://i.pinimg.com/474x/98/2e/10/982e10486f83a19d5b91ba22cd9e23a3.jpg","content":"<h2 id=\"volatile的作用详解\"><a href=\"#volatile的作用详解\" class=\"headerlink\" title=\"volatile的作用详解\"></a><a href=\"#volatile%E7%9A%84%E4%BD%9C%E7%94%A8%E8%AF%A6%E8%A7%A3\">volatile的作用详解</a></h2><h4 id=\"防重排序\"><a href=\"#防重排序\" class=\"headerlink\" title=\"防重排序\"></a><a href=\"#%E9%98%B2%E9%87%8D%E6%8E%92%E5%BA%8F\">防重排序</a></h4><p>从一个经典的双检索单例模式开始：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Singleton &#123;</span><br><span class=\"line\">    public static volatile Singleton singleton;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 构造函数私有，禁止外部实例化</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private Singleton() &#123;&#125;;</span><br><span class=\"line\">    public static Singleton getInstance() &#123;</span><br><span class=\"line\">        if (singleton == null) &#123;</span><br><span class=\"line\">            synchronized (singleton.class) &#123;</span><br><span class=\"line\">                if (singleton == null) &#123;</span><br><span class=\"line\">                    singleton = new Singleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在我们分析一下为什么要在变量singleton之间加上volatile关键字。要理解这个问题，先要了解对象的构造过程，实例化一个对象其实可以分为三个步骤：</p>\n<ul>\n<li>分配内存空间。</li>\n<li>初始化对象。</li>\n<li>将内存空间的地址赋值给对应的引用。</li>\n</ul>\n<p>但是由于操作系统可以<code>对指令进行重排序</code>，所以上面的过程也可能会变成如下过程：</p>\n<ul>\n<li>分配内存空间。</li>\n<li>将内存空间的地址赋值给对应的引用。</li>\n<li>初始化对象</li>\n</ul>\n<p>如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。因此，为了防止这个过程的重排序，我们需要将变量设置为volatile类型的变量。</p>\n<h4 id=\"实现可见性\"><a href=\"#实现可见性\" class=\"headerlink\" title=\"实现可见性\"></a><a href=\"#%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%81%E6%80%A7\">实现可见性</a></h4><p>可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到。引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestVolatile &#123;</span><br><span class=\"line\">    private static boolean stop = false;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        // Thread-A</span><br><span class=\"line\">        new Thread(&quot;Thread A&quot;) &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void run() &#123;</span><br><span class=\"line\">                while (!stop) &#123;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + &quot; stopped&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        // Thread-main</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            TimeUnit.SECONDS.sleep(1);</span><br><span class=\"line\">            System.out.println(Thread.currentThread() + &quot; after 1 seconds&quot;);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        stop = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到 Thread-main 休眠1秒之后，设置 stop &#x3D; ture，但是Thread A根本没停下来，这就是可见性问题。如果通过在stop变量前面加上volatile关键字则会真正stop。</p>\n<p>这里有必要做一下详细的解释：</p>\n<p>CPU的多级缓存机制是大小限制的，上下文切换的时候，会将线程相关状态保存在TCB中，TCB在内存中。下次再次切换会该线程的时候，会从TCB中恢复线程的上下文信息。即，从上面的程序来说，“stop的值被保存在TCB中”，一直读取的都是老值。</p>\n<h4 id=\"保证原子性：单次读-写\"><a href=\"#保证原子性：单次读-写\" class=\"headerlink\" title=\"保证原子性：单次读&#x2F;写\"></a><a href=\"#%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7-%E5%8D%95%E6%AC%A1%E8%AF%BB-%E5%86%99\">保证原子性：单次读&#x2F;写</a></h4><p>volatile不能保证完全的原子性，只能保证单次的读&#x2F;写操作具有原子性。</p>\n<p>我们先来看两个经典的问题：</p>\n<h6 id=\"1-i-为什么不能保证原子性？\"><a href=\"#1-i-为什么不能保证原子性？\" class=\"headerlink\" title=\"1. i++为什么不能保证原子性？\"></a><a href=\"#_1-i-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7\">1. i++为什么不能保证原子性？</a></h6><p>对于原子性，需要强调一点，也是大家容易误解的一点：对volatile变量的单次读&#x2F;写操作可以保证原子性的，如long和double类型变量，但是并不能保证i++这种操作的原子性，因为本质上i++是读、写两次操作。</p>\n<p>i++其实是一个复合操作，包括三步骤：</p>\n<ul>\n<li>读取i的值。</li>\n<li>对i加1。</li>\n<li>将i的值写回内存。</li>\n</ul>\n<p>volatile是无法保证这三个操作是具有原子性的，我们可以通过AtomicInteger或者Synchronized来保证+1操作的原子性。</p>\n<h6 id=\"2-共享的long和double变量为什么要用volatile？\"><a href=\"#2-共享的long和double变量为什么要用volatile？\" class=\"headerlink\" title=\"2. 共享的long和double变量为什么要用volatile？\"></a><a href=\"#_2-%E5%85%B1%E4%BA%AB%E7%9A%84long%E5%92%8Cdouble%E5%8F%98%E9%87%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8volatile\">2. 共享的long和double变量为什么要用volatile？</a></h6><p>因为long和double两种数据类型的操作可分为高32位和低32位两部分，因此普通的long或double类型读&#x2F;写可能不是原子的。因此，鼓励大家将共享的long和double变量设置为volatile类型，这样能保证任何情况下对long和double的单次读&#x2F;写操作都具有原子性。</p>\n<p>（目前各种平台下的商用虚拟机都选择把 64 位数据的读写操作作为原子操作来对待，因此我们在编写代码时一般不把long 和 double 变量专门声明为 volatile多数情况下也是不会错的）</p>\n<h2 id=\"volatile-的实现原理\"><a href=\"#volatile-的实现原理\" class=\"headerlink\" title=\"volatile 的实现原理\"></a><a href=\"#volatile-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\">volatile 的实现原理</a></h2><h4 id=\"volatile-可见性实现\"><a href=\"#volatile-可见性实现\" class=\"headerlink\" title=\"volatile 可见性实现\"></a><a href=\"#volatile-%E5%8F%AF%E8%A7%81%E6%80%A7%E5%AE%9E%E7%8E%B0\">volatile 可见性实现</a></h4><p>volatile 变量的内存可见性是基于内存屏障(Memory Barrier)实现:</p>\n<p>内存屏障，又称内存栅栏，是一个 CPU 指令。</p>\n<p>在程序运行时，为了提高执行性能，编译器和处理器会对指令进行重排序，JMM 为了保证在不同的编译器和 CPU 上有相同的结果，通过插入特定类型的内存屏障来禁止+ 特定类型的编译器重排序和处理器重排序，插入一条内存屏障会告诉编译器和 CPU：不管什么指令都不能和这条 Memory Barrier 指令重排序。</p>\n<p>为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存(L1，L2 或其他)后再进行操作，但操作完不知道何时会写到内存。</p>\n<p>如果对声明了 volatile 的变量进行写操作，JVM 就会向处理器发送一条 lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。</p>\n<p>为了保证各个处理器的缓存是一致的，实现了缓存一致性协议(MESI)，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p>\n<p>所有多核处理器下还会完成：当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。</p>\n<p>volatile 变量通过这样的机制就使得每个线程都能获得该变量的最新值。</p>\n<h4 id=\"volatile-有序性实现\"><a href=\"#volatile-有序性实现\" class=\"headerlink\" title=\"volatile 有序性实现\"></a><a href=\"#volatile-%E6%9C%89%E5%BA%8F%E6%80%A7%E5%AE%9E%E7%8E%B0\">volatile 有序性实现</a></h4><h6 id=\"1-happens-before\"><a href=\"#1-happens-before\" class=\"headerlink\" title=\"1. happens-before\"></a><a href=\"#_1-happens-before\">1. happens-before</a></h6><p>happens-before 规则中有一条是 volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。</p>\n<p>（简单说，如果写在读的前面的话，那么一定读到的就是最新值）</p>\n<h6 id=\"2-写操作禁止重排序\"><a href=\"#2-写操作禁止重排序\" class=\"headerlink\" title=\"2. 写操作禁止重排序\"></a><a href=\"#_2-%E5%86%99%E6%93%8D%E4%BD%9C%E7%A6%81%E6%AD%A2%E9%87%8D%E6%8E%92%E5%BA%8F\">2. 写操作禁止重排序</a></h6><p>为了性能优化，JMM 在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序。JMM 提供了内存屏障阻止这种重排序。</p>\n<p>Java 编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。</p>\n<hr>\n","text":"volatile的作用详解防重排序从一个经典的双检索单例模式开始： 1234567891011121314151617public class Singleto...","permalink":"/post/并发/Volatile详解","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"八股","slug":"八股","count":14,"path":"api/categories/八股.json"}],"tags":[{"name":"java","slug":"java","count":12,"path":"api/tags/java.json"},{"name":"并发框架","slug":"并发框架","count":6,"path":"api/tags/并发框架.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#volatile%E7%9A%84%E4%BD%9C%E7%94%A8%E8%AF%A6%E8%A7%A3\"><span class=\"toc-text\">volatile的作用详解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%98%B2%E9%87%8D%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">防重排序</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%81%E6%80%A7\"><span class=\"toc-text\">实现可见性</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%9A%E5%8D%95%E6%AC%A1%E8%AF%BB-%E5%86%99\"><span class=\"toc-text\">保证原子性：单次读&#x2F;写</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#1-i-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%9F\"><span class=\"toc-text\">1. i++为什么不能保证原子性？</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#2-%E5%85%B1%E4%BA%AB%E7%9A%84long%E5%92%8Cdouble%E5%8F%98%E9%87%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8volatile%EF%BC%9F\"><span class=\"toc-text\">2. 共享的long和double变量为什么要用volatile？</span></a></li></ol></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#volatile-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">volatile 的实现原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#volatile-%E5%8F%AF%E8%A7%81%E6%80%A7%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">volatile 可见性实现</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#volatile-%E6%9C%89%E5%BA%8F%E6%80%A7%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">volatile 有序性实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#1-happens-before\"><span class=\"toc-text\">1. happens-before</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#2-%E5%86%99%E6%93%8D%E4%BD%9C%E7%A6%81%E6%AD%A2%E9%87%8D%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">2. 写操作禁止重排序</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>","author":{"name":"Ivan","slug":"blog-author","avatar":"https://yslcrush.obs.cn-south-1.myhuaweicloud.com/imag/m.jpg","link":"/","description":"离婚后看淡人生","socials":{"github":"https://github.com/FAKERSMILE","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/3494374914656981/favlist"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"Sychronized详解","uid":"2d6047dcb37a308542a367e2837e0e0c","slug":"并发/Sychronized详解","date":"2024-12-03T15:23:37.000Z","updated":"2024-12-03T16:35:43.397Z","comments":true,"path":"api/articles/并发/Sychronized详解.json","keywords":null,"cover":"https://i.pinimg.com/474x/2a/f8/28/2af828adf433f313bb63c977f587c209.jpg","text":"synchronized的使用在应用Sychronized关键字时需要把握如下注意点： 一把锁只能同时被一个线程获取，没有获得锁的线程只能等待； 每个实例都对应...","permalink":"/post/并发/Sychronized详解","photos":[],"count_time":{"symbolsCount":"6.4k","symbolsTime":"6 mins."},"categories":[{"name":"八股","slug":"八股","count":14,"path":"api/categories/八股.json"}],"tags":[{"name":"java","slug":"java","count":12,"path":"api/tags/java.json"},{"name":"并发框架","slug":"并发框架","count":6,"path":"api/tags/并发框架.json"}],"author":{"name":"Ivan","slug":"blog-author","avatar":"https://yslcrush.obs.cn-south-1.myhuaweicloud.com/imag/m.jpg","link":"/","description":"离婚后看淡人生","socials":{"github":"https://github.com/FAKERSMILE","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/3494374914656981/favlist"}}}}},"next_post":{"title":"锁的概念","uid":"6f65c61888737e8d4204dac5a8495701","slug":"并发/锁的概念","date":"2024-12-03T15:13:49.000Z","updated":"2024-12-03T16:35:43.405Z","comments":true,"path":"api/articles/并发/锁的概念.json","keywords":null,"cover":"https://i.pinimg.com/474x/8b/cf/58/8bcf5852517ffb57d8fdd8fd009da50c.jpg","text":"导图 乐观锁 VS 悲观锁乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。 先说概念。对于同一个数...","permalink":"/post/并发/锁的概念","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"八股","slug":"八股","count":14,"path":"api/categories/八股.json"}],"tags":[{"name":"java","slug":"java","count":12,"path":"api/tags/java.json"},{"name":"并发框架","slug":"并发框架","count":6,"path":"api/tags/并发框架.json"}],"author":{"name":"Ivan","slug":"blog-author","avatar":"https://yslcrush.obs.cn-south-1.myhuaweicloud.com/imag/m.jpg","link":"/","description":"离婚后看淡人生","socials":{"github":"https://github.com/FAKERSMILE","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/3494374914656981/favlist"}}}}}}