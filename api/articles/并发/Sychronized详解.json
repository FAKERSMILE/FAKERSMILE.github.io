{"title":"Sychronized详解","uid":"2d6047dcb37a308542a367e2837e0e0c","slug":"并发/Sychronized详解","date":"2024-12-03T15:23:37.000Z","updated":"2024-12-03T16:35:43.397Z","comments":true,"path":"api/articles/并发/Sychronized详解.json","keywords":null,"cover":"https://i.pinimg.com/474x/2a/f8/28/2af828adf433f313bb63c977f587c209.jpg","content":"<h2 id=\"synchronized的使用\"><a href=\"#synchronized的使用\" class=\"headerlink\" title=\"synchronized的使用\"></a><a href=\"#synchronized%E7%9A%84%E4%BD%BF%E7%94%A8\">synchronized的使用</a></h2><p>在应用Sychronized关键字时需要把握如下注意点：</p>\n<ul>\n<li>一把锁只能同时被一个线程获取，没有获得锁的线程只能等待；</li>\n<li>每个实例都对应有自己的一把锁(this),不同实例之间互不影响；例外：锁对象是*.class以及synchronized修饰的是static方法的时候，所有对象公用同一把锁</li>\n<li>synchronized修饰的方法，无论方法正常执行完毕还是抛出异常，都会释放锁</li>\n</ul>\n<h2 id=\"synchronized原理分析\"><a href=\"#synchronized原理分析\" class=\"headerlink\" title=\"synchronized原理分析\"></a><a href=\"#synchronized%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90\">synchronized原理分析</a></h2><h4 id=\"加锁和释放锁的原理\"><a href=\"#加锁和释放锁的原理\" class=\"headerlink\" title=\"加锁和释放锁的原理\"></a><a href=\"#%E5%8A%A0%E9%94%81%E5%92%8C%E9%87%8A%E6%94%BE%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86\">加锁和释放锁的原理</a></h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test &#123;</span><br><span class=\"line\">    Object object = new Object();</span><br><span class=\"line\">    </span><br><span class=\"line\">    public void func()&#123;</span><br><span class=\"line\">        synchronized(object)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        method();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static void method()&#123;</span><br><span class=\"line\">        System.out.println(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>生成的字节码（非完整，只关注函数func）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void func();</span><br><span class=\"line\">    descriptor: ()V</span><br><span class=\"line\">    flags: (0x0001) ACC_PUBLIC</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=2, locals=3, args_size=1</span><br><span class=\"line\">         0: aload_0</span><br><span class=\"line\">         1: getfield      #7                  // Field object:Ljava/lang/Object;</span><br><span class=\"line\">         4: dup</span><br><span class=\"line\">         5: astore_1</span><br><span class=\"line\">         6: monitorenter // 注意这里</span><br><span class=\"line\">         7: aload_1</span><br><span class=\"line\">         8: monitorexit // 注意这里</span><br><span class=\"line\">         9: goto          17</span><br><span class=\"line\">        12: astore_2</span><br><span class=\"line\">        13: aload_1</span><br><span class=\"line\">        14: monitorexit // 注意这里</span><br><span class=\"line\">        15: aload_2</span><br><span class=\"line\">        16: athrow</span><br><span class=\"line\">        17: invokestatic  #13                 // Method method:()V</span><br><span class=\"line\">        20: return</span><br><span class=\"line\">      Exception table:</span><br><span class=\"line\">         from    to  target type</span><br><span class=\"line\">             7     9    12   any</span><br><span class=\"line\">            12    15    12   any</span><br></pre></td></tr></table></figure>\n\n<p><code>Monitorenter</code>和<code>Monitorexit</code>指令，会让对象在执行，使其锁计数器加1或者减1。每一个对象在同一时间只与一个monitor(锁)相关联，而一个monitor在同一时间只能被一个线程获得，一个对象在尝试获得与这个对象相关联的Monitor锁的所有权的时候，monitorenter指令会发生如下3中情况之一：</p>\n<ul>\n<li>monitor计数器为0，意味着目前还没有被获得，那这个线程就会立刻获得然后把锁计数器+1，一旦+1，别的线程再想获取，就需要等待</li>\n<li>如果这个monitor已经拿到了这个锁的所有权，又重入了这把锁，那锁计数器就会累加，变成2，并且随着重入的次数，会一直累加</li>\n<li>这把锁已经被别的线程获取了，等待锁释放</li>\n</ul>\n<p><code>monitorexit指令</code>：释放对于monitor的所有权，释放过程很简单，就是讲monitor的计数器减1，如果减完以后，计数器不是0，则代表刚才是重入进来的，当前线程还继续持有这把锁的所有权，如果计数器变成0，则代表当前线程不再拥有该monitor的所有权，即释放锁。</p>\n<p><img src=\"https://www.kaiven666.online/images/image-20241103144511876.png\" alt=\"image-20241103144511876\"></p>\n<p>该图可以看出，任意线程对Object的访问，首先要获得Object的监视器，如果获取失败，该线程就进入同步状态，线程状态变为BLOCKED，当Object的监视器占有者释放后，在同步队列中得线程就会有机会重新获取该监视器.</p>\n<p>(这也是可重入的原理)</p>\n<h4 id=\"保证可见性的原理：内存模型和happens-before规则\"><a href=\"#保证可见性的原理：内存模型和happens-before规则\" class=\"headerlink\" title=\"保证可见性的原理：内存模型和happens-before规则\"></a><a href=\"#%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7%E7%9A%84%E5%8E%9F%E7%90%86-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8Chappens-before%E8%A7%84%E5%88%99\">保证可见性的原理：内存模型和happens-before规则</a></h4><p>Synchronized的happens-before规则，即监视器锁规则：对同一个监视器的解锁，happens-before于对该监视器的加锁。</p>\n<p>（这是JVM对你的一个承诺）</p>\n<h2 id=\"JVM中锁的优化\"><a href=\"#JVM中锁的优化\" class=\"headerlink\" title=\"JVM中锁的优化\"></a><a href=\"#jvm%E4%B8%AD%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96\">JVM中锁的优化</a></h2><p>简单来说在JVM中monitorenter和monitorexit字节码依赖于底层的操作系统的Mutex Lock来实现的，但是由于使用Mutex Lock需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的；然而在现实中的大部分情况下，同步方法是运行在单线程环境(无锁竞争环境)如果每次都调用Mutex Lock那么将严重的影响程序的性能。<strong>不过在jdk1.6中对锁的实现引入了大量的优化，如锁粗化(Lock Coarsening)、锁消除(Lock Elimination)、轻量级锁(Lightweight Locking)、偏向锁(Biased Locking)、适应性自旋(Adaptive Spinning)等技术来减少锁操作的开销</strong>。</p>\n<ul>\n<li><code>锁粗化(Lock Coarsening)</code>：也就是减少不必要的紧连在一起的unlock，lock操作，将多个连续的锁扩展成一个范围更大的锁。</li>\n<li><code>锁消除(Lock Elimination)</code>：通过运行时JIT编译器的逃逸分析来消除一些没有在当前同步块以外被其他线程共享的数据的锁保护，通过逃逸分析也可以在线程本的Stack上进行对象空间的分配(同时还可以减少Heap上的垃圾收集开销)。</li>\n<li><code>轻量级锁(Lightweight Locking)</code>：这种锁实现的背后基于这样一种假设，即在真实的情况下我们程序中的大部分同步代码一般都处于无锁竞争状态(即单线程执行环境)，在无锁竞争的情况下完全可以避免调用操作系统层面的重量级互斥锁，取而代之的是在monitorenter和monitorexit中只需要依靠一条CAS原子指令就可以完成锁的获取及释放。当存在锁竞争的情况下，执行CAS指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒(具体处理步骤下面详细讨论)。</li>\n<li><code>偏向锁(Biased Locking)</code>：是为了在无锁竞争的情况下避免在锁获取过程中执行不必要的CAS原子指令，因为CAS原子指令虽然相对于重量级锁来说开销比较小但还是存在非常可观的本地延迟。</li>\n<li><code>适应性自旋(Adaptive Spinning)</code>：当线程在获取轻量级锁的过程中执行CAS操作失败时，在进入与monitor相关联的操作系统重量级锁(mutex semaphore)前会进入忙等待(Spinning)然后再次尝试，当尝试一定的次数后如果仍然没有成功则调用与该monitor关联的semaphore(即互斥锁)进入到阻塞状态。</li>\n</ul>\n<h4 id=\"锁的类型\"><a href=\"#锁的类型\" class=\"headerlink\" title=\"锁的类型\"></a><a href=\"#%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B\">锁的类型</a></h4><p>在Java SE 1.6里Synchronied同步锁，一共有四种状态：<code>无锁</code>、<code>偏向锁</code>、<code>轻量级锁</code>、<code>重量级锁</code>，它会随着竞争情况逐渐升级。锁可以升级但是不可以降级，目的是为了提供获取锁和释放锁的效率。</p>\n<p>（ 锁膨胀方向： 无锁 → 偏向锁 → 轻量级锁 → 重量级锁 (此过程是不可逆的) ）</p>\n<h6 id=\"自旋锁与自适应自旋锁\"><a href=\"#自旋锁与自适应自旋锁\" class=\"headerlink\" title=\"自旋锁与自适应自旋锁\"></a><a href=\"#%E8%87%AA%E6%97%8B%E9%94%81%E4%B8%8E%E8%87%AA%E9%80%82%E5%BA%94%E8%87%AA%E6%97%8B%E9%94%81\">自旋锁与自适应自旋锁</a></h6><p>引入背景：大家都知道，在没有加入锁优化时，Synchronized是一个非常“胖大”的家伙。在多线程竞争锁时，当一个线程获取锁时，它会阻塞所有正在竞争的线程，这样对性能带来了极大的影响。在挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作对系统的并发性能带来了很大的压力。同时HotSpot团队注意到在很多情况下，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和回复阻塞线程并不值得。在如今多处理器环境下，完全可以让另一个没有获取到锁的线程在门外等待一会(自旋)，但不放弃CPU的执行时间。等待持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需要让线程执行一个忙循环(自旋)，这便是自旋锁由来的原因。</p>\n<p>自旋锁早在JDK1.4 中就引入了，只是当时默认时关闭的。在JDK 1.6后默认为开启状态。自旋锁本质上与阻塞并不相同，先不考虑其对多处理器的要求，如果锁占用的时间非常的短，那么自旋锁的性能会非常的好，相反，其会带来更多的性能开销(因为在线程自旋时，始终会占用CPU的时间片，如果锁占用的时间太长，那么自旋的线程会白白消耗掉CPU资源)。因此自旋等待的时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获取到锁，就应该使用传统的方式去挂起线程了，在JDK定义中，自旋锁默认的自旋次数为10次，用户可以使用参数<code>-XX:PreBlockSpin</code>来更改。</p>\n<p>可是现在又出现了一个问题：如果线程锁在线程自旋刚结束就释放掉了锁，那么是不是有点得不偿失。所以这时候我们需要更加聪明的锁来实现更加灵活的自旋。来提高并发的性能。(这里则需要自适应自旋锁！)</p>\n<p>在JDK 1.6中引入了自适应自旋锁。这就意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋 时间及锁的拥有者的状态来决定的。如果在同一个锁对象上，自旋等待刚刚成功获取过锁，并且持有锁的线程正在运行中，那么JVM会认为该锁自旋获取到锁的可能性很大，会自动增加等待时间。比如增加到100此循环。相反，如果对于某个锁，自旋很少成功获取锁。那再以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，JVM对程序的锁的状态预测会越来越准确，JVM也会越来越聪明。</p>\n<h4 id=\"锁消除\"><a href=\"#锁消除\" class=\"headerlink\" title=\"锁消除\"></a><a href=\"#%E9%94%81%E6%B6%88%E9%99%A4\">锁消除</a></h4><p>锁消除是指虚拟机即时编译器再运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持。意思就是：JVM会判断再一段程序中的同步明显不会逃逸出去从而被其他线程访问到，那JVM就把它们当作栈上数据对待，认为这些数据是线程独有的，不需要加同步。此时就会进行锁消除。</p>\n<p>当然在实际开发中，我们很清楚的知道哪些是线程独有的，不需要加同步锁，但是在Java API中有很多方法都是加了同步的，那么此时JVM会判断这段代码是否需要加锁。如果数据并不会逃逸，则会进行锁消除。</p>\n<h4 id=\"锁粗化\"><a href=\"#锁粗化\" class=\"headerlink\" title=\"锁粗化\"></a><a href=\"#%E9%94%81%E7%B2%97%E5%8C%96\">锁粗化</a></h4><p>原则上，我们都知道在加同步锁时，尽可能的将同步块的作用范围限制到尽量小的范围(只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小。在存在锁同步竞争中，也可以使得等待锁的线程尽早的拿到锁)。</p>\n<p>大部分上述情况是完美正确的，但是如果存在连串的一系列操作都对同一个对象反复加锁和解锁，甚至加锁操作时出现在循环体中的，那即使没有线程竞争，频繁的进行互斥同步操作也会导致不必要的性能操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static String test04(String s1, String s2, String s3) &#123;</span><br><span class=\"line\">    StringBuffer sb = new StringBuffer();</span><br><span class=\"line\">    sb.append(s1);</span><br><span class=\"line\">    sb.append(s2);</span><br><span class=\"line\">    sb.append(s3);</span><br><span class=\"line\">    return sb.toString();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上述的连续append()操作中就属于这类情况。JVM会检测到这样一连串的操作都是对同一个对象加锁，那么JVM会将加锁同步的范围扩展(粗化)到整个一系列操作的 外部，使整个一连串的append()操作只需要加锁一次就可以了。</p>\n<h4 id=\"轻量级锁\"><a href=\"#轻量级锁\" class=\"headerlink\" title=\"轻量级锁\"></a><a href=\"#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81\">轻量级锁</a></h4><p>在JDK 1.6之后引入的轻量级锁，需要注意的是轻量级锁并不是替代重量级锁的，而是对在大多数情况下同步块并不会有竞争出现提出的一种优化。它可以减少重量级锁对线程的阻塞带来的线程开销。从而提高并发性能。</p>\n<p>如果要理解轻量级锁，那么必须先要了解HotSpot虚拟机中对象头的内存布局。上面介绍Java对象头也详细介绍过。在对象头中(<code>Object Header</code>)存在两部分。第一部分用于存储对象自身的运行时数据，<code>HashCode</code>、<code>GC Age</code>、<code>锁标记位</code>、<code>是否为偏向锁</code>。等。一般为32位或者64位(视操作系统位数定)。官方称之为<code>Mark Word</code>，它是实现轻量级锁和偏向锁的关键。 另外一部分存储的是指向方法区对象类型数据的指针(<code>Klass Point</code>)，如果对象是数组的话，还会有一个额外的部分用于存储数据的长度。</p>\n<p>在线程执行同步块之前，JVM会先在当前线程的栈帧中创建一个名为锁记录(<code>Lock Record</code>)的空间，用于存储锁对象目前的<code>Mark Word</code>的拷贝(JVM会将对象头中的<code>Mark Word</code>拷贝到锁记录中，官方称为<code>Displaced Mark Ward</code>)这个时候线程堆栈与对象头的状态如图：</p>\n<p><img src=\"https://www.kaiven666.online/images/image-20241103151117782.png\" alt=\"image-20241103151117782\"></p>\n<p>如上图所示：如果当前对象没有被锁定，那么锁标志位为01状态，JVM在执行当前线程时，首先会在当前线程栈帧中创建锁记录<code>Lock Record</code>的空间用于存储锁对象目前的<code>Mark Word</code>的拷贝。</p>\n<p>然后，虚拟机使用CAS操作将标记字段Mark Word拷贝到锁记录中，并且将<code>Mark Word</code>更新为指向<code>Lock Record</code>的指针。如果更新成功了，那么这个线程就拥用了该对象的锁，并且对象Mark Word的锁标志位更新为(<code>Mark Word</code>中最后的2bit)00，即表示此对象处于轻量级锁定状态，如图：</p>\n<p><img src=\"https://www.kaiven666.online/images/image-20241103151315700.png\" alt=\"image-20241103151315700\"></p>\n<p>如果这个更新操作失败，JVM会检查当前的<code>Mark Word</code>中是否存在指向当前线程的栈帧的指针，如果有，说明该锁已经被获取，可以直接调用。如果没有，则说明该锁被其他线程抢占了，如果有两条以上的线程竞争同一个锁，那轻量级锁就不再有效，直接膨胀为重量级锁，没有获得锁的线程会被阻塞。此时，锁的标志位为<code>10.Mark Word</code>中存储的指向重量级锁的指针。</p>\n<p>轻量级解锁时，会使用原子的CAS操作将<code>Displaced Mark Word</code>替换回到对象头中，如果成功，则表示没有发生竞争关系。如果失败，表示当前锁存在竞争关系。锁就会膨胀成重量级锁。两个线程同时争夺锁，导致锁膨胀的流程图如下：</p>\n<p><img src=\"https://www.kaiven666.online/images/image-20241103151337255.png\" alt=\"image-20241103151337255\"></p>\n<h4 id=\"偏向锁\"><a href=\"#偏向锁\" class=\"headerlink\" title=\"偏向锁\"></a><a href=\"#%E5%81%8F%E5%90%91%E9%94%81\">偏向锁</a></h4><p>引入背景：在大多实际环境下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获取，那么在同一个线程反复获取所释放锁中，其中并还没有锁的竞争，那么这样看上去，多次的获取锁和释放锁带来了很多不必要的性能开销和上下文切换。</p>\n<p>为了解决这一问题，HotSpot的作者在Java SE 1.6 中对Synchronized进行了优化，引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁。只需要简单的测试一下对象头的<code>Mark Word</code>里是否存储着指向当前线程的偏向锁。如果成功，表示线程已经获取到了锁。</p>\n<p><img src=\"https://www.kaiven666.online/images/image-20241103151743128.png\" alt=\"image-20241103151743128\"></p>\n<p>偏向锁使用了一种等待竞争出现才会释放锁的机制。所以当其他线程尝试获取偏向锁时，持有偏向锁的线程才会释放锁。但是偏向锁的撤销需要等到全局安全点(就是当前线程没有正在执行的字节码)。它会首先暂停拥有偏向锁的线程，让你后检查持有偏向锁的线程是否活着。如果线程不处于活动状态，直接将对象头设置为无锁状态。如果线程活着，JVM会遍历栈帧中的锁记录，栈帧中的锁记录和对象头要么偏向于其他线程，要么恢复到无锁状态或者标记对象不适合作为偏向锁。</p>\n<p><img src=\"https://www.kaiven666.online/images/image-20241103151944968.png\" alt=\"image-20241103151944968\"></p>\n<h4 id=\"锁的优缺点对比\"><a href=\"#锁的优缺点对比\" class=\"headerlink\" title=\"锁的优缺点对比\"></a><a href=\"#%E9%94%81%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%AF%B9%E6%AF%94\">锁的优缺点对比</a></h4><p><img src=\"https://www.kaiven666.online/images/image-20241103152108923.png\" alt=\"image-20241103152108923\"></p>\n<hr>\n","text":"synchronized的使用在应用Sychronized关键字时需要把握如下注意点： 一把锁只能同时被一个线程获取，没有获得锁的线程只能等待； 每个实例都对应...","permalink":"/post/并发/Sychronized详解","photos":[],"count_time":{"symbolsCount":"6.4k","symbolsTime":"6 mins."},"categories":[{"name":"八股","slug":"八股","count":22,"path":"api/categories/八股.json"}],"tags":[{"name":"java","slug":"java","count":15,"path":"api/tags/java.json"},{"name":"并发框架","slug":"并发框架","count":7,"path":"api/tags/并发框架.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#synchronized%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">synchronized的使用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#synchronized%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90\"><span class=\"toc-text\">synchronized原理分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8A%A0%E9%94%81%E5%92%8C%E9%87%8A%E6%94%BE%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">加锁和释放锁的原理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9A%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8Chappens-before%E8%A7%84%E5%88%99\"><span class=\"toc-text\">保证可见性的原理：内存模型和happens-before规则</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#JVM%E4%B8%AD%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">JVM中锁的优化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">锁的类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E8%87%AA%E6%97%8B%E9%94%81%E4%B8%8E%E8%87%AA%E9%80%82%E5%BA%94%E8%87%AA%E6%97%8B%E9%94%81\"><span class=\"toc-text\">自旋锁与自适应自旋锁</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%94%81%E6%B6%88%E9%99%A4\"><span class=\"toc-text\">锁消除</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%94%81%E7%B2%97%E5%8C%96\"><span class=\"toc-text\">锁粗化</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81\"><span class=\"toc-text\">轻量级锁</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%81%8F%E5%90%91%E9%94%81\"><span class=\"toc-text\">偏向锁</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%94%81%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%AF%B9%E6%AF%94\"><span class=\"toc-text\">锁的优缺点对比</span></a></li></ol></li></ol></li></ol>","author":{"name":"Ivan","slug":"blog-author","avatar":"https://yslcrush.obs.cn-south-1.myhuaweicloud.com/imag/m.jpg","link":"/","description":"离婚后看淡人生","socials":{"github":"https://github.com/FAKERSMILE","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/3494374914656981/favlist"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"final详解","uid":"da333f82be06d5afcb21795dbc6a2364","slug":"并发/final详解","date":"2024-12-03T15:28:28.000Z","updated":"2024-12-03T16:35:43.378Z","comments":true,"path":"api/articles/并发/final详解.json","keywords":null,"cover":"https://i.pinimg.com/474x/49/17/b8/4917b83d8ea91c9652077becbf757e86.jpg","text":"final基础使用修饰类当某个类的整体定义为final时，就表明了你不能打算继承该类，而且也不允许别人这么做。即这个类是不能有子类的。 注意：final类中的所...","permalink":"/post/并发/final详解","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"八股","slug":"八股","count":22,"path":"api/categories/八股.json"}],"tags":[{"name":"java","slug":"java","count":15,"path":"api/tags/java.json"},{"name":"并发框架","slug":"并发框架","count":7,"path":"api/tags/并发框架.json"}],"author":{"name":"Ivan","slug":"blog-author","avatar":"https://yslcrush.obs.cn-south-1.myhuaweicloud.com/imag/m.jpg","link":"/","description":"离婚后看淡人生","socials":{"github":"https://github.com/FAKERSMILE","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/3494374914656981/favlist"}}}}},"next_post":{"title":"Volatile详解","uid":"4dfa428c08a3d894cc1c145fbc03603c","slug":"并发/Volatile详解","date":"2024-12-03T15:19:43.000Z","updated":"2024-12-03T16:35:43.394Z","comments":true,"path":"api/articles/并发/Volatile详解.json","keywords":null,"cover":"https://i.pinimg.com/474x/98/2e/10/982e10486f83a19d5b91ba22cd9e23a3.jpg","text":"volatile的作用详解防重排序从一个经典的双检索单例模式开始： 1234567891011121314151617public class Singleto...","permalink":"/post/并发/Volatile详解","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"八股","slug":"八股","count":22,"path":"api/categories/八股.json"}],"tags":[{"name":"java","slug":"java","count":15,"path":"api/tags/java.json"},{"name":"并发框架","slug":"并发框架","count":7,"path":"api/tags/并发框架.json"}],"author":{"name":"Ivan","slug":"blog-author","avatar":"https://yslcrush.obs.cn-south-1.myhuaweicloud.com/imag/m.jpg","link":"/","description":"离婚后看淡人生","socials":{"github":"https://github.com/FAKERSMILE","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/3494374914656981/favlist"}}}}}}