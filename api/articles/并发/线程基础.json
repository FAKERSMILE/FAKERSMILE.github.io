{"title":"线程基础","uid":"6245dd4deb5ec4d8e16e80935a8a30db","slug":"并发/线程基础","date":"2024-12-03T14:40:50.000Z","updated":"2024-12-03T16:35:43.382Z","comments":true,"path":"api/articles/并发/线程基础.json","keywords":null,"cover":"https://i.pinimg.com/236x/8b/44/3c/8b443cd6bca1516bfb6e156c5503c2c5.jpg","content":"<h2 id=\"线程状态的转换\"><a href=\"#线程状态的转换\" class=\"headerlink\" title=\"线程状态的转换\"></a><a href=\"#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E8%BD%AC%E6%8D%A2\">线程状态的转换</a></h2><h4 id=\"新建（New）\"><a href=\"#新建（New）\" class=\"headerlink\" title=\"新建（New）\"></a><a href=\"#%E6%96%B0%E5%BB%BA-new\">新建（New）</a></h4><p>创建后未启动。</p>\n<h4 id=\"可运行（Runable）\"><a href=\"#可运行（Runable）\" class=\"headerlink\" title=\"可运行（Runable）\"></a><a href=\"#%E5%8F%AF%E8%BF%90%E8%A1%8C-runable\">可运行（Runable）</a></h4><p>可能正在运行，也可能等待CPU时间片。</p>\n<h4 id=\"阻塞（Blocking）\"><a href=\"#阻塞（Blocking）\" class=\"headerlink\" title=\"阻塞（Blocking）\"></a><a href=\"#%E9%98%BB%E5%A1%9E-blocking\">阻塞（Blocking）</a></h4><p>等待获取一个排它锁，如果其他线程释放了锁，就会结束该状态。</p>\n<h4 id=\"无限期等待（Waiting）\"><a href=\"#无限期等待（Waiting）\" class=\"headerlink\" title=\"无限期等待（Waiting）\"></a><a href=\"#%E6%97%A0%E9%99%90%E6%9C%9F%E7%AD%89%E5%BE%85-waiting\">无限期等待（Waiting）</a></h4><p>等待其他线程显式的唤醒，否则不会被分配时间片。</p>\n<h4 id=\"限期等待（Timed-Waiting）\"><a href=\"#限期等待（Timed-Waiting）\" class=\"headerlink\" title=\"限期等待（Timed Waiting）\"></a><a href=\"#%E9%99%90%E6%9C%9F%E7%AD%89%E5%BE%85-timed-waiting\">限期等待（Timed Waiting）</a></h4><p>无需等待其他线程显式地唤醒，在一定时间之后被系统自动唤醒。</p>\n<h4 id=\"死亡（Terminated）\"><a href=\"#死亡（Terminated）\" class=\"headerlink\" title=\"死亡（Terminated）\"></a><a href=\"#%E6%AD%BB%E4%BA%A1-terminated\">死亡（Terminated）</a></h4><p>可以是线程结束任务之后自己结束，或产生异常而结束。</p>\n<h2 id=\"线程使用方式\"><a href=\"#线程使用方式\" class=\"headerlink\" title=\"线程使用方式\"></a><a href=\"#%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F\">线程使用方式</a></h2><p>有三种使用线程的方法:</p>\n<ul>\n<li>实现 Runnable 接口；</li>\n<li>实现 Callable 接口；</li>\n<li>继承 Thread 类。</li>\n</ul>\n<p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。</p>\n<h4 id=\"1-实现-Runnable-接口\"><a href=\"#1-实现-Runnable-接口\" class=\"headerlink\" title=\"1.实现 Runnable 接口\"></a><a href=\"#_1-%E5%AE%9E%E7%8E%B0-runnable-%E6%8E%A5%E5%8F%A3\">1.实现 Runnable 接口</a></h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyRunable implements Runnable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        System.out.println(&quot;hello world!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\">        MyRunable myRunable = new MyRunable();</span><br><span class=\"line\">        Thread thread = new Thread(myRunable);</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">        thread.join();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-实现-Callable-接口\"><a href=\"#2-实现-Callable-接口\" class=\"headerlink\" title=\"2. 实现 Callable 接口\"></a><a href=\"#_2-%E5%AE%9E%E7%8E%B0-callable-%E6%8E%A5%E5%8F%A3\">2. 实现 Callable 接口</a></h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyCallable implements Callable&lt;String&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String call() throws Exception &#123;</span><br><span class=\"line\">        return &quot;Hello World!&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws InterruptedException, ExecutionException &#123;</span><br><span class=\"line\">        MyCallable myCallable = new MyCallable();</span><br><span class=\"line\">        FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(myCallable);</span><br><span class=\"line\">        Thread thread = new Thread(futureTask);</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">        System.out.println(futureTask.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-继承Thread类\"><a href=\"#3-继承Thread类\" class=\"headerlink\" title=\"3. 继承Thread类\"></a><a href=\"#_3-%E7%BB%A7%E6%89%BFthread%E7%B1%BB\">3. 继承Thread类</a></h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyThread extends Thread &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        System.out.println(&quot;Hello World!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\">        MyThread myThread = new MyThread();</span><br><span class=\"line\">        myThread.start();</span><br><span class=\"line\">        myThread.join();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"实现接口-VS-继承-Thread-类\"><a href=\"#实现接口-VS-继承-Thread-类\" class=\"headerlink\" title=\"实现接口 VS 继承 Thread 类\"></a><a href=\"#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3-vs-%E7%BB%A7%E6%89%BF-thread-%E7%B1%BB\">实现接口 VS 继承 Thread 类</a></h4><p>实现接口会更好一些，因为:</p>\n<ul>\n<li>Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；</li>\n<li>类可能只要求可执行就行，继承整个 Thread 类开销过大。</li>\n</ul>\n<h2 id=\"基础线程机制\"><a href=\"#基础线程机制\" class=\"headerlink\" title=\"基础线程机制\"></a><a href=\"#%E5%9F%BA%E7%A1%80%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6\">基础线程机制</a></h2><h4 id=\"Executor\"><a href=\"#Executor\" class=\"headerlink\" title=\"Executor\"></a><a href=\"#executor\">Executor</a></h4><p>Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。</p>\n<p>主要有三种 Executor:</p>\n<ul>\n<li>CachedThreadPool: 一个任务创建一个线程；</li>\n<li>FixedThreadPool: 所有任务只能使用固定大小的线程；</li>\n<li>SingleThreadExecutor: 相当于大小为 1 的 FixedThreadPool。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Solution &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();</span><br><span class=\"line\">        for(int i=0;i&lt;5;i++)&#123;</span><br><span class=\"line\">            final int I = i;</span><br><span class=\"line\">            newCachedThreadPool.execute(() -&gt; &#123;</span><br><span class=\"line\">                System.out.println(&quot;hello world! &quot;+I);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        newCachedThreadPool.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Daemon\"><a href=\"#Daemon\" class=\"headerlink\" title=\"Daemon\"></a><a href=\"#daemon\">Daemon</a></h4><p>守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。</p>\n<p>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。</p>\n<p>main() 属于非守护线程。</p>\n<p>使用 setDaemon() 方法将一个线程设置为守护线程。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Solution &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Thread thread = new Thread(() -&gt; &#123;</span><br><span class=\"line\">            System.out.println(&quot;hello world!&quot;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        thread.setDaemon(true);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"sleep\"><a href=\"#sleep\" class=\"headerlink\" title=\"sleep()\"></a><a href=\"#sleep\">sleep()</a></h4><p>Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。</p>\n<p>sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\">    Thread.sleep(3000);</span><br><span class=\"line\">    System.out.println(&quot;hello world!&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"yield\"><a href=\"#yield\" class=\"headerlink\" title=\"yield()\"></a><a href=\"#yield\">yield()</a></h4><p>对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\">    Thread thread_01 = new Thread(() -&gt; &#123;</span><br><span class=\"line\">        System.out.println(1);</span><br><span class=\"line\">        Thread.yield();</span><br><span class=\"line\">        System.out.println(3);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    Thread thread_02 = new Thread(() -&gt; &#123;</span><br><span class=\"line\">        System.out.println(2);</span><br><span class=\"line\">        Thread.yield();</span><br><span class=\"line\">        System.out.println(4);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    thread_01.start();</span><br><span class=\"line\">    thread_02.start();</span><br><span class=\"line\">    thread_01.join();</span><br><span class=\"line\">    thread_02.join();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"线程中断\"><a href=\"#线程中断\" class=\"headerlink\" title=\"线程中断\"></a><a href=\"#%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD\">线程中断</a></h2><p>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。</p>\n<h4 id=\"InterruptedException\"><a href=\"#InterruptedException\" class=\"headerlink\" title=\"InterruptedException\"></a><a href=\"#interruptedexception\">InterruptedException</a></h4><p>通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I&#x2F;O 阻塞和 synchronized 锁阻塞。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\">    Thread thread = new Thread(() -&gt; &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Thread.sleep(3000);</span><br><span class=\"line\">            System.out.println(&quot;hello&quot;);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            System.out.println(&quot;我被干掉了&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    thread.start();</span><br><span class=\"line\">    Thread.sleep(1000);</span><br><span class=\"line\">    thread.interrupt();</span><br><span class=\"line\">    thread.join();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"interrupted\"><a href=\"#interrupted\" class=\"headerlink\" title=\"interrupted()\"></a><a href=\"#interrupted\">interrupted()</a></h4><p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。</p>\n<p>但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyThread extends Thread &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        while (!interrupted()) &#123;</span><br><span class=\"line\">            System.out.println(&quot;没有被打断&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(&quot;完蛋了！&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\">        MyThread myThread = new MyThread();</span><br><span class=\"line\">        myThread.start();</span><br><span class=\"line\">        Thread.sleep(1000);</span><br><span class=\"line\">        myThread.interrupt();</span><br><span class=\"line\">        myThread.join();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Executor-的中断操作\"><a href=\"#Executor-的中断操作\" class=\"headerlink\" title=\"Executor 的中断操作\"></a><a href=\"#executor-%E7%9A%84%E4%B8%AD%E6%96%AD%E6%93%8D%E4%BD%9C\">Executor 的中断操作</a></h4><p>调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\">    ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();</span><br><span class=\"line\">    newCachedThreadPool.execute(() -&gt; &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Thread.sleep(3000);</span><br><span class=\"line\">            System.out.println(&quot;hello world&quot;);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            System.out.println(&quot;被中断喽&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    newCachedThreadPool.shutdownNow();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) throws InterruptedException, ExecutionException &#123;</span><br><span class=\"line\">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class=\"line\">    Future&lt;Object&gt; submit = executorService.submit(() -&gt; &#123;</span><br><span class=\"line\">        for(int i=0;i&lt;100000000;i++)&#123;</span><br><span class=\"line\">            System.out.println(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    submit.cancel(true);</span><br><span class=\"line\">    System.out.println(&quot;hello&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"线程互斥同步\"><a href=\"#线程互斥同步\" class=\"headerlink\" title=\"线程互斥同步\"></a><a href=\"#%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5\">线程互斥同步</a></h2><p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。</p>\n<h4 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a><a href=\"#synchronized\">synchronized</a></h4><h6 id=\"1-同步一个代码块\"><a href=\"#1-同步一个代码块\" class=\"headerlink\" title=\"1. 同步一个代码块\"></a><a href=\"#_1-%E5%90%8C%E6%AD%A5%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%A0%81%E5%9D%97\">1. 同步一个代码块</a></h6><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Test &#123;</span><br><span class=\"line\">    public void func() &#123;</span><br><span class=\"line\">        synchronized (this) &#123;</span><br><span class=\"line\">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">                System.out.println(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Test test = new Test();</span><br><span class=\"line\">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class=\"line\">        executorService.execute(() -&gt; &#123;</span><br><span class=\"line\">            test.func();</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        executorService.execute(() -&gt; &#123;</span><br><span class=\"line\">            test.func();</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        executorService.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Test &#123;</span><br><span class=\"line\">    public void func() &#123;</span><br><span class=\"line\">        synchronized (this) &#123;</span><br><span class=\"line\">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">                System.out.println(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Test test = new Test();</span><br><span class=\"line\">        Test test2 = new Test();</span><br><span class=\"line\">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class=\"line\">        executorService.execute(() -&gt; &#123;</span><br><span class=\"line\">            test.func();</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        executorService.execute(() -&gt; &#123;</span><br><span class=\"line\">            test2.func();</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        executorService.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"2-同步一个方法\"><a href=\"#2-同步一个方法\" class=\"headerlink\" title=\"2. 同步一个方法\"></a><a href=\"#_2-%E5%90%8C%E6%AD%A5%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95\">2. 同步一个方法</a></h6><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Test &#123;</span><br><span class=\"line\">    public synchronized void func() &#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">            System.out.println(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Test test = new Test();</span><br><span class=\"line\">        Test test2 = new Test();</span><br><span class=\"line\">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class=\"line\">        executorService.execute(() -&gt; &#123;</span><br><span class=\"line\">            test.func();</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        executorService.execute(() -&gt; &#123;</span><br><span class=\"line\">            test2.func();</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        executorService.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它和同步代码块一样，作用于同一个对象。</p>\n<h6 id=\"3-同步一个类\"><a href=\"#3-同步一个类\" class=\"headerlink\" title=\"3. 同步一个类\"></a><a href=\"#_3-%E5%90%8C%E6%AD%A5%E4%B8%80%E4%B8%AA%E7%B1%BB\">3. 同步一个类</a></h6><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Test &#123;</span><br><span class=\"line\">    public void func() &#123;</span><br><span class=\"line\">        synchronized (Test.class) &#123;</span><br><span class=\"line\">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">                System.out.println(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Test test = new Test();</span><br><span class=\"line\">        Test test2 = new Test();</span><br><span class=\"line\">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class=\"line\">        executorService.execute(() -&gt; &#123;</span><br><span class=\"line\">            test.func();</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        executorService.execute(() -&gt; &#123;</span><br><span class=\"line\">            test2.func();</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        executorService.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。</p>\n<h6 id=\"4-同步一个静态方法\"><a href=\"#4-同步一个静态方法\" class=\"headerlink\" title=\"4. 同步一个静态方法\"></a><a href=\"#_4-%E5%90%8C%E6%AD%A5%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95\">4. 同步一个静态方法</a></h6><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Test &#123;</span><br><span class=\"line\">    public static synchronized void func() &#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">            System.out.println(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class=\"line\">        executorService.execute(() -&gt; &#123;</span><br><span class=\"line\">            Test.func();</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        executorService.execute(() -&gt; &#123;</span><br><span class=\"line\">            Test.func();</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        executorService.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>作用于整个类。</p>\n<h4 id=\"ReentrantLock\"><a href=\"#ReentrantLock\" class=\"headerlink\" title=\"ReentrantLock\"></a><a href=\"#reentrantlock\">ReentrantLock</a></h4><p>ReentrantLock 是 java.util.concurrent(J.U.C)包中的锁。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Test &#123;</span><br><span class=\"line\">    private Lock lock;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        lock = new ReentrantLock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void func() &#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            for(int i=0;i&lt;10;i++)&#123;</span><br><span class=\"line\">                System.out.println(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Test test = new Test();</span><br><span class=\"line\">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class=\"line\">        executorService.execute(() -&gt; test.func());</span><br><span class=\"line\">        executorService.execute(() -&gt; test.func());</span><br><span class=\"line\">        executorService.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"比较\"><a href=\"#比较\" class=\"headerlink\" title=\"比较\"></a><a href=\"#%E6%AF%94%E8%BE%83\">比较</a></h4><h6 id=\"1-锁的实现\"><a href=\"#1-锁的实现\" class=\"headerlink\" title=\"1. 锁的实现\"></a><a href=\"#_1-%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0\">1. 锁的实现</a></h6><p>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</p>\n<h6 id=\"2-性能\"><a href=\"#2-性能\" class=\"headerlink\" title=\"2. 性能\"></a><a href=\"#_2-%E6%80%A7%E8%83%BD\">2. 性能</a></h6><p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</p>\n<h6 id=\"3-等待可中断\"><a href=\"#3-等待可中断\" class=\"headerlink\" title=\"3. 等待可中断\"></a><a href=\"#_3-%E7%AD%89%E5%BE%85%E5%8F%AF%E4%B8%AD%E6%96%AD\">3. 等待可中断</a></h6><p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</p>\n<p>ReentrantLock 可中断，而 synchronized 不行。</p>\n<h6 id=\"4-公平锁\"><a href=\"#4-公平锁\" class=\"headerlink\" title=\"4. 公平锁\"></a><a href=\"#_4-%E5%85%AC%E5%B9%B3%E9%94%81\">4. 公平锁</a></h6><p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</p>\n<p>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</p>\n<h6 id=\"5-锁绑定多个条件\"><a href=\"#5-锁绑定多个条件\" class=\"headerlink\" title=\"5. 锁绑定多个条件\"></a><a href=\"#_5-%E9%94%81%E7%BB%91%E5%AE%9A%E5%A4%9A%E4%B8%AA%E6%9D%A1%E4%BB%B6\">5. 锁绑定多个条件</a></h6><p>一个 ReentrantLock 可以同时绑定多个 Condition 对象。</p>\n<h4 id=\"使用选择\"><a href=\"#使用选择\" class=\"headerlink\" title=\"使用选择\"></a><a href=\"#%E4%BD%BF%E7%94%A8%E9%80%89%E6%8B%A9\">使用选择</a></h4><p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p>\n<h2 id=\"线程之间的协作\"><a href=\"#线程之间的协作\" class=\"headerlink\" title=\"线程之间的协作\"></a><a href=\"#%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8D%8F%E4%BD%9C\">线程之间的协作</a></h2><p>当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。</p>\n<h4 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join()\"></a><a href=\"#join\">join()</a></h4><p>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。</p>\n<p>（这里就不掩饰了，经常用的）</p>\n<h4 id=\"wait-notify-notifyAll\"><a href=\"#wait-notify-notifyAll\" class=\"headerlink\" title=\"wait() notify() notifyAll()\"></a><a href=\"#wait-notify-notifyall\">wait() notify() notifyAll()</a></h4><p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。</p>\n<p>它们都属于 Object 的一部分，而不属于 Thread。</p>\n<p>只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateExeception。</p>\n<p>使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Test &#123;</span><br><span class=\"line\">    public synchronized void before() &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Thread.sleep(1500);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            System.out.println(&quot;被打断lou&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(&quot;before&quot;);</span><br><span class=\"line\">        notifyAll();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public synchronized void after() &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            wait();</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(&quot;after&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Test test = new Test();</span><br><span class=\"line\">        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();</span><br><span class=\"line\">        newCachedThreadPool.execute(() -&gt; test.after());</span><br><span class=\"line\">        newCachedThreadPool.execute(() -&gt; test.before());</span><br><span class=\"line\">        newCachedThreadPool.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（以上代码有死锁的风险，如果是after函数先执行，那没有问题；如果是before先执行，就证明了after没有拿到锁，等before释放锁之后，after拿到锁，然后进入休眠状态，然后也没有人唤醒它）</p>\n<h6 id=\"wait-和-sleep-的区别\"><a href=\"#wait-和-sleep-的区别\" class=\"headerlink\" title=\"wait() 和 sleep() 的区别\"></a><a href=\"#wait-%E5%92%8C-sleep-%E7%9A%84%E5%8C%BA%E5%88%AB\">wait() 和 sleep() 的区别</a></h6><ul>\n<li>wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法</li>\n<li>wait() 会释放锁，sleep() 不会</li>\n</ul>\n<h4 id=\"await-signal-signalAll\"><a href=\"#await-signal-signalAll\" class=\"headerlink\" title=\"await() signal() signalAll()\"></a><a href=\"#await-signal-signalall\">await() signal() signalAll()</a></h4><p>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Test &#123;</span><br><span class=\"line\">    private Lock lock;</span><br><span class=\"line\">    private Condition condition;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        lock = new ReentrantLock();</span><br><span class=\"line\">        condition = lock.newCondition();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public void before() &#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Thread.sleep(1500);</span><br><span class=\"line\">            System.out.println(&quot;before&quot;);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            System.out.println(&quot;被打断lou&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        finally&#123;</span><br><span class=\"line\">            condition.signalAll();</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void after() &#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            condition.await();</span><br><span class=\"line\">            System.out.println(&quot;after&quot;);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        finally&#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Test test = new Test();</span><br><span class=\"line\">        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();</span><br><span class=\"line\">        newCachedThreadPool.execute(() -&gt; test.after());</span><br><span class=\"line\">        newCachedThreadPool.execute(() -&gt; test.before());</span><br><span class=\"line\">        newCachedThreadPool.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（和上文一下，也是会有死锁的风险，虽然我没有测出来，但是理论上来说，是这样的）</p>\n<hr>\n","text":"线程状态的转换新建（New）创建后未启动。 可运行（Runable）可能正在运行，也可能等待CPU时间片。 阻塞（Blocking）等待获取一个排它锁，如果其他...","permalink":"/post/并发/线程基础","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"八股","slug":"八股","count":20,"path":"api/categories/八股.json"}],"tags":[{"name":"java","slug":"java","count":15,"path":"api/tags/java.json"},{"name":"并发框架","slug":"并发框架","count":7,"path":"api/tags/并发框架.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">线程状态的转换</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B0%E5%BB%BA%EF%BC%88New%EF%BC%89\"><span class=\"toc-text\">新建（New）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E8%BF%90%E8%A1%8C%EF%BC%88Runable%EF%BC%89\"><span class=\"toc-text\">可运行（Runable）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%98%BB%E5%A1%9E%EF%BC%88Blocking%EF%BC%89\"><span class=\"toc-text\">阻塞（Blocking）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%97%A0%E9%99%90%E6%9C%9F%E7%AD%89%E5%BE%85%EF%BC%88Waiting%EF%BC%89\"><span class=\"toc-text\">无限期等待（Waiting）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%99%90%E6%9C%9F%E7%AD%89%E5%BE%85%EF%BC%88Timed-Waiting%EF%BC%89\"><span class=\"toc-text\">限期等待（Timed Waiting）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%AD%BB%E4%BA%A1%EF%BC%88Terminated%EF%BC%89\"><span class=\"toc-text\">死亡（Terminated）</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">线程使用方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%AE%9E%E7%8E%B0-Runnable-%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">1.实现 Runnable 接口</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%AE%9E%E7%8E%B0-Callable-%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">2. 实现 Callable 接口</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E7%BB%A7%E6%89%BFThread%E7%B1%BB\"><span class=\"toc-text\">3. 继承Thread类</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3-VS-%E7%BB%A7%E6%89%BF-Thread-%E7%B1%BB\"><span class=\"toc-text\">实现接口 VS 继承 Thread 类</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E7%A1%80%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">基础线程机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Executor\"><span class=\"toc-text\">Executor</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Daemon\"><span class=\"toc-text\">Daemon</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#sleep\"><span class=\"toc-text\">sleep()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#yield\"><span class=\"toc-text\">yield()</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD\"><span class=\"toc-text\">线程中断</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#InterruptedException\"><span class=\"toc-text\">InterruptedException</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#interrupted\"><span class=\"toc-text\">interrupted()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Executor-%E7%9A%84%E4%B8%AD%E6%96%AD%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">Executor 的中断操作</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5\"><span class=\"toc-text\">线程互斥同步</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#synchronized\"><span class=\"toc-text\">synchronized</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#1-%E5%90%8C%E6%AD%A5%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%A0%81%E5%9D%97\"><span class=\"toc-text\">1. 同步一个代码块</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#2-%E5%90%8C%E6%AD%A5%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2. 同步一个方法</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#3-%E5%90%8C%E6%AD%A5%E4%B8%80%E4%B8%AA%E7%B1%BB\"><span class=\"toc-text\">3. 同步一个类</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#4-%E5%90%8C%E6%AD%A5%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">4. 同步一个静态方法</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ReentrantLock\"><span class=\"toc-text\">ReentrantLock</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">比较</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#1-%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">1. 锁的实现</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#2-%E6%80%A7%E8%83%BD\"><span class=\"toc-text\">2. 性能</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#3-%E7%AD%89%E5%BE%85%E5%8F%AF%E4%B8%AD%E6%96%AD\"><span class=\"toc-text\">3. 等待可中断</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#4-%E5%85%AC%E5%B9%B3%E9%94%81\"><span class=\"toc-text\">4. 公平锁</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#5-%E9%94%81%E7%BB%91%E5%AE%9A%E5%A4%9A%E4%B8%AA%E6%9D%A1%E4%BB%B6\"><span class=\"toc-text\">5. 锁绑定多个条件</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E9%80%89%E6%8B%A9\"><span class=\"toc-text\">使用选择</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8D%8F%E4%BD%9C\"><span class=\"toc-text\">线程之间的协作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#join\"><span class=\"toc-text\">join()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#wait-notify-notifyAll\"><span class=\"toc-text\">wait() notify() notifyAll()</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#wait-%E5%92%8C-sleep-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">wait() 和 sleep() 的区别</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#await-signal-signalAll\"><span class=\"toc-text\">await() signal() signalAll()</span></a></li></ol></li></ol></li></ol>","author":{"name":"Ivan","slug":"blog-author","avatar":"https://yslcrush.obs.cn-south-1.myhuaweicloud.com/imag/m.jpg","link":"/","description":"离婚后看淡人生","socials":{"github":"https://github.com/FAKERSMILE","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/3494374914656981/favlist"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"锁的概念","uid":"6f65c61888737e8d4204dac5a8495701","slug":"并发/锁的概念","date":"2024-12-03T15:13:49.000Z","updated":"2024-12-03T16:35:43.405Z","comments":true,"path":"api/articles/并发/锁的概念.json","keywords":null,"cover":"https://i.pinimg.com/474x/8b/cf/58/8bcf5852517ffb57d8fdd8fd009da50c.jpg","text":"导图 乐观锁 VS 悲观锁乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。 先说概念。对于同一个数...","permalink":"/post/并发/锁的概念","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"八股","slug":"八股","count":20,"path":"api/categories/八股.json"}],"tags":[{"name":"java","slug":"java","count":15,"path":"api/tags/java.json"},{"name":"并发框架","slug":"并发框架","count":7,"path":"api/tags/并发框架.json"}],"author":{"name":"Ivan","slug":"blog-author","avatar":"https://yslcrush.obs.cn-south-1.myhuaweicloud.com/imag/m.jpg","link":"/","description":"离婚后看淡人生","socials":{"github":"https://github.com/FAKERSMILE","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/3494374914656981/favlist"}}}}},"next_post":{"title":"并发基础","uid":"f5276a6470bcf00967ce9121d16c19cd","slug":"并发/并发基础","date":"2024-12-03T14:35:07.000Z","updated":"2024-12-03T16:35:43.402Z","comments":true,"path":"api/articles/并发/并发基础.json","keywords":null,"cover":"https://i.pinimg.com/236x/c5/b6/af/c5b6afd190cee163764ed775a7dc1d20.jpg","text":"为什么需要多线程？早期的单CPU时代，CPU制作厂商沉迷于提高单个核心的计算能力。但是随着时间的推移，提高单核心的计算能力越来越困难了。于是乎，堆核心成为了快速...","permalink":"/post/并发/并发基础","photos":[],"count_time":{"symbolsCount":"6.6k","symbolsTime":"6 mins."},"categories":[{"name":"八股","slug":"八股","count":20,"path":"api/categories/八股.json"}],"tags":[{"name":"java","slug":"java","count":15,"path":"api/tags/java.json"},{"name":"并发基础","slug":"并发基础","count":1,"path":"api/tags/并发基础.json"},{"name":"并发框架","slug":"并发框架","count":7,"path":"api/tags/并发框架.json"}],"author":{"name":"Ivan","slug":"blog-author","avatar":"https://yslcrush.obs.cn-south-1.myhuaweicloud.com/imag/m.jpg","link":"/","description":"离婚后看淡人生","socials":{"github":"https://github.com/FAKERSMILE","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/3494374914656981/favlist"}}}}}}