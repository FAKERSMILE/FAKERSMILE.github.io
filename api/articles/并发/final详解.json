{"title":"final详解","uid":"da333f82be06d5afcb21795dbc6a2364","slug":"并发/final详解","date":"2024-12-03T15:28:28.000Z","updated":"2024-12-03T16:35:43.378Z","comments":true,"path":"api/articles/并发/final详解.json","keywords":null,"cover":"https://i.pinimg.com/474x/49/17/b8/4917b83d8ea91c9652077becbf757e86.jpg","content":"<h2 id=\"final基础使用\"><a href=\"#final基础使用\" class=\"headerlink\" title=\"final基础使用\"></a><a href=\"#final%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8\">final基础使用</a></h2><h4 id=\"修饰类\"><a href=\"#修饰类\" class=\"headerlink\" title=\"修饰类\"></a><a href=\"#%E4%BF%AE%E9%A5%B0%E7%B1%BB\">修饰类</a></h4><p>当某个类的整体定义为final时，就表明了你不能打算继承该类，而且也不允许别人这么做。即这个类是不能有子类的。</p>\n<p>注意：final类中的所有方法都隐式为final，因为无法覆盖他们，所以在final类中给任何方法添加final关键字是没有任何意义的。</p>\n<h4 id=\"修饰方法\"><a href=\"#修饰方法\" class=\"headerlink\" title=\"修饰方法\"></a><a href=\"#%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95\">修饰方法</a></h4><ul>\n<li><p>private 方法是隐式的final</p>\n<p>类中所有private方法都隐式地指定为final的，由于无法取用private方法，所以也就不能覆盖它。可以对private方法增添final关键字，但这样做并没有什么好处。</p>\n</li>\n<li><p>final方法是可以被重载的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class FinalExampleParent &#123;</span><br><span class=\"line\">    public final void test() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public final void test(String str) &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"修饰参数\"><a href=\"#修饰参数\" class=\"headerlink\" title=\"修饰参数\"></a><a href=\"#%E4%BF%AE%E9%A5%B0%E5%8F%82%E6%95%B0\">修饰参数</a></h4><p>Java允许在参数列表中以声明的方式将参数指明为final，这意味这你无法在方法中更改参数引用所指向的对象。这个特性主要用来向匿名内部类传递数据。</p>\n<h4 id=\"修饰变量\"><a href=\"#修饰变量\" class=\"headerlink\" title=\"修饰变量\"></a><a href=\"#%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F\">修饰变量</a></h4><h6 id=\"所有被final修饰的变量都是编译期常量嘛？\"><a href=\"#所有被final修饰的变量都是编译期常量嘛？\" class=\"headerlink\" title=\"所有被final修饰的变量都是编译期常量嘛？\"></a><a href=\"#%E6%89%80%E6%9C%89%E8%A2%ABfinal%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%8F%98%E9%87%8F%E9%83%BD%E6%98%AF%E7%BC%96%E8%AF%91%E6%9C%9F%E5%B8%B8%E9%87%8F%E5%98%9B\">所有被final修饰的变量都是编译期常量嘛？</a></h6><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test &#123;</span><br><span class=\"line\">    //编译期常量</span><br><span class=\"line\">    final int i = 1;</span><br><span class=\"line\">    final static int J = 1;</span><br><span class=\"line\">    final int[] a = &#123;1,2,3,4&#125;;</span><br><span class=\"line\">    //非编译期常量</span><br><span class=\"line\">    Random r = new Random();</span><br><span class=\"line\">    final int k = r.nextInt();</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>k的值由随机数对象决定，所以不是所有的final修饰的字段都是编译期常量，只是k的值在被初始化后无法被更改。</p>\n<h6 id=\"statci-final\"><a href=\"#statci-final\" class=\"headerlink\" title=\"statci final\"></a><a href=\"#statci-final\">statci final</a></h6><p>一个既是static又是final 的字段只占据一段不能改变的存储空间，它必须在定义的时候进行赋值，否则编译器将不予通过。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Test &#123;</span><br><span class=\"line\">    static Random r = new Random();</span><br><span class=\"line\">    final int k = r.nextInt(10);</span><br><span class=\"line\">    static final int k2 = r.nextInt(10); </span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Test t1 = new Test();</span><br><span class=\"line\">        System.out.println(&quot;k=&quot;+t1.k+&quot; k2=&quot;+t1.k2);</span><br><span class=\"line\">        Test t2 = new Test();</span><br><span class=\"line\">        System.out.println(&quot;k=&quot;+t2.k+&quot; k2=&quot;+t2.k2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以发现对于不同的对象k的值是不同的，但是k2的值却是相同的，这是为什么呢? 因为static关键字所修饰的字段并不属于一个对象，而是属于这个类的。也可简单的理解为static final所修饰的字段仅占据内存的一个一份空间，一旦被初始化之后便不会被更改。</p>\n<h2 id=\"final域重排序规则\"><a href=\"#final域重排序规则\" class=\"headerlink\" title=\"final域重排序规则\"></a><a href=\"#final%E5%9F%9F%E9%87%8D%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99\">final域重排序规则</a></h2><p>Java中，无非就是两种数据类型，基本数据类型和引用（对象）。在下文中，我们展开来看：</p>\n<h4 id=\"final域为基本类型\"><a href=\"#final域为基本类型\" class=\"headerlink\" title=\"final域为基本类型\"></a><a href=\"#final%E5%9F%9F%E4%B8%BA%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B\">final域为基本类型</a></h4><h6 id=\"写final域的重排序规则\"><a href=\"#写final域的重排序规则\" class=\"headerlink\" title=\"写final域的重排序规则\"></a><a href=\"#%E5%86%99final%E5%9F%9F%E7%9A%84%E9%87%8D%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99\">写final域的重排序规则</a></h6><p>写final域的重排序规则禁止对final域的写重排序到构造函数之外，这个规则的实现主要包含了两个方面：</p>\n<ul>\n<li>JMM禁止编译器把final域的写重排序到构造函数之外；</li>\n<li>编译器会在final域写之后，构造函数return之前，插入一个storestore屏障。这个屏障可以禁止处理器把final域的写重排序到构造函数之外。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class FinalDemo &#123;</span><br><span class=\"line\">    private int a;  //普通域</span><br><span class=\"line\">    private final int b; //final域</span><br><span class=\"line\">    private static FinalDemo finalDemo;</span><br><span class=\"line\"></span><br><span class=\"line\">    public FinalDemo() &#123;</span><br><span class=\"line\">        a = 1; // 1. 写普通域</span><br><span class=\"line\">        b = 2; // 2. 写final域</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void writer() &#123;</span><br><span class=\"line\">        finalDemo = new FinalDemo();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void reader() &#123;</span><br><span class=\"line\">        FinalDemo demo = finalDemo; // 3.读对象引用</span><br><span class=\"line\">        int a = demo.a;    //4.读普通域</span><br><span class=\"line\">        int b = demo.b;    //5.读final域</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>假设线程A执行writer方法，线程B执行reader方法。</p>\n<p>线程A在进行对象的构造时，由于b带有final域，所以写指令不会被重排序到构造函数外，而a是普通域，可能会被重排序到构造函数外。线程B读取b的值的时候，一定是可以读到最新值2的（假设对象已经构造完毕），读取a的值就不一定了，可能会读取到默认值。</p>\n<h6 id=\"读final域重排序规则\"><a href=\"#读final域重排序规则\" class=\"headerlink\" title=\"读final域重排序规则\"></a><a href=\"#%E8%AF%BBfinal%E5%9F%9F%E9%87%8D%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99\">读final域重排序规则</a></h6><p>读final域重排序规则为：在一个线程中，初次读对象引用和初次读该对象包含的final域，JMM会禁止这两个操作的重排序。(注意，这个规则仅仅是针对处理器)，处理器会在读final域操作的前面插入一个LoadLoad屏障。实际上，读对象的引用和读该对象的final域存在间接依赖性，一般处理器不会重排序这两个操作。但是有一些处理器会重排序，因此，这条禁止重排序规则就是针对这些处理器而设定的。</p>\n<p>上文的线程B在进行final域变量值b的读取时，一定会先读取对象的引用，在通过对象的引用读取对应的值。</p>\n<p>读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读这个包含这个final域的对象的引用。</p>\n<h4 id=\"final域为引用类型\"><a href=\"#final域为引用类型\" class=\"headerlink\" title=\"final域为引用类型\"></a><a href=\"#final%E5%9F%9F%E4%B8%BA%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B\">final域为引用类型</a></h4><h6 id=\"对final修饰的对象的成员域写操作\"><a href=\"#对final修饰的对象的成员域写操作\" class=\"headerlink\" title=\"对final修饰的对象的成员域写操作\"></a><a href=\"#%E5%AF%B9final%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%88%90%E5%91%98%E5%9F%9F%E5%86%99%E6%93%8D%E4%BD%9C\">对final修饰的对象的成员域写操作</a></h6><p>针对引用数据类型，final域写针对编译器和处理器重排序增加了这样的约束：在构造函数内对一个final修饰的对象的成员域的写入，与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量，这两个操作是不能被重排序的。注意这里的是“增加”也就说前面对final基本数据类型的重排序规则在这里还是使用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class FinalReferenceDemo &#123;</span><br><span class=\"line\">    final int[] arrays;</span><br><span class=\"line\">    private FinalReferenceDemo finalReferenceDemo;</span><br><span class=\"line\"></span><br><span class=\"line\">    public FinalReferenceDemo() &#123;</span><br><span class=\"line\">        arrays = new int[1];  //1</span><br><span class=\"line\">        arrays[0] = 1;        //2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void writerOne() &#123;</span><br><span class=\"line\">        finalReferenceDemo = new FinalReferenceDemo(); //3</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void writerTwo() &#123;</span><br><span class=\"line\">        arrays[0] = 2;  //4</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void reader() &#123;</span><br><span class=\"line\">        if (finalReferenceDemo != null) &#123;  //5</span><br><span class=\"line\">            int temp = finalReferenceDemo.arrays[0];  //6</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>针对上面的实例程序，线程线程A执行wirterOne方法，执行完后线程B执行writerTwo方法，然后线程C执行reader方法。</p>\n<p>由于对final域的写禁止重排序到构造方法外，因此1和3不能被重排序。由于一个final域的引用对象的成员域写入不能与随后将这个被构造出来的对象赋给引用变量重排序，因此2和3不能重排序。</p>\n<h6 id=\"对final修饰的对象的成员域读操作\"><a href=\"#对final修饰的对象的成员域读操作\" class=\"headerlink\" title=\"对final修饰的对象的成员域读操作\"></a><a href=\"#%E5%AF%B9final%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%88%90%E5%91%98%E5%9F%9F%E8%AF%BB%E6%93%8D%E4%BD%9C\">对final修饰的对象的成员域读操作</a></h6><p>JMM可以确保线程C至少能看到写线程A对final引用的对象的成员域的写入，即能看下arrays[0] &#x3D; 1，而写线程B对数组元素的写入可能看到可能看不到。JMM不保证线程B的写入对线程C可见，线程B和线程C之间存在数据竞争，此时的结果是不可预知的。如果可见的，可使用锁或者volatile。</p>\n<h4 id=\"关于final域重排序的总结\"><a href=\"#关于final域重排序的总结\" class=\"headerlink\" title=\"关于final域重排序的总结\"></a><a href=\"#%E5%85%B3%E4%BA%8Efinal%E5%9F%9F%E9%87%8D%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%BB%E7%BB%93\">关于final域重排序的总结</a></h4><p>按照final修饰的数据类型分类：</p>\n<ul>\n<li>基本数据类型:<ul>\n<li><code>final域写</code>：禁止final域写与构造方法重排序，即禁止final域写重排序到构造方法之外，从而保证该对象对所有线程可见时，该对象的final域全部已经初始化过。</li>\n<li><code>final域读</code>：禁止初次读对象的引用与读该对象包含的final域的重排序。</li>\n</ul>\n</li>\n<li>引用数据类型：<ul>\n<li><code>额外增加约束</code>：禁止在构造函数对一个final修饰的对象的成员域的写入与随后将这个被构造的对象的引用赋值给引用变量 重排序</li>\n</ul>\n</li>\n</ul>\n<hr>\n","text":"final基础使用修饰类当某个类的整体定义为final时，就表明了你不能打算继承该类，而且也不允许别人这么做。即这个类是不能有子类的。 注意：final类中的所...","permalink":"/post/并发/final详解","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"八股","slug":"八股","count":22,"path":"api/categories/八股.json"}],"tags":[{"name":"java","slug":"java","count":15,"path":"api/tags/java.json"},{"name":"并发框架","slug":"并发框架","count":7,"path":"api/tags/并发框架.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#final%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">final基础使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E9%A5%B0%E7%B1%BB\"><span class=\"toc-text\">修饰类</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">修饰方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E9%A5%B0%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">修饰参数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">修饰变量</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E6%89%80%E6%9C%89%E8%A2%ABfinal%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%8F%98%E9%87%8F%E9%83%BD%E6%98%AF%E7%BC%96%E8%AF%91%E6%9C%9F%E5%B8%B8%E9%87%8F%E5%98%9B%EF%BC%9F\"><span class=\"toc-text\">所有被final修饰的变量都是编译期常量嘛？</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#statci-final\"><span class=\"toc-text\">statci final</span></a></li></ol></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#final%E5%9F%9F%E9%87%8D%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99\"><span class=\"toc-text\">final域重排序规则</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#final%E5%9F%9F%E4%B8%BA%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">final域为基本类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E5%86%99final%E5%9F%9F%E7%9A%84%E9%87%8D%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99\"><span class=\"toc-text\">写final域的重排序规则</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E8%AF%BBfinal%E5%9F%9F%E9%87%8D%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99\"><span class=\"toc-text\">读final域重排序规则</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#final%E5%9F%9F%E4%B8%BA%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">final域为引用类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E5%AF%B9final%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%88%90%E5%91%98%E5%9F%9F%E5%86%99%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">对final修饰的对象的成员域写操作</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E5%AF%B9final%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%88%90%E5%91%98%E5%9F%9F%E8%AF%BB%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">对final修饰的对象的成员域读操作</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8Efinal%E5%9F%9F%E9%87%8D%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">关于final域重排序的总结</span></a></li></ol></li></ol></li></ol>","author":{"name":"Ivan","slug":"blog-author","avatar":"https://yslcrush.obs.cn-south-1.myhuaweicloud.com/imag/m.jpg","link":"/","description":"离婚后看淡人生","socials":{"github":"https://github.com/FAKERSMILE","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/325730313"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"SPI","uid":"5fa7811420fef5e890cc85bbf0c3fa40","slug":"java基础/SPI","date":"2024-12-03T16:25:08.000Z","updated":"2024-12-03T16:35:43.391Z","comments":true,"path":"api/articles/java基础/SPI.json","keywords":null,"cover":"https://i.pinimg.com/474x/15/0d/32/150d325e01f64442bc6855573f140b99.jpg","text":"什么是 SPI 机制？SPI（Service Provider Interface），是 JDK 内置的一种服务提供发现机制，可以用来启用框架扩展和替换组件，主...","permalink":"/post/java基础/SPI","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"八股","slug":"八股","count":22,"path":"api/categories/八股.json"}],"tags":[{"name":"java","slug":"java","count":15,"path":"api/tags/java.json"}],"author":{"name":"Ivan","slug":"blog-author","avatar":"https://yslcrush.obs.cn-south-1.myhuaweicloud.com/imag/m.jpg","link":"/","description":"离婚后看淡人生","socials":{"github":"https://github.com/FAKERSMILE","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/325730313"}}}}},"next_post":{"title":"Sychronized详解","uid":"2d6047dcb37a308542a367e2837e0e0c","slug":"并发/Sychronized详解","date":"2024-12-03T15:23:37.000Z","updated":"2024-12-03T16:35:43.397Z","comments":true,"path":"api/articles/并发/Sychronized详解.json","keywords":null,"cover":"https://i.pinimg.com/474x/2a/f8/28/2af828adf433f313bb63c977f587c209.jpg","text":"synchronized的使用在应用Sychronized关键字时需要把握如下注意点： 一把锁只能同时被一个线程获取，没有获得锁的线程只能等待； 每个实例都对应...","permalink":"/post/并发/Sychronized详解","photos":[],"count_time":{"symbolsCount":"6.4k","symbolsTime":"6 mins."},"categories":[{"name":"八股","slug":"八股","count":22,"path":"api/categories/八股.json"}],"tags":[{"name":"java","slug":"java","count":15,"path":"api/tags/java.json"},{"name":"并发框架","slug":"并发框架","count":7,"path":"api/tags/并发框架.json"}],"author":{"name":"Ivan","slug":"blog-author","avatar":"https://yslcrush.obs.cn-south-1.myhuaweicloud.com/imag/m.jpg","link":"/","description":"离婚后看淡人生","socials":{"github":"https://github.com/FAKERSMILE","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/325730313"}}}}}}