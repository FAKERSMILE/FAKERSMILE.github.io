{"title":"并发基础","uid":"f5276a6470bcf00967ce9121d16c19cd","slug":"并发/并发基础","date":"2024-12-03T14:35:07.000Z","updated":"2024-12-03T16:35:43.402Z","comments":true,"path":"api/articles/并发/并发基础.json","keywords":null,"cover":"https://i.pinimg.com/236x/c5/b6/af/c5b6afd190cee163764ed775a7dc1d20.jpg","content":"<h2 id=\"为什么需要多线程？\"><a href=\"#为什么需要多线程？\" class=\"headerlink\" title=\"为什么需要多线程？\"></a><a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%A4%9A%E7%BA%BF%E7%A8%8B\">为什么需要多线程？</a></h2><p>早期的单CPU时代，CPU制作厂商沉迷于提高单个核心的计算能力。但是随着时间的推移，提高单核心的计算能力越来越困难了。于是乎，堆核心成为了快速提高CPU计算能力的另一种途径。这样一来，多个任务就可以并行的跑在CPU的不同核心上。</p>\n<p>一个程序只是一个单线程的应用的话，无法利用现代多核心CPU的优势。所以，学习并发编程可以提高我们程序的运行效率。</p>\n<h2 id=\"线程安全示例\"><a href=\"#线程安全示例\" class=\"headerlink\" title=\"线程安全示例\"></a><a href=\"#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%A4%BA%E4%BE%8B\">线程安全示例</a></h2><p>多线程编程虽然可以提高我们程序的运行效率，但是同样也面临着线程安全或者说并发安全问题：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ThreadUnsafeExample &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private int cnt = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void add() &#123;</span><br><span class=\"line\">        cnt++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int get() &#123;</span><br><span class=\"line\">        return cnt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\">        final int threadSize = 1000;</span><br><span class=\"line\">        ThreadUnsafeExample example = new ThreadUnsafeExample();</span><br><span class=\"line\">        final CountDownLatch countDownLatch = new CountDownLatch(threadSize);</span><br><span class=\"line\">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class=\"line\">        for (int i = 0; i &lt; threadSize; i++) &#123;</span><br><span class=\"line\">            executorService.execute(() -&gt; &#123;</span><br><span class=\"line\">                example.add();</span><br><span class=\"line\">                countDownLatch.countDown();</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        countDownLatch.await();</span><br><span class=\"line\">        executorService.shutdown();</span><br><span class=\"line\">        System.out.println(example.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行的结果总是小于1000。</p>\n<h2 id=\"并发问题发生的三要素\"><a href=\"#并发问题发生的三要素\" class=\"headerlink\" title=\"并发问题发生的三要素\"></a><a href=\"#%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E5%8F%91%E7%94%9F%E7%9A%84%E4%B8%89%E8%A6%81%E7%B4%A0\">并发问题发生的三要素</a></h2><h4 id=\"1-可见性：CPU缓存引起的\"><a href=\"#1-可见性：CPU缓存引起的\" class=\"headerlink\" title=\"1. 可见性：CPU缓存引起的\"></a><a href=\"#_1-%E5%8F%AF%E8%A7%81%E6%80%A7-cpu%E7%BC%93%E5%AD%98%E5%BC%95%E8%B5%B7%E7%9A%84\">1. 可见性：CPU缓存引起的</a></h4><p><img src=\"https://www.kaiven666.online/images/image-20241102153812248.png\" alt=\"image-20241102153812248\"></p>\n<p>CPU直接与自己的L1级缓存进行交互，L1级缓存的数据来自L2，L2中的数据来自L3，L3中的数据来自内存。</p>\n<p>假设线程A和线程B并发的执行这段代码的话，线程A在CPU1上执行，线程B在CPU2上执行，会有以下这种情况：</p>\n<p>线程A将i的值从内存载入CPU1对应的缓存中，此时i的值为0；</p>\n<p>线程B将i的值从内存载入CPU2对应的缓存中，此时i的值为0；</p>\n<p>线程A执行了自增操作，CPU1缓存中的i的值为1；</p>\n<p>线程B执行了自增操作，CPU2缓存中的i的值为1；</p>\n<p>线程A将CPU1缓存i的值写入内存，内存中i的值是1；</p>\n<p>线程B将CPU2缓存i的值写入内存，内存中i的值是1。</p>\n<p>其中一次操作的值将另一次操作的值给覆盖了。</p>\n<p>本质问题就是一个线程在CPU缓存中修改了共享的值，另一个线程并不知道。</p>\n<h4 id=\"2-原子性：分时复用引起的\"><a href=\"#2-原子性：分时复用引起的\" class=\"headerlink\" title=\"2. 原子性：分时复用引起的\"></a><a href=\"#_2-%E5%8E%9F%E5%AD%90%E6%80%A7-%E5%88%86%E6%97%B6%E5%A4%8D%E7%94%A8%E5%BC%95%E8%B5%B7%E7%9A%84\">2. 原子性：分时复用引起的</a></h4><p>对于【i++】操作来说，它对应三条指令：</p>\n<ol>\n<li>将变量i从内存中读到寄存器</li>\n<li>将寄存器中i的值+1</li>\n<li>写回内存（由于缓存机制，也可能是缓存，而不是内存）</li>\n</ol>\n<p>我们都知道，CPU运作机制就是执行一条又一条的指令。无论是Linux、windows还是Max OS，它们都属于分时操作系统。CPU并发的运行着N多个程序。CPU有一个时钟硬件设备，定期向CPU发送时钟中断信号，CPU收到信号后，操作系统介入，调度下一个程序运行。</p>\n<p>所以，就算是在只有一个CPU的机器上，运行多线程的程序，由于分时复用机制，一个操作如果由多条指令集合构成，那么也会造成并发安全问题。</p>\n<h4 id=\"3-有序性：重排序引起\"><a href=\"#3-有序性：重排序引起\" class=\"headerlink\" title=\"3. 有序性：重排序引起\"></a><a href=\"#_3-%E6%9C%89%E5%BA%8F%E6%80%A7-%E9%87%8D%E6%8E%92%E5%BA%8F%E5%BC%95%E8%B5%B7\">3. 有序性：重排序引起</a></h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int i = 0;              </span><br><span class=\"line\">boolean flag = false;</span><br><span class=\"line\">i = 1;                //语句1  </span><br><span class=\"line\">flag = true;          //语句2</span><br></pre></td></tr></table></figure>\n\n<p>从我们开发的角度来看，语句1应该在语句2之前执行的，那事实真的是这样嘛？</p>\n<p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p>\n<ul>\n<li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>\n<li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>\n<li>内存系统的重排序。由于处理器使用缓存和读 &#x2F; 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>\n</ul>\n<p>从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p>\n<p><img src=\"https://www.kaiven666.online/images/image-20241102162148326.png\" alt=\"image-20241102162148326\"></p>\n<p>上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。</p>\n<h2 id=\"Java是怎么解决并发问题的？\"><a href=\"#Java是怎么解决并发问题的？\" class=\"headerlink\" title=\"Java是怎么解决并发问题的？\"></a><a href=\"#java%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E7%9A%84\">Java是怎么解决并发问题的？</a></h2><p><strong>JMM（Java内存模型）</strong>。</p>\n<p><strong>理解的第一个维度：核心知识点</strong></p>\n<p>JMM本质上可以理解为，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括：</p>\n<ul>\n<li>volatile、synchronized 和 final 三个关键字</li>\n<li>Happens-Before 规则</li>\n</ul>\n<p><strong>理解的第二个维度：可见性，有序性，原子性</strong></p>\n<ul>\n<li><h6 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a><a href=\"#%E5%8E%9F%E5%AD%90%E6%80%A7\">原子性</a></h6></li>\n</ul>\n<p>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</p>\n<p>请分析以下哪些操作是原子性操作：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = 10;        //语句1: 直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中</span><br><span class=\"line\">y = x;         //语句2: 包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</span><br><span class=\"line\">x++;           //语句3： x++包括3个操作：读取x的值，进行加1操作，写入新的值。</span><br><span class=\"line\">x = x + 1;     //语句4： 同语句3</span><br></pre></td></tr></table></figure>\n\n<p>只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p>\n<p>Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p>\n<ul>\n<li><h6 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a><a href=\"#%E5%8F%AF%E8%A7%81%E6%80%A7\">可见性</a></h6></li>\n</ul>\n<p>Java提供了volatile关键字来保证可见性。</p>\n<p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>\n<p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>\n<p>另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>\n<ul>\n<li><h6 id=\"有序性\"><a href=\"#有序性\" class=\"headerlink\" title=\"有序性\"></a><a href=\"#%E6%9C%89%E5%BA%8F%E6%80%A7\">有序性</a></h6></li>\n</ul>\n<p>在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。当然JMM是通过Happens-Before 规则来保证有序性的。</p>\n<h2 id=\"Happens-Before-规则\"><a href=\"#Happens-Before-规则\" class=\"headerlink\" title=\"Happens-Before 规则\"></a><a href=\"#happens-before-%E8%A7%84%E5%88%99\">Happens-Before 规则</a></h2><p>上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。</p>\n<h4 id=\"1-单一线程原则\"><a href=\"#1-单一线程原则\" class=\"headerlink\" title=\"1. 单一线程原则\"></a><a href=\"#_1-%E5%8D%95%E4%B8%80%E7%BA%BF%E7%A8%8B%E5%8E%9F%E5%88%99\">1. 单一线程原则</a></h4><p>在一个线程内，在程序前面的操作先行发生于后面的操作。</p>\n<h4 id=\"2-管程锁定规则\"><a href=\"#2-管程锁定规则\" class=\"headerlink\" title=\"2. 管程锁定规则\"></a><a href=\"#_2-%E7%AE%A1%E7%A8%8B%E9%94%81%E5%AE%9A%E8%A7%84%E5%88%99\">2. 管程锁定规则</a></h4><p>一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。</p>\n<h4 id=\"3-volatile变量规则\"><a href=\"#3-volatile变量规则\" class=\"headerlink\" title=\"3. volatile变量规则\"></a><a href=\"#_3-volatile%E5%8F%98%E9%87%8F%E8%A7%84%E5%88%99\">3. volatile变量规则</a></h4><p>对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。</p>\n<h4 id=\"4-线程启动规则\"><a href=\"#4-线程启动规则\" class=\"headerlink\" title=\"4. 线程启动规则\"></a><a href=\"#_4-%E7%BA%BF%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%A7%84%E5%88%99\">4. 线程启动规则</a></h4><p>Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。</p>\n<h4 id=\"5-线程加入规则\"><a href=\"#5-线程加入规则\" class=\"headerlink\" title=\"5. 线程加入规则\"></a><a href=\"#_5-%E7%BA%BF%E7%A8%8B%E5%8A%A0%E5%85%A5%E8%A7%84%E5%88%99\">5. 线程加入规则</a></h4><p>Thread 对象的结束先行发生于 join() 方法返回。</p>\n<h4 id=\"6-线程中断规则\"><a href=\"#6-线程中断规则\" class=\"headerlink\" title=\"6. 线程中断规则\"></a><a href=\"#_6-%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD%E8%A7%84%E5%88%99\">6. 线程中断规则</a></h4><p>对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。</p>\n<h4 id=\"7-对象终结规则\"><a href=\"#7-对象终结规则\" class=\"headerlink\" title=\"7. 对象终结规则\"></a><a href=\"#_7-%E5%AF%B9%E8%B1%A1%E7%BB%88%E7%BB%93%E8%A7%84%E5%88%99\">7. 对象终结规则</a></h4><p>一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始。</p>\n<h4 id=\"8-传递性\"><a href=\"#8-传递性\" class=\"headerlink\" title=\"8. 传递性\"></a><a href=\"#_8-%E4%BC%A0%E9%80%92%E6%80%A7\">8. 传递性</a></h4><p>如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。</p>\n<h2 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a><a href=\"#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8\">线程安全</a></h2><p>一个类在可以被多个线程安全调用时就是线程安全的。</p>\n<p>线程安全不是一个非真即假的命题，可以将共享数据按照安全程度的强弱顺序分成以下五类: 不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p>\n<h4 id=\"1-不可变\"><a href=\"#1-不可变\" class=\"headerlink\" title=\"1. 不可变\"></a><a href=\"#_1-%E4%B8%8D%E5%8F%AF%E5%8F%98\">1. 不可变</a></h4><p>不可变(Immutable)的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。</p>\n<p>多线程环境下，应当尽量使对象成为不可变，来满足线程安全。</p>\n<p>不可变的类型:</p>\n<ul>\n<li>final 关键字修饰的基本数据类型</li>\n<li>String</li>\n<li>枚举类型</li>\n<li>Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。</li>\n</ul>\n<h4 id=\"2-相对线程安全\"><a href=\"#2-相对线程安全\" class=\"headerlink\" title=\"2. 相对线程安全\"></a><a href=\"#_2-%E7%9B%B8%E5%AF%B9%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8\">2. 相对线程安全</a></h4><p>相对线程安全需要保证对这个对象单独的操作是线程安全的，在调用的时候不需要做额外的保障措施。但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。</p>\n<p>在 Java 语言中，大部分的线程安全类都属于这种类型，例如 Vector、HashTable、Collections 的 synchronizedCollection() 方法包装的集合等。</p>\n<h4 id=\"3-线程兼容\"><a href=\"#3-线程兼容\" class=\"headerlink\" title=\"3. 线程兼容\"></a><a href=\"#_3-%E7%BA%BF%E7%A8%8B%E5%85%BC%E5%AE%B9\">3. 线程兼容</a></h4><p>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。Java API 中大部分的类都是属于线程兼容的，如与前面的 Vector 和 HashTable 相对应的集合类 ArrayList 和 HashMap 等。</p>\n<h4 id=\"4-线程对立\"><a href=\"#4-线程对立\" class=\"headerlink\" title=\"4. 线程对立\"></a><a href=\"#_4-%E7%BA%BF%E7%A8%8B%E5%AF%B9%E7%AB%8B\">4. 线程对立</a></h4><p>线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于 Java 语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。</p>\n<h2 id=\"线程安全的实现方法\"><a href=\"#线程安全的实现方法\" class=\"headerlink\" title=\"线程安全的实现方法\"></a><a href=\"#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95\">线程安全的实现方法</a></h2><h4 id=\"1-互斥同步\"><a href=\"#1-互斥同步\" class=\"headerlink\" title=\"1. 互斥同步\"></a><a href=\"#_1-%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5\">1. 互斥同步</a></h4><p>synchronized 和 ReentrantLock。</p>\n<h4 id=\"2-非阻塞同步\"><a href=\"#2-非阻塞同步\" class=\"headerlink\" title=\"2. 非阻塞同步\"></a><a href=\"#_2-%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%90%8C%E6%AD%A5\">2. 非阻塞同步</a></h4><p>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。</p>\n<p>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁(这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁)、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p>\n<h6 id=\"（一）CAS\"><a href=\"#（一）CAS\" class=\"headerlink\" title=\"（一）CAS\"></a><a href=\"#%E4%B8%80-cas\">（一）CAS</a></h6><p>随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略: 先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施(不断地重试，直到成功为止)。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p>\n<p>乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是: 比较并交换(Compare-and-Swap，CAS)。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。</p>\n<h6 id=\"（二）ABA\"><a href=\"#（二）ABA\" class=\"headerlink\" title=\"（二）ABA\"></a><a href=\"#%E4%BA%8C-aba\">（二）ABA</a></h6><p>如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。</p>\n<p>J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。</p>\n<h4 id=\"3-无同步方案\"><a href=\"#3-无同步方案\" class=\"headerlink\" title=\"3. 无同步方案\"></a><a href=\"#_3-%E6%97%A0%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88\">3. 无同步方案</a></h4><p>要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。</p>\n<h6 id=\"（一）栈封闭\"><a href=\"#（一）栈封闭\" class=\"headerlink\" title=\"（一）栈封闭\"></a><a href=\"#%E4%B8%80-%E6%A0%88%E5%B0%81%E9%97%AD\">（一）栈封闭</a></h6><p>多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。</p>\n<h6 id=\"（二）线程本地存储（Thread-Local-Storage）\"><a href=\"#（二）线程本地存储（Thread-Local-Storage）\" class=\"headerlink\" title=\"（二）线程本地存储（Thread Local Storage）\"></a><a href=\"#%E4%BA%8C-%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8-thread-local-storage\">（二）线程本地存储（<strong>Thread Local Storage</strong>）</a></h6><p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</p>\n<p>符合这种特点的应用并不少见，大部分使用消费队列的架构模式(如“生产者-消费者”模式)都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”(Thread-per-Request)的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。</p>\n<p>可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。</p>\n<p>ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。</p>\n<p>在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。</p>\n<h6 id=\"（三）可重入代码\"><a href=\"#（三）可重入代码\" class=\"headerlink\" title=\"（三）可重入代码\"></a><a href=\"#%E4%B8%89-%E5%8F%AF%E9%87%8D%E5%85%A5%E4%BB%A3%E7%A0%81\">（三）可重入代码</a></h6><p>这种代码也叫做纯代码(Pure Code)，可以在代码执行的任何时刻中断它，转而去执行另外一段代码(包括递归调用它本身)，而在控制权返回后，原来的程序不会出现任何错误。</p>\n<p>可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。</p>\n<hr>\n","text":"为什么需要多线程？早期的单CPU时代，CPU制作厂商沉迷于提高单个核心的计算能力。但是随着时间的推移，提高单核心的计算能力越来越困难了。于是乎，堆核心成为了快速...","permalink":"/post/并发/并发基础","photos":[],"count_time":{"symbolsCount":"6.6k","symbolsTime":"6 mins."},"categories":[{"name":"八股","slug":"八股","count":22,"path":"api/categories/八股.json"}],"tags":[{"name":"java","slug":"java","count":15,"path":"api/tags/java.json"},{"name":"并发基础","slug":"并发基础","count":1,"path":"api/tags/并发基础.json"},{"name":"并发框架","slug":"并发框架","count":7,"path":"api/tags/并发框架.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F\"><span class=\"toc-text\">为什么需要多线程？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">线程安全示例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E5%8F%91%E7%94%9F%E7%9A%84%E4%B8%89%E8%A6%81%E7%B4%A0\"><span class=\"toc-text\">并发问题发生的三要素</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%9ACPU%E7%BC%93%E5%AD%98%E5%BC%95%E8%B5%B7%E7%9A%84\"><span class=\"toc-text\">1. 可见性：CPU缓存引起的</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%9A%E5%88%86%E6%97%B6%E5%A4%8D%E7%94%A8%E5%BC%95%E8%B5%B7%E7%9A%84\"><span class=\"toc-text\">2. 原子性：分时复用引起的</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E6%9C%89%E5%BA%8F%E6%80%A7%EF%BC%9A%E9%87%8D%E6%8E%92%E5%BA%8F%E5%BC%95%E8%B5%B7\"><span class=\"toc-text\">3. 有序性：重排序引起</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Java%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">Java是怎么解决并发问题的？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%AD%90%E6%80%A7\"><span class=\"toc-text\">原子性</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E8%A7%81%E6%80%A7\"><span class=\"toc-text\">可见性</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E6%9C%89%E5%BA%8F%E6%80%A7\"><span class=\"toc-text\">有序性</span></a></li></ol></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Happens-Before-%E8%A7%84%E5%88%99\"><span class=\"toc-text\">Happens-Before 规则</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%8D%95%E4%B8%80%E7%BA%BF%E7%A8%8B%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">1. 单一线程原则</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E7%AE%A1%E7%A8%8B%E9%94%81%E5%AE%9A%E8%A7%84%E5%88%99\"><span class=\"toc-text\">2. 管程锁定规则</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-volatile%E5%8F%98%E9%87%8F%E8%A7%84%E5%88%99\"><span class=\"toc-text\">3. volatile变量规则</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E7%BA%BF%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%A7%84%E5%88%99\"><span class=\"toc-text\">4. 线程启动规则</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E7%BA%BF%E7%A8%8B%E5%8A%A0%E5%85%A5%E8%A7%84%E5%88%99\"><span class=\"toc-text\">5. 线程加入规则</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD%E8%A7%84%E5%88%99\"><span class=\"toc-text\">6. 线程中断规则</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-%E5%AF%B9%E8%B1%A1%E7%BB%88%E7%BB%93%E8%A7%84%E5%88%99\"><span class=\"toc-text\">7. 对象终结规则</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-%E4%BC%A0%E9%80%92%E6%80%A7\"><span class=\"toc-text\">8. 传递性</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8\"><span class=\"toc-text\">线程安全</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E4%B8%8D%E5%8F%AF%E5%8F%98\"><span class=\"toc-text\">1. 不可变</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E7%9B%B8%E5%AF%B9%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8\"><span class=\"toc-text\">2. 相对线程安全</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E7%BA%BF%E7%A8%8B%E5%85%BC%E5%AE%B9\"><span class=\"toc-text\">3. 线程兼容</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E7%BA%BF%E7%A8%8B%E5%AF%B9%E7%AB%8B\"><span class=\"toc-text\">4. 线程对立</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">线程安全的实现方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5\"><span class=\"toc-text\">1. 互斥同步</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%90%8C%E6%AD%A5\"><span class=\"toc-text\">2. 非阻塞同步</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%EF%BC%88%E4%B8%80%EF%BC%89CAS\"><span class=\"toc-text\">（一）CAS</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%EF%BC%88%E4%BA%8C%EF%BC%89ABA\"><span class=\"toc-text\">（二）ABA</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E6%97%A0%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">3. 无同步方案</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%EF%BC%88%E4%B8%80%EF%BC%89%E6%A0%88%E5%B0%81%E9%97%AD\"><span class=\"toc-text\">（一）栈封闭</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%EF%BC%88%E4%BA%8C%EF%BC%89%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%EF%BC%88Thread-Local-Storage%EF%BC%89\"><span class=\"toc-text\">（二）线程本地存储（Thread Local Storage）</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%EF%BC%88%E4%B8%89%EF%BC%89%E5%8F%AF%E9%87%8D%E5%85%A5%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">（三）可重入代码</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>","author":{"name":"Ivan","slug":"blog-author","avatar":"https://yslcrush.obs.cn-south-1.myhuaweicloud.com/imag/m.jpg","link":"/","description":"离婚后看淡人生","socials":{"github":"https://github.com/FAKERSMILE","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/3494374914656981/favlist"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"线程基础","uid":"6245dd4deb5ec4d8e16e80935a8a30db","slug":"并发/线程基础","date":"2024-12-03T14:40:50.000Z","updated":"2024-12-03T16:35:43.382Z","comments":true,"path":"api/articles/并发/线程基础.json","keywords":null,"cover":"https://i.pinimg.com/236x/8b/44/3c/8b443cd6bca1516bfb6e156c5503c2c5.jpg","text":"线程状态的转换新建（New）创建后未启动。 可运行（Runable）可能正在运行，也可能等待CPU时间片。 阻塞（Blocking）等待获取一个排它锁，如果其他...","permalink":"/post/并发/线程基础","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"八股","slug":"八股","count":22,"path":"api/categories/八股.json"}],"tags":[{"name":"java","slug":"java","count":15,"path":"api/tags/java.json"},{"name":"并发框架","slug":"并发框架","count":7,"path":"api/tags/并发框架.json"}],"author":{"name":"Ivan","slug":"blog-author","avatar":"https://yslcrush.obs.cn-south-1.myhuaweicloud.com/imag/m.jpg","link":"/","description":"离婚后看淡人生","socials":{"github":"https://github.com/FAKERSMILE","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/3494374914656981/favlist"}}}}},"next_post":{"title":"计算机网络","uid":"293c17b4d2a4292133cc4d1ffd7f8725","slug":"计网/计算机网络","date":"2024-12-03T14:23:01.000Z","updated":"2024-12-03T16:35:43.375Z","comments":true,"path":"api/articles/计网/计算机网络.json","keywords":null,"cover":"https://i.pinimg.com/236x/69/25/ad/6925ad87d9fd333a079da2b53ec08834.jpg","text":"OSI模型、TCP/IP模型、五层模型 ？ 刚开始学习的小伙伴一定会被这些搞懵逼的，傻傻分不清哦。 这个所谓的七层模型，实际上那帮搞学术的弄出来的，但是很可惜，...","permalink":"/post/计网/计算机网络","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"八股","slug":"八股","count":22,"path":"api/categories/八股.json"}],"tags":[{"name":"计算机网络","slug":"计算机网络","count":2,"path":"api/tags/计算机网络.json"}],"author":{"name":"Ivan","slug":"blog-author","avatar":"https://yslcrush.obs.cn-south-1.myhuaweicloud.com/imag/m.jpg","link":"/","description":"离婚后看淡人生","socials":{"github":"https://github.com/FAKERSMILE","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/3494374914656981/favlist"}}}}}}