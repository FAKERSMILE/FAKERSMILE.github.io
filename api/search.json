[{"id":"5bcef49cfc4866658bd7f1721b4f6cb7","title":"反射机制","content":"对于Java的反射机制，精炼一点就是，可以在程序运行时获取类和对象的信息，包括属性和方法。\n反射基础Class类和普通的类没有什么区别，有属性，有方法。\n我们编写的类在被编译后，都会附带一个Class对象，表示创建类的类型信息，被写入在同名的class字节码文件中。\n我们无法手动创建Class类的对象，因为其构造函数是私有化的。\nClass对象的作用是运行时提供某个对象的类型信息。\n反射的使用对于对象，我们的常规操作是什么？\n无非就是new一个对象出来、改变对象的状态（修改属性值）、调用对象方法。\n不过，现在，我们要使用反射机制来完成这些操作。\nClass类对象的获取在类加载的时候，jvm会创建一个class对象。\n获取class对象的三种方式：\n\n类名.class\n对象.getClass()\nClass.forName(全限定类名)\n\n（这里简单演示一下就行了，毕竟平时开发的时候真的很少用这玩意儿啦）\n1234567891011121314151617181920212223242526272829303132333435class Person &#123;    private String name;    private int age;    public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    private void sayHello()&#123;        System.out.println(&quot;hello&quot;);    &#125;    @Override    public String toString() &#123;        return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;    &#125;&#125;\n\n创建一个新的对象：\n12345678public class Test &#123;    public static void main(String[] args) throws NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException &#123;       Constructor&lt;Person&gt; constructor = Person.class.getDeclaredConstructor(String.class,int.class);       Person person = constructor.newInstance(&quot;kaiven&quot;,20);       System.out.println(person);    &#125;&#125;\n\n改变对象的状态：\n1234567891011public class Test &#123;    public static void main(String[] args) throws NoSuchMethodException, SecurityException, InstantiationException,            IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchFieldException &#123;        Person person = new Person(&quot;kaiven&quot;, 20);        Field namField = person.getClass().getDeclaredField(&quot;name&quot;);        namField.setAccessible(true);        namField.set(person, &quot;lucy&quot;);        System.out.println(person.getName());    &#125;&#125;\n\n调用对象方法：\n12345678910public class Test &#123;    public static void main(String[] args) throws NoSuchMethodException, SecurityException, InstantiationException,            IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchFieldException &#123;        Person person = new Person(&quot;kaiven&quot;, 20);        Method method = person.getClass().getDeclaredMethod(&quot;sayHello&quot;);        method.setAccessible(true);        method.invoke(person);    &#125;&#125;\n\n（想玩儿的时候自己去查阅文档玩儿一下就行了）\n反射机制执行的流程（等我去搞一下JVM，哈哈。先欠着，以后还。）\n\n","slug":"java基础/反射机制","date":"2024-12-03T16:33:37.000Z","categories_index":"八股","tags_index":"java","author_index":"Ivan"},{"id":"ffb5215d2da6c9afc674d09b81aafa43","title":"注解机制","content":"注解基础注解是JDK1.5版本引入的一个新特性，用于对代码进行说明。\n注解的作用\n通过代码里标识的元数据生成javadoc文档\n编译检查\n编译时动态处理，比如说动态生成代码\n运行时动态处理，比如说使用反射注入实例\n\n注解的分类\nJava自带的标准注解，包括@Override、@Deprecated和@SuppressWarnings，分别用于标明重写某个方法、标明某个类或方法过时、标明要忽略的警告，用这些注解标明后编译器就会进行检查。\n元注解，元注解是用于定义注解的注解，包括@Retention、@Target、@Inherited、@Documented，@Retention用于标明注解被保留的阶段，@Target用于标明注解使用的范围，@Inherited用于标明注解可继承，@Documented用于标明是否生成javadoc文档。\n自定义注解，可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。\n\nJava内置注解12345678910111213141516171819202122232425262728293031public class Solution &#123;    public void test()&#123;&#125;&#125;class Test extends Solution &#123;    /**     * 重写父类方法     */    @Override    public void test() &#123;            &#125;    /**     * 被弃用的方法（后续版本可能移除，不推荐再使用）     */    @Deprecated    public void oldMethod()&#123;    &#125;    /**     * 忽略警告     */    @SuppressWarnings(&quot;rawtypes&quot;)    public List list()&#123;        return new ArrayList&lt;&gt;();    &#125;&#125;\n\n@Override我们来看一下这个注解的内部是什么样子：\n1234@Target(ElementType.METHOD) // 表示该注解用来修饰方法的@Retention(RetentionPolicy.SOURCE) // 表示该注解仅在编译时有效public @interface Override &#123;&#125;\n\n@Deprecated123456789101112131415161718192021222324@Documented // 能够被文档化@Retention(RetentionPolicy.RUNTIME) // 可以保留到运行时@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE, PARAMETER, TYPE&#125;) // 作用域相当的广泛public @interface Deprecated &#123;    /**     * Returns the version in which the annotated element became deprecated.     * The version string is in the same format and namespace as the value of     * the &#123;@code @since&#125; javadoc tag. The default value is the empty     * string.     *     * @return the version string     * @since 9     */    String since() default &quot;&quot;;    /**     * Indicates whether the annotated element is subject to removal in a     * future version. The default value is &#123;@code false&#125;.     *     * @return whether the element is subject to removal     * @since 9     */    boolean forRemoval() default false;&#125;\n\n@SuppressWarnings123456789101112131415161718192021@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE&#125;) // 作用域相当广泛@Retention(RetentionPolicy.SOURCE) // 仅在编译时有效public @interface SuppressWarnings &#123;    /**     * The set of warnings that are to be suppressed by the compiler in the     * annotated element.  Duplicate names are permitted.  The second and     * successive occurrences of a name are ignored.  The presence of     * unrecognized warning names is &lt;i&gt;not&lt;/i&gt; an error: Compilers must     * ignore any warning names they do not recognize.  They are, however,     * free to emit a warning if an annotation contains an unrecognized     * warning name.     *     * &lt;p&gt; The string &#123;@code &quot;unchecked&quot;&#125; is used to suppress     * unchecked warnings. Compiler vendors should document the     * additional warning names they support in conjunction with this     * annotation type. They are encouraged to cooperate to ensure     * that the same names work across multiple compilers.     * @return the set of warnings to be suppressed     */    String[] value();&#125;\n\n元注解@Target123456789101112@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Target &#123;    /**     * Returns an array of the kinds of elements an annotation interface     * can be applied to.     * @return an array of the kinds of elements an annotation interface     * can be applied to     */    ElementType[] value();&#125;\n\n该注解的作用就是限定注解的使用范围，具体范围如下：\n1234567891011121314151617181920212223public enum ElementType &#123;     TYPE, // 类、接口、枚举类     FIELD, // 成员变量（包括：枚举常量）     METHOD, // 成员方法     PARAMETER, // 方法参数     CONSTRUCTOR, // 构造方法     LOCAL_VARIABLE, // 局部变量     ANNOTATION_TYPE, // 注解类     PACKAGE, // 可用于修饰：包     TYPE_PARAMETER, // 类型参数，JDK 1.8 新增     TYPE_USE // 使用类型的任何地方，JDK 1.8 新增 &#125;\n\n我们可以看到该注解自身也加上了一个 @Target(ElementType.ANNOTATION_TYPE) 。\n@Retention12345678910@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Retention &#123;    /**     * Returns the retention policy.     * @return the retention policy     */    RetentionPolicy value();&#125;\n\n该注解的作用就是描述注解保留的时间（或者叫做阶段吧）。总共有三个阶段：\n123456789101112131415161718192021public enum RetentionPolicy &#123;    /**     * Annotations are to be discarded by the compiler.     */    SOURCE,    /**     * Annotations are to be recorded in the class file by the compiler     * but need not be retained by the VM at run time.  This is the default     * behavior.     */    CLASS,    /**     * Annotations are to be recorded in the class file by the compiler and     * retained by the VM at run time, so they may be read reflectively.     *     * @see java.lang.reflect.AnnotatedElement     */    RUNTIME&#125;\n\n（英文描述得已经很清晰了）\n@Documented该注解的作用就是在使用 javadoc 工具为类生成帮助文档时保留注解信息。\n12345@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Documented &#123;&#125;\n\n@Inherited如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。\n12345@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Inherited &#123;&#125;\n\n注解与反射在使用SpringBoot进行开发的时候，你会感慨为什么写几个注解就能够将项目跑起来，那肯定是因为框架的开发者在你看不见的地方替你完成了某些操作。\n注意：注解的生命周期只有是 RUNTIME 才能通过反射去获取。\n自定义注解我们来编写一个属于自己的注解吧。\n123456789101112package com.kaiven.anno;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.METHOD) // 作用在方法上@Retention(RetentionPolicy.RUNTIME) // 保留到运行时，否则无法通过反射获取public @interface GetMapping &#123;    String value() default &quot;&quot;;&#125;\n\n123456789101112131415161718192021package com.kaiven;import com.kaiven.anno.GetMapping;import java.lang.reflect.Method;public class Main &#123;    public static void main(String[] args) throws NoSuchMethodException &#123;        Method hello = Main.class.getMethod(&quot;hello&quot;);        // 如果该方法上有GetMapping注解        if (hello.isAnnotationPresent(GetMapping.class)) &#123;            GetMapping annotation = hello.getAnnotation(GetMapping.class);            System.out.println(annotation.value());        &#125;    &#125;    @GetMapping(&quot;/hello&quot;)    public String hello()&#123;        return &quot;Hello world!&quot;;    &#125;&#125;\n\n有没有那一点点的味道了？\n深入理解注解注解支持继承嘛？注解是不支持继承的，但注解在编译之后，编译器会自动继承java.lang.annotation.Annotation接口。\n注解实现的原理？https://blog.csdn.net/qq\\_20009015/article/details/106038023\n（对于注解的应用，大多还是与Spring相关的，最大的一个变化就是从xml配置项目到注解化的转变）\n\n","slug":"java基础/注解机制","date":"2024-12-03T16:29:44.000Z","categories_index":"八股","tags_index":"java","author_index":"Ivan"},{"id":"5fa7811420fef5e890cc85bbf0c3fa40","title":"SPI","content":"什么是 SPI 机制？SPI（Service Provider Interface），是 JDK 内置的一种服务提供发现机制，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用，Java的SPI机制可以为某个接口寻找服务实现。\nJava中SPI机制的主要思想是将装配的控制权转移到程序外，降低耦合度。\n\n当服务的提供者提供了一种接口的实现之后，需要在classpath下的META-INF/services/目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的META-INF/services/中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。JDK中查找服务的实现的工具类是：java.util.ServiceLoader。\nSPI机制的简单示例定义一个搜索接口，搜索关键词是一个参数，返回对应的搜索结果：\n123public interface Search &#123;    String search(String keywords);&#125;\n\n文件搜索的具体实现：\n123456public class FileSearchImpl implements Search&#123;    @Override    public String search(String keywords) &#123;        return &quot;我是文件搜索功能的具体实现&quot;;    &#125;&#125;\n\n数据库搜索的具体实现：\n123456public class DataBaseSearchImpl implements Search&#123;    @Override    public String search(String keywords) &#123;        return &quot;我是数据库搜索功能的实现&quot;;    &#125;&#125;\n\n接下来可以在resources下新建META-INF&#x2F;services&#x2F;目录，然后新建接口全限定名的文件：com.kaiven.spi.Search，里面加上我们需要用到的实现类。\n12com.kaiven.spi.DataBaseSearchImplcom.kaiven.spi.FileSearchImpl\n\n测试：\n12345678public class Main &#123;    public static void main(String[] args) &#123;        ServiceLoader&lt;Search&gt; load = ServiceLoader.load(Search.class);        for (Search search : load) &#123;            System.out.println(search.search(&quot;&quot;));        &#125;    &#125;&#125;\n\n（好玩吧，哈哈）\nSPI机制的典型应用数据库JDBC提供了统一的数据库相关操作的接口：\n123456789101112131415public interface Driver &#123;    Connection connect(String url, java.util.Properties info)        throws SQLException;    boolean acceptsURL(String url) throws SQLException;    DriverPropertyInfo[] getPropertyInfo(String url, java.util.Properties info)                         throws SQLException;    int getMajorVersion();    int getMinorVersion();    public Logger getParentLogger() throws SQLFeatureNotSupportedException;&#125;\n\n这就是所谓的数据库驱动接口。\n让我们看一下mysql是怎么实现的：\n\n是不是和我们上面写的例子一模一样呢？哈哈。\n（其他的应用场景可以自行百度扩展一下，特别是Spring的，想一下没有SpringBoot之前，是不是一大堆的xml配置文件）\nSPI机制深入理解SPI和API的区别？使用SPI机制的时候，我们会将具体的实现抽离出程序外，也就是相当于接口的定义与实现不在同一个包中，比如 JDBC和MySQL驱动的实现。对于API的话，平时的开发中，会将接口与实现类放在同一个包中。前者强调调用方，后者强调实现方。\nSPI机制的实现原理（这个感兴趣的可以自行去查看JDK中ServiceLoader&lt;S&gt;方法的具体实现，面试的话，这里你能讲出一些自己的理解就行了）\nSPI机制的缺陷\n不能按需加载，需要遍历所有实现，并实例化，然后再循环中才能找到我们的实现。如果不想使用某些实现类，或者某些类实例化很耗时，它也被载入并实例化，这就造成了浪费。\n获取某个实现类的方式不够灵活，只能通过Iterator形式获取，不能根据某个参数来获取对应的实现类。\n多线程使用 ServiceLoader 类的实例是不安全的。\n\n\n","slug":"java基础/SPI","date":"2024-12-03T16:25:08.000Z","categories_index":"八股","tags_index":"java","author_index":"Ivan"},{"id":"da333f82be06d5afcb21795dbc6a2364","title":"final详解","content":"final基础使用修饰类当某个类的整体定义为final时，就表明了你不能打算继承该类，而且也不允许别人这么做。即这个类是不能有子类的。\n注意：final类中的所有方法都隐式为final，因为无法覆盖他们，所以在final类中给任何方法添加final关键字是没有任何意义的。\n修饰方法\nprivate 方法是隐式的final\n类中所有private方法都隐式地指定为final的，由于无法取用private方法，所以也就不能覆盖它。可以对private方法增添final关键字，但这样做并没有什么好处。\n\nfinal方法是可以被重载的\n1234567public class FinalExampleParent &#123;    public final void test() &#123;    &#125;    public final void test(String str) &#123;    &#125;&#125;\n\n修饰参数Java允许在参数列表中以声明的方式将参数指明为final，这意味这你无法在方法中更改参数引用所指向的对象。这个特性主要用来向匿名内部类传递数据。\n修饰变量所有被final修饰的变量都是编译期常量嘛？12345678910111213public class Test &#123;    //编译期常量    final int i = 1;    final static int J = 1;    final int[] a = &#123;1,2,3,4&#125;;    //非编译期常量    Random r = new Random();    final int k = r.nextInt();    public static void main(String[] args) &#123;    &#125;&#125;\n\nk的值由随机数对象决定，所以不是所有的final修饰的字段都是编译期常量，只是k的值在被初始化后无法被更改。\nstatci final一个既是static又是final 的字段只占据一段不能改变的存储空间，它必须在定义的时候进行赋值，否则编译器将不予通过。\n1234567891011public class Test &#123;    static Random r = new Random();    final int k = r.nextInt(10);    static final int k2 = r.nextInt(10);     public static void main(String[] args) &#123;        Test t1 = new Test();        System.out.println(&quot;k=&quot;+t1.k+&quot; k2=&quot;+t1.k2);        Test t2 = new Test();        System.out.println(&quot;k=&quot;+t2.k+&quot; k2=&quot;+t2.k2);    &#125;&#125;\n\n我们可以发现对于不同的对象k的值是不同的，但是k2的值却是相同的，这是为什么呢? 因为static关键字所修饰的字段并不属于一个对象，而是属于这个类的。也可简单的理解为static final所修饰的字段仅占据内存的一个一份空间，一旦被初始化之后便不会被更改。\nfinal域重排序规则Java中，无非就是两种数据类型，基本数据类型和引用（对象）。在下文中，我们展开来看：\nfinal域为基本类型写final域的重排序规则写final域的重排序规则禁止对final域的写重排序到构造函数之外，这个规则的实现主要包含了两个方面：\n\nJMM禁止编译器把final域的写重排序到构造函数之外；\n编译器会在final域写之后，构造函数return之前，插入一个storestore屏障。这个屏障可以禁止处理器把final域的写重排序到构造函数之外。\n\n1234567891011121314151617181920public class FinalDemo &#123;    private int a;  //普通域    private final int b; //final域    private static FinalDemo finalDemo;    public FinalDemo() &#123;        a = 1; // 1. 写普通域        b = 2; // 2. 写final域    &#125;    public static void writer() &#123;        finalDemo = new FinalDemo();    &#125;    public static void reader() &#123;        FinalDemo demo = finalDemo; // 3.读对象引用        int a = demo.a;    //4.读普通域        int b = demo.b;    //5.读final域    &#125;&#125;\n\n假设线程A执行writer方法，线程B执行reader方法。\n线程A在进行对象的构造时，由于b带有final域，所以写指令不会被重排序到构造函数外，而a是普通域，可能会被重排序到构造函数外。线程B读取b的值的时候，一定是可以读到最新值2的（假设对象已经构造完毕），读取a的值就不一定了，可能会读取到默认值。\n读final域重排序规则读final域重排序规则为：在一个线程中，初次读对象引用和初次读该对象包含的final域，JMM会禁止这两个操作的重排序。(注意，这个规则仅仅是针对处理器)，处理器会在读final域操作的前面插入一个LoadLoad屏障。实际上，读对象的引用和读该对象的final域存在间接依赖性，一般处理器不会重排序这两个操作。但是有一些处理器会重排序，因此，这条禁止重排序规则就是针对这些处理器而设定的。\n上文的线程B在进行final域变量值b的读取时，一定会先读取对象的引用，在通过对象的引用读取对应的值。\n读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读这个包含这个final域的对象的引用。\nfinal域为引用类型对final修饰的对象的成员域写操作针对引用数据类型，final域写针对编译器和处理器重排序增加了这样的约束：在构造函数内对一个final修饰的对象的成员域的写入，与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量，这两个操作是不能被重排序的。注意这里的是“增加”也就说前面对final基本数据类型的重排序规则在这里还是使用。\n1234567891011121314151617181920212223public class FinalReferenceDemo &#123;    final int[] arrays;    private FinalReferenceDemo finalReferenceDemo;    public FinalReferenceDemo() &#123;        arrays = new int[1];  //1        arrays[0] = 1;        //2    &#125;    public void writerOne() &#123;        finalReferenceDemo = new FinalReferenceDemo(); //3    &#125;    public void writerTwo() &#123;        arrays[0] = 2;  //4    &#125;    public void reader() &#123;        if (finalReferenceDemo != null) &#123;  //5            int temp = finalReferenceDemo.arrays[0];  //6        &#125;    &#125;&#125;\n\n针对上面的实例程序，线程线程A执行wirterOne方法，执行完后线程B执行writerTwo方法，然后线程C执行reader方法。\n由于对final域的写禁止重排序到构造方法外，因此1和3不能被重排序。由于一个final域的引用对象的成员域写入不能与随后将这个被构造出来的对象赋给引用变量重排序，因此2和3不能重排序。\n对final修饰的对象的成员域读操作JMM可以确保线程C至少能看到写线程A对final引用的对象的成员域的写入，即能看下arrays[0] &#x3D; 1，而写线程B对数组元素的写入可能看到可能看不到。JMM不保证线程B的写入对线程C可见，线程B和线程C之间存在数据竞争，此时的结果是不可预知的。如果可见的，可使用锁或者volatile。\n关于final域重排序的总结按照final修饰的数据类型分类：\n\n基本数据类型:\nfinal域写：禁止final域写与构造方法重排序，即禁止final域写重排序到构造方法之外，从而保证该对象对所有线程可见时，该对象的final域全部已经初始化过。\nfinal域读：禁止初次读对象的引用与读该对象包含的final域的重排序。\n\n\n引用数据类型：\n额外增加约束：禁止在构造函数对一个final修饰的对象的成员域的写入与随后将这个被构造的对象的引用赋值给引用变量 重排序\n\n\n\n\n","slug":"并发/final详解","date":"2024-12-03T15:28:28.000Z","categories_index":"八股","tags_index":"java,并发框架","author_index":"Ivan"},{"id":"2d6047dcb37a308542a367e2837e0e0c","title":"Sychronized详解","content":"synchronized的使用在应用Sychronized关键字时需要把握如下注意点：\n\n一把锁只能同时被一个线程获取，没有获得锁的线程只能等待；\n每个实例都对应有自己的一把锁(this),不同实例之间互不影响；例外：锁对象是*.class以及synchronized修饰的是static方法的时候，所有对象公用同一把锁\nsynchronized修饰的方法，无论方法正常执行完毕还是抛出异常，都会释放锁\n\nsynchronized原理分析加锁和释放锁的原理1234567891011121314public class Test &#123;    Object object = new Object();        public void func()&#123;        synchronized(object)&#123;        &#125;        method();    &#125;    private static void method()&#123;        System.out.println(1);    &#125;&#125;\n\n生成的字节码（非完整，只关注函数func）：\n123456789101112131415161718192021222324public void func();    descriptor: ()V    flags: (0x0001) ACC_PUBLIC    Code:      stack=2, locals=3, args_size=1         0: aload_0         1: getfield      #7                  // Field object:Ljava/lang/Object;         4: dup         5: astore_1         6: monitorenter // 注意这里         7: aload_1         8: monitorexit // 注意这里         9: goto          17        12: astore_2        13: aload_1        14: monitorexit // 注意这里        15: aload_2        16: athrow        17: invokestatic  #13                 // Method method:()V        20: return      Exception table:         from    to  target type             7     9    12   any            12    15    12   any\n\nMonitorenter和Monitorexit指令，会让对象在执行，使其锁计数器加1或者减1。每一个对象在同一时间只与一个monitor(锁)相关联，而一个monitor在同一时间只能被一个线程获得，一个对象在尝试获得与这个对象相关联的Monitor锁的所有权的时候，monitorenter指令会发生如下3中情况之一：\n\nmonitor计数器为0，意味着目前还没有被获得，那这个线程就会立刻获得然后把锁计数器+1，一旦+1，别的线程再想获取，就需要等待\n如果这个monitor已经拿到了这个锁的所有权，又重入了这把锁，那锁计数器就会累加，变成2，并且随着重入的次数，会一直累加\n这把锁已经被别的线程获取了，等待锁释放\n\nmonitorexit指令：释放对于monitor的所有权，释放过程很简单，就是讲monitor的计数器减1，如果减完以后，计数器不是0，则代表刚才是重入进来的，当前线程还继续持有这把锁的所有权，如果计数器变成0，则代表当前线程不再拥有该monitor的所有权，即释放锁。\n\n该图可以看出，任意线程对Object的访问，首先要获得Object的监视器，如果获取失败，该线程就进入同步状态，线程状态变为BLOCKED，当Object的监视器占有者释放后，在同步队列中得线程就会有机会重新获取该监视器.\n(这也是可重入的原理)\n保证可见性的原理：内存模型和happens-before规则Synchronized的happens-before规则，即监视器锁规则：对同一个监视器的解锁，happens-before于对该监视器的加锁。\n（这是JVM对你的一个承诺）\nJVM中锁的优化简单来说在JVM中monitorenter和monitorexit字节码依赖于底层的操作系统的Mutex Lock来实现的，但是由于使用Mutex Lock需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的；然而在现实中的大部分情况下，同步方法是运行在单线程环境(无锁竞争环境)如果每次都调用Mutex Lock那么将严重的影响程序的性能。不过在jdk1.6中对锁的实现引入了大量的优化，如锁粗化(Lock Coarsening)、锁消除(Lock Elimination)、轻量级锁(Lightweight Locking)、偏向锁(Biased Locking)、适应性自旋(Adaptive Spinning)等技术来减少锁操作的开销。\n\n锁粗化(Lock Coarsening)：也就是减少不必要的紧连在一起的unlock，lock操作，将多个连续的锁扩展成一个范围更大的锁。\n锁消除(Lock Elimination)：通过运行时JIT编译器的逃逸分析来消除一些没有在当前同步块以外被其他线程共享的数据的锁保护，通过逃逸分析也可以在线程本的Stack上进行对象空间的分配(同时还可以减少Heap上的垃圾收集开销)。\n轻量级锁(Lightweight Locking)：这种锁实现的背后基于这样一种假设，即在真实的情况下我们程序中的大部分同步代码一般都处于无锁竞争状态(即单线程执行环境)，在无锁竞争的情况下完全可以避免调用操作系统层面的重量级互斥锁，取而代之的是在monitorenter和monitorexit中只需要依靠一条CAS原子指令就可以完成锁的获取及释放。当存在锁竞争的情况下，执行CAS指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒(具体处理步骤下面详细讨论)。\n偏向锁(Biased Locking)：是为了在无锁竞争的情况下避免在锁获取过程中执行不必要的CAS原子指令，因为CAS原子指令虽然相对于重量级锁来说开销比较小但还是存在非常可观的本地延迟。\n适应性自旋(Adaptive Spinning)：当线程在获取轻量级锁的过程中执行CAS操作失败时，在进入与monitor相关联的操作系统重量级锁(mutex semaphore)前会进入忙等待(Spinning)然后再次尝试，当尝试一定的次数后如果仍然没有成功则调用与该monitor关联的semaphore(即互斥锁)进入到阻塞状态。\n\n锁的类型在Java SE 1.6里Synchronied同步锁，一共有四种状态：无锁、偏向锁、轻量级锁、重量级锁，它会随着竞争情况逐渐升级。锁可以升级但是不可以降级，目的是为了提供获取锁和释放锁的效率。\n（ 锁膨胀方向： 无锁 → 偏向锁 → 轻量级锁 → 重量级锁 (此过程是不可逆的) ）\n自旋锁与自适应自旋锁引入背景：大家都知道，在没有加入锁优化时，Synchronized是一个非常“胖大”的家伙。在多线程竞争锁时，当一个线程获取锁时，它会阻塞所有正在竞争的线程，这样对性能带来了极大的影响。在挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作对系统的并发性能带来了很大的压力。同时HotSpot团队注意到在很多情况下，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和回复阻塞线程并不值得。在如今多处理器环境下，完全可以让另一个没有获取到锁的线程在门外等待一会(自旋)，但不放弃CPU的执行时间。等待持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需要让线程执行一个忙循环(自旋)，这便是自旋锁由来的原因。\n自旋锁早在JDK1.4 中就引入了，只是当时默认时关闭的。在JDK 1.6后默认为开启状态。自旋锁本质上与阻塞并不相同，先不考虑其对多处理器的要求，如果锁占用的时间非常的短，那么自旋锁的性能会非常的好，相反，其会带来更多的性能开销(因为在线程自旋时，始终会占用CPU的时间片，如果锁占用的时间太长，那么自旋的线程会白白消耗掉CPU资源)。因此自旋等待的时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获取到锁，就应该使用传统的方式去挂起线程了，在JDK定义中，自旋锁默认的自旋次数为10次，用户可以使用参数-XX:PreBlockSpin来更改。\n可是现在又出现了一个问题：如果线程锁在线程自旋刚结束就释放掉了锁，那么是不是有点得不偿失。所以这时候我们需要更加聪明的锁来实现更加灵活的自旋。来提高并发的性能。(这里则需要自适应自旋锁！)\n在JDK 1.6中引入了自适应自旋锁。这就意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋 时间及锁的拥有者的状态来决定的。如果在同一个锁对象上，自旋等待刚刚成功获取过锁，并且持有锁的线程正在运行中，那么JVM会认为该锁自旋获取到锁的可能性很大，会自动增加等待时间。比如增加到100此循环。相反，如果对于某个锁，自旋很少成功获取锁。那再以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，JVM对程序的锁的状态预测会越来越准确，JVM也会越来越聪明。\n锁消除锁消除是指虚拟机即时编译器再运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持。意思就是：JVM会判断再一段程序中的同步明显不会逃逸出去从而被其他线程访问到，那JVM就把它们当作栈上数据对待，认为这些数据是线程独有的，不需要加同步。此时就会进行锁消除。\n当然在实际开发中，我们很清楚的知道哪些是线程独有的，不需要加同步锁，但是在Java API中有很多方法都是加了同步的，那么此时JVM会判断这段代码是否需要加锁。如果数据并不会逃逸，则会进行锁消除。\n锁粗化原则上，我们都知道在加同步锁时，尽可能的将同步块的作用范围限制到尽量小的范围(只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小。在存在锁同步竞争中，也可以使得等待锁的线程尽早的拿到锁)。\n大部分上述情况是完美正确的，但是如果存在连串的一系列操作都对同一个对象反复加锁和解锁，甚至加锁操作时出现在循环体中的，那即使没有线程竞争，频繁的进行互斥同步操作也会导致不必要的性能操作。\n1234567public static String test04(String s1, String s2, String s3) &#123;    StringBuffer sb = new StringBuffer();    sb.append(s1);    sb.append(s2);    sb.append(s3);    return sb.toString();&#125;\n\n在上述的连续append()操作中就属于这类情况。JVM会检测到这样一连串的操作都是对同一个对象加锁，那么JVM会将加锁同步的范围扩展(粗化)到整个一系列操作的 外部，使整个一连串的append()操作只需要加锁一次就可以了。\n轻量级锁在JDK 1.6之后引入的轻量级锁，需要注意的是轻量级锁并不是替代重量级锁的，而是对在大多数情况下同步块并不会有竞争出现提出的一种优化。它可以减少重量级锁对线程的阻塞带来的线程开销。从而提高并发性能。\n如果要理解轻量级锁，那么必须先要了解HotSpot虚拟机中对象头的内存布局。上面介绍Java对象头也详细介绍过。在对象头中(Object Header)存在两部分。第一部分用于存储对象自身的运行时数据，HashCode、GC Age、锁标记位、是否为偏向锁。等。一般为32位或者64位(视操作系统位数定)。官方称之为Mark Word，它是实现轻量级锁和偏向锁的关键。 另外一部分存储的是指向方法区对象类型数据的指针(Klass Point)，如果对象是数组的话，还会有一个额外的部分用于存储数据的长度。\n在线程执行同步块之前，JVM会先在当前线程的栈帧中创建一个名为锁记录(Lock Record)的空间，用于存储锁对象目前的Mark Word的拷贝(JVM会将对象头中的Mark Word拷贝到锁记录中，官方称为Displaced Mark Ward)这个时候线程堆栈与对象头的状态如图：\n\n如上图所示：如果当前对象没有被锁定，那么锁标志位为01状态，JVM在执行当前线程时，首先会在当前线程栈帧中创建锁记录Lock Record的空间用于存储锁对象目前的Mark Word的拷贝。\n然后，虚拟机使用CAS操作将标记字段Mark Word拷贝到锁记录中，并且将Mark Word更新为指向Lock Record的指针。如果更新成功了，那么这个线程就拥用了该对象的锁，并且对象Mark Word的锁标志位更新为(Mark Word中最后的2bit)00，即表示此对象处于轻量级锁定状态，如图：\n\n如果这个更新操作失败，JVM会检查当前的Mark Word中是否存在指向当前线程的栈帧的指针，如果有，说明该锁已经被获取，可以直接调用。如果没有，则说明该锁被其他线程抢占了，如果有两条以上的线程竞争同一个锁，那轻量级锁就不再有效，直接膨胀为重量级锁，没有获得锁的线程会被阻塞。此时，锁的标志位为10.Mark Word中存储的指向重量级锁的指针。\n轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头中，如果成功，则表示没有发生竞争关系。如果失败，表示当前锁存在竞争关系。锁就会膨胀成重量级锁。两个线程同时争夺锁，导致锁膨胀的流程图如下：\n\n偏向锁引入背景：在大多实际环境下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获取，那么在同一个线程反复获取所释放锁中，其中并还没有锁的竞争，那么这样看上去，多次的获取锁和释放锁带来了很多不必要的性能开销和上下文切换。\n为了解决这一问题，HotSpot的作者在Java SE 1.6 中对Synchronized进行了优化，引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁。只需要简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果成功，表示线程已经获取到了锁。\n\n偏向锁使用了一种等待竞争出现才会释放锁的机制。所以当其他线程尝试获取偏向锁时，持有偏向锁的线程才会释放锁。但是偏向锁的撤销需要等到全局安全点(就是当前线程没有正在执行的字节码)。它会首先暂停拥有偏向锁的线程，让你后检查持有偏向锁的线程是否活着。如果线程不处于活动状态，直接将对象头设置为无锁状态。如果线程活着，JVM会遍历栈帧中的锁记录，栈帧中的锁记录和对象头要么偏向于其他线程，要么恢复到无锁状态或者标记对象不适合作为偏向锁。\n\n锁的优缺点对比\n\n","slug":"并发/Sychronized详解","date":"2024-12-03T15:23:37.000Z","categories_index":"八股","tags_index":"java,并发框架","author_index":"Ivan"},{"id":"4dfa428c08a3d894cc1c145fbc03603c","title":"Volatile详解","content":"volatile的作用详解防重排序从一个经典的双检索单例模式开始：\n1234567891011121314151617public class Singleton &#123;    public static volatile Singleton singleton;    /**     * 构造函数私有，禁止外部实例化     */    private Singleton() &#123;&#125;;    public static Singleton getInstance() &#123;        if (singleton == null) &#123;            synchronized (singleton.class) &#123;                if (singleton == null) &#123;                    singleton = new Singleton();                &#125;            &#125;        &#125;        return singleton;    &#125;&#125;\n\n现在我们分析一下为什么要在变量singleton之间加上volatile关键字。要理解这个问题，先要了解对象的构造过程，实例化一个对象其实可以分为三个步骤：\n\n分配内存空间。\n初始化对象。\n将内存空间的地址赋值给对应的引用。\n\n但是由于操作系统可以对指令进行重排序，所以上面的过程也可能会变成如下过程：\n\n分配内存空间。\n将内存空间的地址赋值给对应的引用。\n初始化对象\n\n如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。因此，为了防止这个过程的重排序，我们需要将变量设置为volatile类型的变量。\n实现可见性可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到。引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。\n123456789101112131415161718192021222324public class TestVolatile &#123;    private static boolean stop = false;    public static void main(String[] args) &#123;        // Thread-A        new Thread(&quot;Thread A&quot;) &#123;            @Override            public void run() &#123;                while (!stop) &#123;                &#125;                System.out.println(Thread.currentThread() + &quot; stopped&quot;);            &#125;        &#125;.start();        // Thread-main        try &#123;            TimeUnit.SECONDS.sleep(1);            System.out.println(Thread.currentThread() + &quot; after 1 seconds&quot;);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        stop = true;    &#125;&#125;\n\n可以看到 Thread-main 休眠1秒之后，设置 stop &#x3D; ture，但是Thread A根本没停下来，这就是可见性问题。如果通过在stop变量前面加上volatile关键字则会真正stop。\n这里有必要做一下详细的解释：\nCPU的多级缓存机制是大小限制的，上下文切换的时候，会将线程相关状态保存在TCB中，TCB在内存中。下次再次切换会该线程的时候，会从TCB中恢复线程的上下文信息。即，从上面的程序来说，“stop的值被保存在TCB中”，一直读取的都是老值。\n保证原子性：单次读&#x2F;写volatile不能保证完全的原子性，只能保证单次的读&#x2F;写操作具有原子性。\n我们先来看两个经典的问题：\n1. i++为什么不能保证原子性？对于原子性，需要强调一点，也是大家容易误解的一点：对volatile变量的单次读&#x2F;写操作可以保证原子性的，如long和double类型变量，但是并不能保证i++这种操作的原子性，因为本质上i++是读、写两次操作。\ni++其实是一个复合操作，包括三步骤：\n\n读取i的值。\n对i加1。\n将i的值写回内存。\n\nvolatile是无法保证这三个操作是具有原子性的，我们可以通过AtomicInteger或者Synchronized来保证+1操作的原子性。\n2. 共享的long和double变量为什么要用volatile？因为long和double两种数据类型的操作可分为高32位和低32位两部分，因此普通的long或double类型读&#x2F;写可能不是原子的。因此，鼓励大家将共享的long和double变量设置为volatile类型，这样能保证任何情况下对long和double的单次读&#x2F;写操作都具有原子性。\n（目前各种平台下的商用虚拟机都选择把 64 位数据的读写操作作为原子操作来对待，因此我们在编写代码时一般不把long 和 double 变量专门声明为 volatile多数情况下也是不会错的）\nvolatile 的实现原理volatile 可见性实现volatile 变量的内存可见性是基于内存屏障(Memory Barrier)实现:\n内存屏障，又称内存栅栏，是一个 CPU 指令。\n在程序运行时，为了提高执行性能，编译器和处理器会对指令进行重排序，JMM 为了保证在不同的编译器和 CPU 上有相同的结果，通过插入特定类型的内存屏障来禁止+ 特定类型的编译器重排序和处理器重排序，插入一条内存屏障会告诉编译器和 CPU：不管什么指令都不能和这条 Memory Barrier 指令重排序。\n为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存(L1，L2 或其他)后再进行操作，但操作完不知道何时会写到内存。\n如果对声明了 volatile 的变量进行写操作，JVM 就会向处理器发送一条 lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。\n为了保证各个处理器的缓存是一致的，实现了缓存一致性协议(MESI)，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。\n所有多核处理器下还会完成：当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。\nvolatile 变量通过这样的机制就使得每个线程都能获得该变量的最新值。\nvolatile 有序性实现1. happens-beforehappens-before 规则中有一条是 volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。\n（简单说，如果写在读的前面的话，那么一定读到的就是最新值）\n2. 写操作禁止重排序为了性能优化，JMM 在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序。JMM 提供了内存屏障阻止这种重排序。\nJava 编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。\n\n","slug":"并发/Volatile详解","date":"2024-12-03T15:19:43.000Z","categories_index":"八股","tags_index":"java,并发框架","author_index":"Ivan"},{"id":"6f65c61888737e8d4204dac5a8495701","title":"锁的概念","content":"导图\n乐观锁 VS 悲观锁乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。\n先说概念。对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。\n而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。\n乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。\n\n根据从上面的概念描述我们可以发现：\n\n悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。\n乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。\n\n自旋锁 VS 适应性自旋锁阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。\n在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。\n而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。\n\n自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。\n自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。\n无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁这四种锁是指锁的状态，专门针对synchronized的。\n（后续的文章会详细讲解）\n总结而言： 偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。\n公平锁 VS 非公平锁公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。\n非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。\n可重入锁 VS 非可重入锁可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。\n1234567891011121314151617class Test &#123;    public synchronized void func01(int arg)&#123;        System.out.println(arg);        func02(arg + 1);    &#125;    public synchronized void func02(int arg)&#123;        System.out.println(arg);    &#125;    public static void main(String[] args) &#123;        Test test = new Test();        ExecutorService executorService = Executors.newCachedThreadPool();        executorService.execute(() -&gt; test.func01(1));        executorService.execute(() -&gt; test.func01(3));        executorService.shutdown();    &#125;&#125;\n\n如果 synchronized 不是可重入锁的话，那么很明显上述代码会造成死锁。\n可重入锁的实现原理大致是这样的：内部维护了一个计数器，获取到锁的时候，判断一下计数器的值。如果计数器的值是0的话，那么执行+1操作；如果不是0的话，判断当前线程是否是获取到锁的线程，如果是的话，就执行+1操作。释放锁就是每执行完一个同步代码块后，将计数器的值-1，计数器的值为0时，释放锁。\n独享锁(排他锁) VS 共享锁独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。\n共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。\n（本文主要是介绍一下锁的概念上的东西，具体的实现请看后续章节）\n\n","slug":"并发/锁的概念","date":"2024-12-03T15:13:49.000Z","categories_index":"八股","tags_index":"java,并发框架","author_index":"Ivan"},{"id":"6245dd4deb5ec4d8e16e80935a8a30db","title":"线程基础","content":"线程状态的转换新建（New）创建后未启动。\n可运行（Runable）可能正在运行，也可能等待CPU时间片。\n阻塞（Blocking）等待获取一个排它锁，如果其他线程释放了锁，就会结束该状态。\n无限期等待（Waiting）等待其他线程显式的唤醒，否则不会被分配时间片。\n限期等待（Timed Waiting）无需等待其他线程显式地唤醒，在一定时间之后被系统自动唤醒。\n死亡（Terminated）可以是线程结束任务之后自己结束，或产生异常而结束。\n线程使用方式有三种使用线程的方法:\n\n实现 Runnable 接口；\n实现 Callable 接口；\n继承 Thread 类。\n\n实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。\n1.实现 Runnable 接口123456789101112131415class MyRunable implements Runnable &#123;    @Override    public void run() &#123;        System.out.println(&quot;hello world!&quot;);    &#125;    public static void main(String[] args) throws InterruptedException &#123;        MyRunable myRunable = new MyRunable();        Thread thread = new Thread(myRunable);        thread.start();        thread.join();    &#125;    &#125;\n\n2. 实现 Callable 接口123456789101112131415class MyCallable implements Callable&lt;String&gt; &#123;    @Override    public String call() throws Exception &#123;        return &quot;Hello World!&quot;;    &#125;    public static void main(String[] args) throws InterruptedException, ExecutionException &#123;        MyCallable myCallable = new MyCallable();        FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(myCallable);        Thread thread = new Thread(futureTask);        thread.start();        System.out.println(futureTask.get());    &#125;&#125;\n\n3. 继承Thread类1234567891011121314class MyThread extends Thread &#123;    @Override    public void run() &#123;        System.out.println(&quot;Hello World!&quot;);    &#125;    public static void main(String[] args) throws InterruptedException &#123;        MyThread myThread = new MyThread();        myThread.start();        myThread.join();    &#125;    &#125;\n\n实现接口 VS 继承 Thread 类实现接口会更好一些，因为:\n\nJava 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；\n类可能只要求可执行就行，继承整个 Thread 类开销过大。\n\n基础线程机制ExecutorExecutor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。\n主要有三种 Executor:\n\nCachedThreadPool: 一个任务创建一个线程；\nFixedThreadPool: 所有任务只能使用固定大小的线程；\nSingleThreadExecutor: 相当于大小为 1 的 FixedThreadPool。\n\n123456789101112public class Solution &#123;    public static void main(String[] args) &#123;        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();        for(int i=0;i&lt;5;i++)&#123;            final int I = i;            newCachedThreadPool.execute(() -&gt; &#123;                System.out.println(&quot;hello world! &quot;+I);            &#125;);        &#125;        newCachedThreadPool.shutdown();    &#125;&#125;\n\nDaemon守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。\n当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。\nmain() 属于非守护线程。\n使用 setDaemon() 方法将一个线程设置为守护线程。\n12345678public class Solution &#123;    public static void main(String[] args) &#123;        Thread thread = new Thread(() -&gt; &#123;            System.out.println(&quot;hello world!&quot;);        &#125;);        thread.setDaemon(true);    &#125;&#125;\n\nsleep()Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。\nsleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。\n1234public static void main(String[] args) throws InterruptedException &#123;    Thread.sleep(3000);    System.out.println(&quot;hello world!&quot;);&#125;\n\nyield()对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。\n12345678910111213141516public static void main(String[] args) throws InterruptedException &#123;    Thread thread_01 = new Thread(() -&gt; &#123;        System.out.println(1);        Thread.yield();        System.out.println(3);    &#125;);    Thread thread_02 = new Thread(() -&gt; &#123;        System.out.println(2);        Thread.yield();        System.out.println(4);    &#125;);    thread_01.start();    thread_02.start();    thread_01.join();    thread_02.join();&#125;\n\n线程中断一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。\nInterruptedException通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I&#x2F;O 阻塞和 synchronized 锁阻塞。\n1234567891011121314public static void main(String[] args) throws InterruptedException &#123;    Thread thread = new Thread(() -&gt; &#123;        try &#123;            Thread.sleep(3000);            System.out.println(&quot;hello&quot;);        &#125; catch (InterruptedException e) &#123;            System.out.println(&quot;我被干掉了&quot;);        &#125;    &#125;);    thread.start();    Thread.sleep(1000);    thread.interrupt();    thread.join();&#125;\n\ninterrupted()如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。\n但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。\n123456789101112131415161718class MyThread extends Thread &#123;    @Override    public void run() &#123;        while (!interrupted()) &#123;            System.out.println(&quot;没有被打断&quot;);        &#125;        System.out.println(&quot;完蛋了！&quot;);    &#125;        public static void main(String[] args) throws InterruptedException &#123;        MyThread myThread = new MyThread();        myThread.start();        Thread.sleep(1000);        myThread.interrupt();        myThread.join();    &#125;&#125;\n\nExecutor 的中断操作调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。\n123456789101112public static void main(String[] args) throws InterruptedException &#123;    ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();    newCachedThreadPool.execute(() -&gt; &#123;        try &#123;            Thread.sleep(3000);            System.out.println(&quot;hello world&quot;);        &#125; catch (InterruptedException e) &#123;            System.out.println(&quot;被中断喽&quot;);        &#125;    &#125;);    newCachedThreadPool.shutdownNow();&#125;\n\n如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。\n1234567891011public static void main(String[] args) throws InterruptedException, ExecutionException &#123;    ExecutorService executorService = Executors.newCachedThreadPool();    Future&lt;Object&gt; submit = executorService.submit(() -&gt; &#123;        for(int i=0;i&lt;100000000;i++)&#123;            System.out.println(i);        &#125;        return null;    &#125;);    submit.cancel(true);    System.out.println(&quot;hello&quot;);&#125;\n\n线程互斥同步Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。\nsynchronized1. 同步一个代码块1234567891011121314151617181920class Test &#123;    public void func() &#123;        synchronized (this) &#123;            for (int i = 0; i &lt; 10; i++) &#123;                System.out.println(i);            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        Test test = new Test();        ExecutorService executorService = Executors.newCachedThreadPool();        executorService.execute(() -&gt; &#123;            test.func();        &#125;);        executorService.execute(() -&gt; &#123;            test.func();        &#125;);        executorService.shutdown();    &#125;&#125;\n\n它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步：\n123456789101112131415161718192021class Test &#123;    public void func() &#123;        synchronized (this) &#123;            for (int i = 0; i &lt; 10; i++) &#123;                System.out.println(i);            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        Test test = new Test();        Test test2 = new Test();        ExecutorService executorService = Executors.newCachedThreadPool();        executorService.execute(() -&gt; &#123;            test.func();        &#125;);        executorService.execute(() -&gt; &#123;            test2.func();        &#125;);        executorService.shutdown();    &#125;&#125;\n\n2. 同步一个方法1234567891011121314151617181920class Test &#123;    public synchronized void func() &#123;        for (int i = 0; i &lt; 10; i++) &#123;            System.out.println(i);        &#125;    &#125;    public static void main(String[] args) &#123;        Test test = new Test();        Test test2 = new Test();        ExecutorService executorService = Executors.newCachedThreadPool();        executorService.execute(() -&gt; &#123;            test.func();        &#125;);        executorService.execute(() -&gt; &#123;            test2.func();        &#125;);        executorService.shutdown();    &#125;&#125;\n\n它和同步代码块一样，作用于同一个对象。\n3. 同步一个类12345678910111213141516171819202122class Test &#123;    public void func() &#123;        synchronized (Test.class) &#123;            for (int i = 0; i &lt; 10; i++) &#123;                System.out.println(i);            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        Test test = new Test();        Test test2 = new Test();        ExecutorService executorService = Executors.newCachedThreadPool();        executorService.execute(() -&gt; &#123;            test.func();        &#125;);        executorService.execute(() -&gt; &#123;            test2.func();        &#125;);        executorService.shutdown();    &#125;&#125;\n\n作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。\n4. 同步一个静态方法123456789101112131415161718class Test &#123;    public static synchronized void func() &#123;        for (int i = 0; i &lt; 10; i++) &#123;            System.out.println(i);        &#125;    &#125;    public static void main(String[] args) &#123;        ExecutorService executorService = Executors.newCachedThreadPool();        executorService.execute(() -&gt; &#123;            Test.func();        &#125;);        executorService.execute(() -&gt; &#123;            Test.func();        &#125;);        executorService.shutdown();    &#125;&#125;\n\n作用于整个类。\nReentrantLockReentrantLock 是 java.util.concurrent(J.U.C)包中的锁。\n12345678910111213141516171819202122232425class Test &#123;    private Lock lock;    &#123;        lock = new ReentrantLock();    &#125;    public void func() &#123;        lock.lock();        try &#123;            for(int i=0;i&lt;10;i++)&#123;                System.out.println(i);            &#125;        &#125; finally &#123;            lock.unlock();        &#125;    &#125;    public static void main(String[] args) &#123;        Test test = new Test();        ExecutorService executorService = Executors.newCachedThreadPool();        executorService.execute(() -&gt; test.func());        executorService.execute(() -&gt; test.func());        executorService.shutdown();    &#125;&#125;\n\n比较1. 锁的实现synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。\n2. 性能新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。\n3. 等待可中断当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。\nReentrantLock 可中断，而 synchronized 不行。\n4. 公平锁公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。\nsynchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。\n5. 锁绑定多个条件一个 ReentrantLock 可以同时绑定多个 Condition 对象。\n使用选择除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。\n线程之间的协作当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。\njoin()在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。\n（这里就不掩饰了，经常用的）\nwait() notify() notifyAll()调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。\n它们都属于 Object 的一部分，而不属于 Thread。\n只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateExeception。\n使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。\n12345678910111213141516171819202122232425262728class Test &#123;    public synchronized void before() &#123;        try &#123;            Thread.sleep(1500);        &#125; catch (InterruptedException e) &#123;            System.out.println(&quot;被打断lou&quot;);        &#125;        System.out.println(&quot;before&quot;);        notifyAll();    &#125;    public synchronized void after() &#123;        try &#123;            wait();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(&quot;after&quot;);    &#125;    public static void main(String[] args) &#123;        Test test = new Test();        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();        newCachedThreadPool.execute(() -&gt; test.after());        newCachedThreadPool.execute(() -&gt; test.before());        newCachedThreadPool.shutdown();    &#125;&#125;\n\n（以上代码有死锁的风险，如果是after函数先执行，那没有问题；如果是before先执行，就证明了after没有拿到锁，等before释放锁之后，after拿到锁，然后进入休眠状态，然后也没有人唤醒它）\nwait() 和 sleep() 的区别\nwait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法\nwait() 会释放锁，sleep() 不会\n\nawait() signal() signalAll()java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。\n123456789101112131415161718192021222324252627282930313233343536373839404142class Test &#123;    private Lock lock;    private Condition condition;    &#123;        lock = new ReentrantLock();        condition = lock.newCondition();    &#125;    public void before() &#123;        lock.lock();        try &#123;            Thread.sleep(1500);            System.out.println(&quot;before&quot;);        &#125; catch (InterruptedException e) &#123;            System.out.println(&quot;被打断lou&quot;);        &#125;        finally&#123;            condition.signalAll();            lock.unlock();        &#125;    &#125;    public void after() &#123;        lock.lock();        try &#123;            condition.await();            System.out.println(&quot;after&quot;);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        finally&#123;            lock.unlock();        &#125;    &#125;    public static void main(String[] args) &#123;        Test test = new Test();        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();        newCachedThreadPool.execute(() -&gt; test.after());        newCachedThreadPool.execute(() -&gt; test.before());        newCachedThreadPool.shutdown();    &#125;&#125;\n\n（和上文一下，也是会有死锁的风险，虽然我没有测出来，但是理论上来说，是这样的）\n\n","slug":"并发/线程基础","date":"2024-12-03T14:40:50.000Z","categories_index":"八股","tags_index":"java,并发框架","author_index":"Ivan"},{"id":"f5276a6470bcf00967ce9121d16c19cd","title":"并发基础","content":"为什么需要多线程？早期的单CPU时代，CPU制作厂商沉迷于提高单个核心的计算能力。但是随着时间的推移，提高单核心的计算能力越来越困难了。于是乎，堆核心成为了快速提高CPU计算能力的另一种途径。这样一来，多个任务就可以并行的跑在CPU的不同核心上。\n一个程序只是一个单线程的应用的话，无法利用现代多核心CPU的优势。所以，学习并发编程可以提高我们程序的运行效率。\n线程安全示例多线程编程虽然可以提高我们程序的运行效率，但是同样也面临着线程安全或者说并发安全问题：\n12345678910111213141516171819202122232425262728public class ThreadUnsafeExample &#123;    private int cnt = 0;    public void add() &#123;        cnt++;    &#125;    public int get() &#123;        return cnt;    &#125;    public static void main(String[] args) throws InterruptedException &#123;        final int threadSize = 1000;        ThreadUnsafeExample example = new ThreadUnsafeExample();        final CountDownLatch countDownLatch = new CountDownLatch(threadSize);        ExecutorService executorService = Executors.newCachedThreadPool();        for (int i = 0; i &lt; threadSize; i++) &#123;            executorService.execute(() -&gt; &#123;                example.add();                countDownLatch.countDown();            &#125;);        &#125;        countDownLatch.await();        executorService.shutdown();        System.out.println(example.get());    &#125;&#125;\n\n运行的结果总是小于1000。\n并发问题发生的三要素1. 可见性：CPU缓存引起的\nCPU直接与自己的L1级缓存进行交互，L1级缓存的数据来自L2，L2中的数据来自L3，L3中的数据来自内存。\n假设线程A和线程B并发的执行这段代码的话，线程A在CPU1上执行，线程B在CPU2上执行，会有以下这种情况：\n线程A将i的值从内存载入CPU1对应的缓存中，此时i的值为0；\n线程B将i的值从内存载入CPU2对应的缓存中，此时i的值为0；\n线程A执行了自增操作，CPU1缓存中的i的值为1；\n线程B执行了自增操作，CPU2缓存中的i的值为1；\n线程A将CPU1缓存i的值写入内存，内存中i的值是1；\n线程B将CPU2缓存i的值写入内存，内存中i的值是1。\n其中一次操作的值将另一次操作的值给覆盖了。\n本质问题就是一个线程在CPU缓存中修改了共享的值，另一个线程并不知道。\n2. 原子性：分时复用引起的对于【i++】操作来说，它对应三条指令：\n\n将变量i从内存中读到寄存器\n将寄存器中i的值+1\n写回内存（由于缓存机制，也可能是缓存，而不是内存）\n\n我们都知道，CPU运作机制就是执行一条又一条的指令。无论是Linux、windows还是Max OS，它们都属于分时操作系统。CPU并发的运行着N多个程序。CPU有一个时钟硬件设备，定期向CPU发送时钟中断信号，CPU收到信号后，操作系统介入，调度下一个程序运行。\n所以，就算是在只有一个CPU的机器上，运行多线程的程序，由于分时复用机制，一个操作如果由多条指令集合构成，那么也会造成并发安全问题。\n3. 有序性：重排序引起1234int i = 0;              boolean flag = false;i = 1;                //语句1  flag = true;          //语句2\n\n从我们开发的角度来看，语句1应该在语句2之前执行的，那事实真的是这样嘛？\n在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：\n\n编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。\n指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。\n内存系统的重排序。由于处理器使用缓存和读 &#x2F; 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。\n\n从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：\n\n上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。\nJava是怎么解决并发问题的？JMM（Java内存模型）。\n理解的第一个维度：核心知识点\nJMM本质上可以理解为，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括：\n\nvolatile、synchronized 和 final 三个关键字\nHappens-Before 规则\n\n理解的第二个维度：可见性，有序性，原子性\n\n原子性\n\n在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。\n请分析以下哪些操作是原子性操作：\n1234x = 10;        //语句1: 直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中y = x;         //语句2: 包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。x++;           //语句3： x++包括3个操作：读取x的值，进行加1操作，写入新的值。x = x + 1;     //语句4： 同语句3\n\n只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。\nJava内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。\n\n可见性\n\nJava提供了volatile关键字来保证可见性。\n当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。\n而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。\n另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。\n\n有序性\n\n在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。当然JMM是通过Happens-Before 规则来保证有序性的。\nHappens-Before 规则上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。\n1. 单一线程原则在一个线程内，在程序前面的操作先行发生于后面的操作。\n2. 管程锁定规则一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。\n3. volatile变量规则对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。\n4. 线程启动规则Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。\n5. 线程加入规则Thread 对象的结束先行发生于 join() 方法返回。\n6. 线程中断规则对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。\n7. 对象终结规则一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始。\n8. 传递性如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。\n线程安全一个类在可以被多个线程安全调用时就是线程安全的。\n线程安全不是一个非真即假的命题，可以将共享数据按照安全程度的强弱顺序分成以下五类: 不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。\n1. 不可变不可变(Immutable)的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。\n多线程环境下，应当尽量使对象成为不可变，来满足线程安全。\n不可变的类型:\n\nfinal 关键字修饰的基本数据类型\nString\n枚举类型\nNumber 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。\n\n2. 相对线程安全相对线程安全需要保证对这个对象单独的操作是线程安全的，在调用的时候不需要做额外的保障措施。但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。\n在 Java 语言中，大部分的线程安全类都属于这种类型，例如 Vector、HashTable、Collections 的 synchronizedCollection() 方法包装的集合等。\n3. 线程兼容线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。Java API 中大部分的类都是属于线程兼容的，如与前面的 Vector 和 HashTable 相对应的集合类 ArrayList 和 HashMap 等。\n4. 线程对立线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于 Java 语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。\n线程安全的实现方法1. 互斥同步synchronized 和 ReentrantLock。\n2. 非阻塞同步互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。\n互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁(这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁)、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。\n（一）CAS随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略: 先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施(不断地重试，直到成功为止)。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。\n乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是: 比较并交换(Compare-and-Swap，CAS)。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。\n（二）ABA如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。\nJ.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。\n3. 无同步方案要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。\n（一）栈封闭多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。\n（二）线程本地存储（Thread Local Storage）如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。\n符合这种特点的应用并不少见，大部分使用消费队列的架构模式(如“生产者-消费者”模式)都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”(Thread-per-Request)的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。\n可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。\nThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。\n在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。\n（三）可重入代码这种代码也叫做纯代码(Pure Code)，可以在代码执行的任何时刻中断它，转而去执行另外一段代码(包括递归调用它本身)，而在控制权返回后，原来的程序不会出现任何错误。\n可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。\n\n","slug":"并发/并发基础","date":"2024-12-03T14:35:07.000Z","categories_index":"八股","tags_index":"java,并发基础,并发框架","author_index":"Ivan"},{"id":"293c17b4d2a4292133cc4d1ffd7f8725","title":"计算机网络","content":"OSI模型、TCP&#x2F;IP模型、五层模型 ？\n刚开始学习的小伙伴一定会被这些搞懵逼的，傻傻分不清哦。\n这个所谓的七层模型，实际上那帮搞学术的弄出来的，但是很可惜，并没有流行开了，主要原因就是搭建这样的体系架构网络很复杂。（了解一下就行了）\nTCP&#x2F;IP网络模型是目前最流行的网络协议模型。在我们的实际生活中被广泛的使用。\n最后这个五层协议，主要是为了教学需要而设计的，了解一下即可，但是我还是会简单介绍的。\nTCP&#x2F;IP模型每一层的作用？\n应用层\n这是我们大部分开发最为熟悉的一层，应用层对于我们来说，是相对可控的，因为传输层及以下是操作系统的网络协议栈接管，用户态的我怎么敢触碰内核态的你。\n你所熟知的各种协议，比如 HTTP、HTTPS、DNS等，都属于应用层协议。\n\n传输层\n这一层的协议就少了，就两个：TCP和UDP\n之后的文章会做详细的讲解，这里简单说一下两个协议的特点。\nTCP提供面向连接的、可靠的传输服务；UDP提供无连接、尽最大努力交付的传输服务。\n\n网络层\nIP协议起了至关重要的作用，想一下，现在的网络体系，离得开IP嘛？\n\n网络接口层\n对于上层的协议来说，这一层就是数据的发送层，实际上，并不是，后面会说。\n\n\n数据发送的大致流程？\n应用层将需要发送的数据交给传输层，传输层拿到后加上TCP头部，向下交给网络层，网络层又加上IP头部，交给网络接口层，加上帧头和帧尾，然后发出去。\n（上层协议委托的数据对于下层协议来说是透明的，比如说对于网络层来说，它是不知道有TCP头部和应用数据之分的，只会认为是一个整体）\n网络接口层简介物理层没有什么好说的，这里主要说一下数据链路层。\n数据链路层的协议很多，但是他们都面临着三个问题：封装成帧、透明传输和差错检测\n\n封装成帧\n数据链路层会将网络层交付的数据添加首部和尾部，这就封装成了一个帧，首部和尾部就标识了该帧的开始与结束。\n帧长 &#x3D; 首部长度 + 数据段长度 + 尾部长度。\nMTU（最大传输单元） —— 数据部分长度限制，看图：\n\n帧定界符：就是表示一个帧的开始与结束的标志。=&gt; 有个场景，如果发送端发送的时候，突然“掉线”了，那么接收端就永远不会收到帧结束符。等到下一个帧的帧开始符到达时，接收端就知道上一个帧不完整了，就会把它丢弃。\n\n\n透明传输\n这个问题与数据链路层的机制有关系。数据链路层奉行一种“来者不拒”的理念，“只要给我的，我都要”，对于帧的隔离，识别比特流中的定界符就好了。也就是说，数据链路层并不知道你传的内容是些什么玩意儿，它只负责去“截断”（找到帧开始符合帧结束符）。所以，什么样的比特组合都能通过该层。对于这些比特流而言，数据链路层就好像不存在一样。\n但是这样会引发一个什么样的问题呢？对于文本数据还好说，里面的内容都是键盘上录入进去的，帧开始符和帧结束符找两个用户录入不进去的字符就好了。可是，如果是一些音视频或者其他的比特流，很难保证里面其中一个字节的比特组合不会与帧开始符和帧结束符不同（毕竟对于数据链路层来说，它唯一能做的就是扫描字节，找到帧定界符）。\n如果数据段中出现了“帧开始”符，那么前面的数据就会被丢弃；如果数据段中出现了“帧结束符”，那么后面的数据就会被丢弃。\n为了解决该问题，发送端在数据链路层封装成帧的时候，如果数据内容里面出现了帧定界符，那么就在对应的字节前面添加一个转义字符，如果转义字符也重复了，那么就再添加一个转移字符。&#x3D;&gt; 该过程称作字节填充或者字节填充。\n\n\n差错检测\n比特差错 &#x3D;&gt; 世界上没有完美无暇的东西，总会出问题的。数据在传输的过程中，可能会出现0变成1，或者1变成0的情况。\n泼出去的水无法改变，那就只能在收到的时候，利用各种手段去检测数据是否完整了。\n在数据链路层，广泛采用循环冗余检验CRC检错技术 &#x3D;&gt; 其实就是数据段后添加一个冗余码（帧检验序列FCS） &#x3D;&gt; 发送端根据一定的算法生成，接收端根据一定的算法检测（别问，问就是了解就行了，难道我还要把算法的逻辑说出来嘛，呜呜呜）。\n值得一提的是，FCS的生成和CRC的运用，都是在硬件层面进行的，非常之快。\n数据链路层只能以一种无限接近1的概率向上抛出帧，保障帧无差错。\n但是依然会出现这三个问题：帧丢失、帧失序、帧重复 &#x3D;&gt; 不能提供可靠的传输服务\n\n\n关于MAC地址相信大家都听过一个词，叫做“MAC地址”，到底是一个什么东西呢？ 它就是一个硬件地址，网卡（或者说网络适配器）厂商在生产的时候，写死在硬件里面的，全球唯一的。 网络适配器有过滤功能。每收到一个MAC帧，先用硬件检测一下MAC帧中的硬件地址，看一下是不是发往本站的。是，则收下；不是，则丢弃。 （所以，MAC地址也叫做硬件地址）\n\n","slug":"计网/计算机网络","date":"2024-12-03T14:23:01.000Z","categories_index":"八股","tags_index":"计算机网络","author_index":"Ivan"},{"id":"282ca770e6df8001dbda062738b2a12a","title":"java面向对象","content":"Java给我的感觉就是一个有一个的类，毕竟类是其代码的基本组织单元。\n对象是类实例化的结果，所以对象有时也被称为实例，从类到对象的过程称为实例化。\n面向对象的三大特点：封装、继承、多态\n封装学术上的东西就不讲了，从开发的视角阐述这个概念。\n通常我们都会将字段的可访问性设置为private，然后通过Getter和Setter方法对外提供查看和设置字段值的接口。\n（我习惯于称作字段，貌似大家都喜欢叫属性）\n上代码：\n12345678910111213141516171819202122public class Person &#123;    private String name;    private int age;        public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;&#125;\n\n这是一个Person类，对人这个实体的抽象。类中有两个字段：name和age，代表人的姓名和年龄。从代码层面上看，Person类外面的任何方法都不能直接访问这两个字段，只能通过类中提供的方法进行访问和修改。\n这就是封装！！！\n至于说有什么有点，AI来吧：\n面向对象编程（OOP）中的封装是一个核心概念，它提供了以下优点：\n\n数据隐藏：封装允许对象隐藏其内部状态和复杂性，只暴露一个清晰的接口给外部世界。这降低了代码的复杂性，并提高了代码的可理解性。\n\n实现细节的保护：通过隐藏内部实现，封装防止了外部代码直接访问对象的内部数据，从而防止了可能的错误或不当的修改。\n\n接口与实现的分离：封装使得对象的内部实现可以独立于其接口进行修改，只要接口保持不变，外部代码就不需要修改。\n\n提高代码的可维护性：由于对象的内部实现被隐藏，修改这些实现不会影响依赖于该对象的代码，这使得维护和更新变得更加容易。\n\n增强代码的安全性：封装可以防止外部代码访问或修改对象的私有成员，这有助于防止潜在的安全风险。\n\n促进重用：封装提供了一个清晰的接口，使得对象可以在不同的程序和环境中重用，而不需要了解其内部工作机制。\n\n减少耦合：封装减少了类与类之间的直接依赖，从而降低了系统中各部分之间的耦合度。\n\n提高代码的可测试性：封装使得单元测试可以针对特定的对象进行，而不需要考虑整个系统的复杂性。\n\n支持多态：封装与多态一起工作，允许基于接口而非实现编程，这使得使用基类指针或引用调用派生类的方法成为可能。\n\n封装继承：在支持继承的语言中，封装允许子类继承父类的属性和方法，同时可以扩展或修改这些属性和方法，而不需要更改外部代码。\n\n促进模块化设计：封装鼓励将系统分解成模块或类，每个模块或类都有自己的职责，这有助于构建更大规模的系统。\n\n提高代码的组织性：封装要求将相关的数据和操作这些数据的方法组合在一起，这有助于提高代码的组织性和结构化。\n\n\n总的来说，封装是面向对象设计的一个关键原则，它有助于创建更健壮、更灵活和更易于维护的软件。\n随便扫一眼就行了。。。\n继承这个没有什么好说的，子类可以继承父类非private的字段和方法。\n在实际开发中，我们往往使用父类变量去引用子类对象，除非想调用子类对象的扩展的方法。\n1234567891011121314151617class Student extends Person &#123;    public Student(String name, int age) &#123;        super(name, age);    &#125;    public void sayHello()&#123;        System.out.println(&quot;Hello Java&quot;);    &#125;&#125;class Test &#123;    public static void main(String[] args) &#123;        Person person = new Student(&quot;kaiven&quot;, 20);        System.out.println(person.getName() + person.getAge());    &#125;&#125;\n\n由于Student继承了Person，所以Person类型的变量可以引用Student类型的对象。\n当然，考虑以下语句，能够正常运行：\n如果你尝试了，会发现不行。其实是可以的，因为引用的是Student对象嘛。但是，通不过编译器，因为Person类中没有sayHello这个方法。\n如果我们想调用属于这个子类对象的特有方法，只能通过类型强转去通过编译器的检查：\n1234567class Test &#123;    public static void main(String[] args) &#123;        Person person = new Student(&quot;kaiven&quot;, 20);        Student student = (Student) person;        student.sayHello();    &#125;&#125;\n\n多态不要去抓着这个字眼不放了，你越想就越容易钻牛角尖。\nJava中的多态，分为编译时多态和运行时多态。\n编译时多态指的是方法的重载：\n1234567891011121314class Student extends Person &#123;        public Student(String name, int age) &#123;        super(name, age);    &#125;    public void sayHello()&#123;        System.out.println(&quot;Hello Java&quot;);    &#125;    public void sayHello(String content)&#123;        System.out.println(content);    &#125;&#125;\n\n运行时多态指的是程序中定义的对象引用的具体类型在运行期间才确定。\n运行时多态的三个条件：继承、覆盖（重写）、向上转型\n123456789101112131415161718192021222324252627282930313233class Student extends Person &#123;    public Student(String name, int age) &#123;        super(name, age);    &#125;    @Override    public String getName() &#123;        return &quot;我就不告诉你我的名次&quot;;    &#125;    &#125;class Teacher extends Person&#123;    public Teacher(String name, int age) &#123;        super(name, age);    &#125;        @Override    public String getName() &#123;        return &quot;我可以告诉你我的名字，但是是假的&quot;;    &#125;&#125;class Test &#123;    public static void main(String[] args) &#123;        Person person01 = new Student(&quot;kaiven&quot;, 20);        Person person02 = new Teacher(&quot;jack&quot;, 22);        System.out.println(person01.getName());        System.out.println(person02.getName());    &#125;&#125;\n\nJVM知道应该调用哪个方法的，不用担心。\n\n","slug":"java基础/javamxdx","date":"2024-12-03T13:21:54.000Z","categories_index":"八股","tags_index":"java","author_index":"Ivan"},{"id":"5d0fb8fa16015e90389a3f31d7e8667c","title":"java导学","content":"恭喜你，成功入坑Java开发，以后将走上后端开发的道路。\nJava是一门什么样的编程语言呢？\n（AI的回答）\nJava 是一种广泛使用的编程语言，它由Sun Microsystems（现在是Oracle Corporation的一部分）在1995年发布。Java 被设计为具有跨平台兼容性、安全性、网络中心化和健壮性等特点，这使得它成为了构建企业级应用、Android 应用、网站后台服务和其他类型软件的热门选择。\n以下是Java的一些关键特性：\n\n跨平台兼容性：Java的口号“一次编写，到处运行”（Write Once, Run Anywhere，简称WORA）强调了其跨平台的能力。这意味着在一台机器上编写的Java程序可以在其他装有Java虚拟机（JVM）的机器上运行，而无需任何修改。\n\n面向对象：Java是一种面向对象的语言，它支持类、对象、封装、继承和多态等概念。\n\n内存管理：Java有自动垃圾回收机制，这意味着程序员不需要（也不能）手动管理内存。这减少了内存泄漏和其他内存管理错误的可能性。\n\n健壮性：Java的设计目标之一是创建一个健壮的语言，这意味着它旨在消除某些类别的错误，例如数组越界、野指针等。\n\n安全性：Java提供了一个安全的环境，其中包括一个沙箱执行环境和一个强大的安全管理体系。\n\n多线程：Java内置了对多线程编程的支持，这使得开发多线程应用程序变得相对容易。\n\n网络编程：Java有强大的网络编程支持，这使得它非常适合创建网络应用程序和服务。\n\n开源：Java有一个活跃的开源社区，提供了大量的库和框架，如Spring、Hibernate等，这些工具可以帮助开发者快速构建高质量的应用程序。\n\n\nJava在企业级应用开发中非常流行，也被广泛应用于Android移动应用开发。此外，Java还被用于桌面应用程序、游戏开发、科学计算和教育等领域。随着技术的发展，Java也在不断更新和改进，以适应新的编程范式和市场需求。\n快速的浏览一下就好了，对于一个小白来说，这些都是废话。学就完事儿了，现在，管这么多的概念干嘛。\n学的东西是不是很多嘞？\n的确是这样的，技术这种东西是学不完的。我之所以入坑Java就是因为觉得Java框架的统一性，就只用学一个Spring框架。可是深入学习后，才知道是我肤浅了。\n（之前是写前端的，然后就是觉得前端的生态太乱了，真的是百花齐放，然后转到Java后端，发现，其实也差不多）\n但是无论技术多么的复杂多样，掌握好基本的开发要求，不断的扩展知识和技术，这才是正解。\n如果你和我一样，学一个东西非要去搞清楚底层的运行原理或者源码实现，那么，恭喜你，你会陷入一个内耗循环。\n不是说这样不好，但是技术这个东西真的太多啦。比如说一个消息中间件，就有ActiveMQ、RabbitMQ、Kafka、RocketMQ。。。\n你去学嘛，你去看源码嘛，哈哈。\n对于一门技术，我们的态度应该是：\n\n搞明白基本的概念和特性，明白大致的应用场景\n学会技术的基本使用以及了解一些高级特性的适用场景\n对于基本原理，围绕面试八股展开，出现频率高的，重点学习\n源码嘛，看时间喽（如果有人给你出视频去讲源码了，那就不要浪费时间自己看）\n\n不要总是想着要把技术搞得多么的牛逼，要让面试官觉得你牛逼，那才是真的牛逼。\n（面试，也是一门技术活）\n不过，现在，不用考虑这么多，干就完事儿！\n\n","slug":"java导学","date":"2024-12-03T13:13:19.000Z","categories_index":"八股","tags_index":"java,java基础","author_index":"Ivan"},{"id":"eb843316efe7fc0d2e0c7904a0ae2582","title":"mysql进阶","content":"MySQL的系统架构1、数据库和数据库实例在与MySQL相关的学习和研究中，我们需要搞清楚一些概念：\n\n数据库：按照一定的数据结构来组织、存储和管理数据的仓库，通常由数据库管理系统进行管理。\n数据库管理软件（RDBMS）：就是我们说的数据库管理软件，我们常说的MySQL指的就是它。\n数据库实例：其实就是正在运行的数据库管理程序，一个数据库管理程序我们称作一个数据库实例。\n\n2、MySQL架构\n（现在的话，有个印象就行了）\n（1）MySQL向外提供的交互接口Connectors组件，是MySQL向外提供的交互组件，如java,.net,php等语言可以通过该组件来操作SQL语句，实现\n与SQL的交互。通过客户端&#x2F;服务器通信协议与MySQL建立连接。MySQL 客户端与服务端的通信方式是 “ 半双工\n”。对于每一个 MySQL 的连接，时刻都有一个线程状态来标识这个连接正在做什么。\n（2）管理服务组件和工具组件提供MySQL的各项服务组件和管理工具，如备份(Backup)，恢复(Recovery)，安全管理(Security)等功能。\n（3）连接池组件负责监听客户端向MySQL Server端的各种请求，接收请求，转发请求到目标模块。每个成功连接MySQL Server的客户请求都会被创建或分配一个线程，该线程负责客户端与MySQL Server端的通信，接收客户端发送的命令，传递服务端的结果信息等。\n（4）SQL接口组件接收用户SQL命令，如DML,DDL和存储过程等，并将最终结果返回给用户。\n（5）查询分析器组件首先分析SQL命令语法的合法性，并进行抽象语法树解析，如果sql有语法错误，会抛出异常信息。\n（6）优化器组件对SQL命令按照标准流程进行优化分析，mysql会按照它认为的最优方式进行优化，选用成本最小的执行计划。\n（7）缓存组件缓存和缓冲组件，这里边的内容我们后边会详细的讲解。\n（8）MySQL存储引擎MySQL属于关系型数据库，而关系型数据库的存储是以表的形式进行的，对于表的创建，数据的存储，检索，更新等都是由MySQL存储引擎完成的。\nMySQL存储引擎在MySQL中扮演着重要角色。研究过SQL Server和Oracle的读者可能很清楚，这两种数据库的存\n储引擎只有一个，而MySQL的存储引擎种类比较多，如MyIsam存储引擎，InnoDB存储引擎和Memory存储引\n擎。\n因为mysql本身就是开源的，他允许第三方基于MySQL骨架，开发适合自己业务需求的存储引擎。从MySQL存储引擎种类上来说，可以分为官方存储引擎和第三方存储引擎，比较常用的存储引擎包括InnoDB存储引擎，MyIsam 存储引擎和Momery存储引擎。\n3、SQL语句的执行流程\n（图应该都可以看得懂的吧）\n小问题：MySQL8为什么取消了查询缓存？\n锁争用问题：在高并发环境中，查询缓存会引起锁争用问题。每次对查询缓存的读写操作都需要获取锁，这在高并发下会导致锁的争用，进而引发性能瓶颈。\n缓存无效化问题：查询缓存的无效化机制导致缓存命中率较低。当一个表的数据发生变化时（如INSERT、UPDATE、DELETE操作），与该表相关的所有查询缓存都会被无效化。对于写操作频繁的系统，这意味着查询缓存的有效性非常短暂，导致缓存命中率很低，反而增加了缓存维护的开销而没有带来明显的性能提升。\n内存开销：查询缓存的管理需要额外的内存资源，而且如果查询语句的字符大小写、空格或者注释的不同，查询缓存都会认为是不同的查询（因为他们的hash值会不同），这可能会导致内存资源的过度消耗。\n\nMySQL的目录结构windows中的目录结构在mysql启动的时候，会从【安装目录】加载软件数据，在运行过程中，会从【数据目录】中读取数据。这两个目\n录我们不要放在一起，避免重新安装软件导致数据丢失：\n\n\nbin目录：用于放置一些可执行的工具文件，如mysql.exe、mysqld.exe、mysqlshow.exe等。\ninclude目录：用于放置一些头文件，如：mysql.h、mysql_ername.h等。（MySQL是C语言写的，这个都知道的吧）\nlib目录：用于放置一系列库文件。\ndata目录：用于放置一些日志文件以及数据库。\nmy.ini文件：MySQL的配置文件，MySQL实例初始化时会加载该文件中的内容\n\n\ndata目录中，每个文件夹对应一个数据库，数据库中的表就是一个又一个的文件。\nLinux中的文件目录这个和windows下的文件目录是差不多的，如果是默认的安装方式的话，文件是分散在不同地方的。\n（百度或者问AI）\n字符集和排序规则mysql支持大量的字符集，但是我们通常使用的是utf8，【show collation】命令可以查看mysql支持的所有的排序规则和字符集，如下所示部分：\n1show collation like &#x27;%utf8%&#x27;;\n\n\n一种字符集会对应很多的规则：\n\nutf8-polish-ci，表示utf-8的字符集的波兰语的比较规则，ci代表忽略大小写。\n\nutf8-general-ci，就是通用的忽略大小写的utf8字符集比较规则。\n\nutf8mb4_0900_ai_ci中的0900指的是Unicode 9.0的规范，后边的后缀代表不区分重音也不区分大小写，他是utf8mb4字符集一个新的通用排序归则。\n\n\n\nutf8和utf8mb4的区别：\n\nutf8mb3(utf-8)：使用1~3个字节表示字符，utf8默认就是utf8mb3。\n\nutf8mb4：使用1~4个字节表示字符，他是utf8的超集，甚至可以存储很多【emoji表情?????】，\n\nmysql8.0已经默认字符集设置为utf8mb4。\n\n\n【字符集】和【比较规则】可以作用在全局、数据库、表、甚至是列级别。（想了解的自行百度怎么设置，大家最熟悉的莫过于在创建库和表的时候指定字符集和比较规则吧）\nMySQL修改配置的方法1、修改全局变量很显然，这些东西你百度都能得到的，这里就不去复制粘贴了。全局修改的变量对每一个会话都起作用。\n2、当前会话的变量这个修改的作用域只对某一个会话起作用。\n3、修改配置文件先看一个示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225[client]port = 3306socket = /tmp/mysql.sock[mysqld]port = 3306basedir = /project/mysql/mysql-8.0.18datadir = /project/mysql/datapid-file = /project/mysql/mysql-8.0.18/mysqld.pidsocket = /tmp/mysql.socktmpdir = /project/mysql/tmpuser = mysql#关闭MySQL X plugin（33060）mysqlx=0###日志配置------innodb_log_file_size = 1Glog_error = /project/mysql/mysql-8.0.18/log/error.logslow_query_log = 1long_query_time = 5slow_query_log_file = /project/mysql/mysql-8.0.18/log/slow.log#记录没有索引导致的慢查询###连接配置------#最大连接数max_connections = 3000#最大错误连接数max_connect_errors = 10#连接闲置超时时间interactive_timeout = 1800wait_timeout = 1800#连接响应超时时间connect-timeout = 60###默认配置（插件、字符------default_authentication_plugin = mysql_native_passwordcharacter-set-server = utf8sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLESinnodb_log_file_size = 1024M#关闭InnoDB严格模式，防止报错 Row size too large (&gt; 8126)innodb_strict_mode=0default-storage-engine=INNODBbind-address = 0.0.0.0#域名解析，设置为1之后就不能直接127.0.0.1连接数据库，需要root@127.0.0.1#skip_name_resolve = 1#忽略大小写，此项很重要（MySQL8之后的版本必须在初始化就设定此参数，初始化之后配置更改不生效）lower_case_table_names = 1###主备相关------server-id = 25log-bin = backup.log#二进制日志格式,三种模式：statement语句&gt;模式,row行模式，mixed混合模式binlog_format = mixedmax_binlog_size = 1Gexpire_logs_days = 7#事务提交前产生的日志缓存binlog_cache_size = 16M#Auto_increment_increment和auto_increment_offset用于主－主服务器（master-to-master）复制，避免主键冲突#为了避免两台服务器同时做更新时自增长字段的值之间发生冲突。一般在主主同步配置时，需要将两台服务器的auto_increment_increment增长量都配置为2（根据从库节点数量配置），而要把auto_increment_offset分别配置为1（主库）和2（从库）#递增值auto_increment_increment = 2#初始值auto_increment_offset = 1#表示需要记录二进制日志的数据库binlog_do_db=csspbinlog_do_db=mysql#从库配置replicate_do_db=cssp#表示不需要记录二进制日志的数据库binlog_ignore_db=information_schema#忽略表replicate-wild-ignore-table=pva_db.pva_login_%replicate-wild-ignore-table=pva_db.pva_login_log#忽略错误代码（从库配置）slave-skip-errors = 1032,1062,126,1114,1146,1048,1396#自动清空不再需要中继日志（从库配置）relay-log-purge = 1###系统资源相关------#接收连接请求队列back_log = 600#最大打开文件数（前提mysql用户需要调整最大打开文件数）open_files_limit = 10240#所有线程打开表数量table_open_cache = 512#处理请求包最大大小max_allowed_packet = 32M#临时表最大大小tmp_table_size = 512M#独立内存表所允许最大容量max_heap_table_size = 512M#用于索引块的缓冲区大小key_buffer_size = 64M#查询排序的缓冲区大小sort_buffer_size = 8M#读操作的缓冲区大小read_buffer_size = 8M#联表查询缓冲区大小join_buffer_size = 8M#批量数据插入缓存bulk_insert_buffer_size = 120M#保存索引以及原始数据的缓冲池（原则上最大为系统内存的 80%）innodb_buffer_pool_size = 2G#脏页比例，脏页占innodb_buffer_pool_size的比例时，触发刷脏页到磁盘（25~50）innodb_max_dirty_pages_pct = 30#事务提交 flushinnodb_flush_log_at_trx_commit = 1#1，（默认值）每一次提交刷新日志到磁盘#2，先写入缓存，由系统设置每秒刷新日志到磁盘（可能丢失1~2秒的数据）###多线程优化------#可重新被利用保存在缓存中的线程数量thread_cache_size = 300###其他配置------#占用内存过高调整以下参数配置#table_definition_cache = 400#open_files_limit = 2048#table_open_cache = 256#跳过密码表检查#skip-grant-tables\n\n修改了配置文件需要重启MySQL服务实例重新加载。\n内置数据库\nmysql：这个库很重要，他是mysql的核心数据库，负责存储数据库的用户、权限设置、关键字等mysql自己需要使用，控制和管理的信息。\n\ninformation_schema：这个数据库维护了数据库其他表的一些描述性信息，也称为元数据。比如，当前有哪\n\n\n些表，哪些视图，哪些触发器，哪些列等。\n\nperformation_schema：这个数据库用来存储mysql服务器运行过程中的一些状态信息，是做性能监控的。\n\n比如最近执行了什么sql语句，内存使用情况等\n\nsys：结合information_schema和performation_schema的数据，能更方便的了解mysql服务器的性能信\n\n息。\n\n2024.11.05\nwriteBy kaiven\n","slug":"mysql进阶","date":"2024-12-03T12:56:15.000Z","categories_index":"八股","tags_index":"mysql","author_index":"Ivan"},{"id":"76e26cf6d70a50daf8e75fb7d566964d","title":"面试官到底喜欢什么样的人？","content":"面试官到底喜欢什么样的人？在统一批次的面试中，可能就有好几百号人，无可否认的是，我们都喜欢优秀的人，都想和优秀的人共事，那怎么表现出我们的优秀呢？\n面试官喜欢爱学习、爱动脑、有技术广度和深度并且有实际经验的人。\n面试时间一般30分钟左右，我们必须通过自己的话术，去展现【爱学习、爱动脑、技术广度和深度以及实际经验】给他&#x2F;她看。\n建立正确的面试心态在这种大环境下，面试时间会被拉的很长，一面、二面、三面……面试的环节越多，那么你挂掉的概率也就越大，但没办法，就是这么卷。。。\n我们不需要唬住所有的面试官，因为在面试的过程中，面试官是用他最熟悉的东西去问题，有可能他熟悉的地方你并不是特别的熟悉，所以可能就会出现答得不好或者答不上来的情况，这很正常。。。\n我们做的事情，就是拿下我们能拿下的面试官。其实大部分面试官都是一边工作一边去面试的，所以八股的知识也就一般。比如说大厂的面试官，可能就会对原理性的东西进行深层次的拷打，如果你还只能回答出一些表面性的东西或者说大家都会说的一些东西，那么就不能体现出你的优势，面试挂掉的概率极大。当然，这些面试官也不是我们的菜。\n这小节最重要的一点就是：你对面试准备有多充分，就决定了你能找到什么样的工作！\n（不会说你随便糊弄了一下就能拿到一份很好的offer，而别人准备了大半年却颗粒无收，匹配机制嘛，找到符合自己目前口味的面试官，才是重点）\n如何把面试官拉倒坑里？上文也叙述过，其实大部分面试官的水平也一般，所以他其实也不知道自己该问些什么东西，如果你也没有对他进行相关的引导的话，他不就只能随便问了嘛。\n如何引导面试官？原理其实也比较简单：\n\n自我介绍阶段，突出描述自己擅长的部分\n回答问题的时候，为下一个问题做铺垫\n\n对于自我介绍，下文会进行详细的叙述。\n我们来说一下第二点，往往面试官问的问题都是层层递进的，会从你对某个问题的回答中捕风捉影，想好下一个要问你的问题。那是不是可以提前预判呢？把面试官引导上你准备好的问题链中去。\n还要一个比较重要的点就是拖延时间，或者说扩展描述，做到问一答三，因为你能回答出来的东西，那肯定是你提前准备好的，你给他暴露的信息越多，他问的点也就越多。但是，短短的半小时，他不可能什么都去问你，一定是从你的问答中挑他感兴趣的点，继续追问。你给他的选项，一定是你准备过的，每个点都这样的去扩展描述，一方面体现出你是一个【爱学习、爱动脑、有技术广度和深度并且有实际经验的人】，另一方面这样也将面试时间的主导权交到了自己的手上，你一直再说，面试官一直在听，问个两三个问题后，他可能就不会在问其他的了。\n（面试也要占用面试官的时间，谁不想休息啊，而且人家也有自己的事情要去做）\n面试的本质是什么？问题：面试是介绍你自己还是你的项目？\n答案：一定是介绍你自己。本质上来说，大多数的项目都是CRUD，没有什么特别的亮点。那和面试官对话的时候，就不要关注项目本身了，而是要去关注某个功能的实现，简单描述一下项目中的功能是怎么去实现的，然后重点叙述一下该方式存在什么样的不足，你会怎么去解决这个问题？\n场景：\n假设你现在的项目就是一个纯粹的后端管理系统，登录方式采用的是JavaWeb的Cookie + Session。\n针对该功能的叙述：\n由于我这个项目其实是一个学习项目，算不上真正意义上的生产级别的项目，所以登录功能只是采用了JavaWeb的 Cookie + Session 这样一种简单的形式。但是呢，这样做存在一些问题。比如说在分布式的环境中，多个JVM实例无法共享 Session ，就会出现明明用户已经登录了，但是后续的请求打在了其他机器上，导致用户会出现重复登录的情况，用户体验感不好。针对这个问题，需要我们去实现session的共享嘛，常见的实现方式就是将 Session 对象序列化放入 Redis 中进行共享，然后每一次的登录请求都去查询Redis。但是呢，这种方式也会出现一定的问题，。。。。。\n（你需要根据实际的场景去提前写好这些话术，你这一套话术下来，是不是达到了拖延时间的效果？你准备的这些话术中的内容的扩展问题你也回去准备的，是不是将面试官引入坑里面了？这一堆东西下来，是不是体现了你是一个【爱学习、爱动脑、有技术广度和深度并且有实际经验的人】？）\n公司招你肯定不是简单的让你做你熟悉的业务，而是想给你什么业务你都能够应对。\n你是一个厨师，业务需求就是食材，只会做几道菜的不叫做厨师。\n项目的亮点角度：架构、业务拆分、技术选型、大数据量处理\n如何写好简历避免已读不回？简历到底看什么？（校招）\n学历（至少全日制本科）\n专业排名（非科班成绩优异也可以，至少证明学习能力很强 &#x3D;&gt; 黑魔法）\n荣誉奖项（黑魔法，如果是大厂的话，斟酌一下，很有可能会让你提供证明材料）\n实习经历（大厂很加分，也可以黑魔法，但是不建议）\n\n学历这个东西确实没有办法，现在的大环境就是这样的，如果你是专科的同学，那么请先专升本，否则你可能会感慨世界的炎凉。（专升本你就写你本科的学历就好了，装傻）\n专业排名真的是最好造假的了，前20%？可以不？谁会去管呢？\n荣誉奖项也是，基本上不会查的，而且你也不会写什么特别高级的奖项，比如说 ACM金牌。。。（当然，如果是大厂的话，背景调查可能比较严格哦，请斟酌）\n实习经历也可以造假的，对，没错，只要你能唬住面试官。（大厂同样需要斟酌）\n如果是找实习的同学，那么肯定是没有实习经历这么一说的（除非你有过一段），那么重点在你的项目经历上。\n虽然说面试是介绍我们自己，但是前提是简历得入得了面试官的法眼，否则面试的资格都没有。\n一个项目的基本元素：\n项目名称（次要，但是不能太土）\n个人职责（在项目中负责什么，应届生次要）\n项目的线上地址（重要，增加项目的真实度）\n项目简介（重要，让面试官能够了解你这个项目的业务类型）\n项目的亮点（重要）\n\n对于项目简介，一定要言简意赅，主要是要让面试官知道你这个项目的大概业务有哪些。你做的那些项目基本上都能找到相似且开源的（大部分同学的项目也是根据这些开源的项目改的），所以没必要去过多的介绍。所以，这里你的项目名称最好是见名知意，比如说xx在线教育平台，面试官甚至都不用去读你的项目简介，就知道你这个项目的业务有哪些。\n对于项目的亮点，这个东西，得从实际的项目出发，体现出你的思考，还是那句话，可能项目真的没有什么亮点，就是一个很普通的CURD。但是，你可以通过引入一些其他的技术，去解决了什么问题，优化了什么东西。（无论是公司里面的大项目还是你的小项目，都会有bug和不足，不然为什么要持续的更新迭代，总会有问题的。）而且，你的亮点话术，要做到有针对性，而不是这些语句迁移到其他的项目上都能使用。\n(什么样的场景，通过什么方式，解决了什么问题或者优化了什么东西)\n如何做好自我介绍？（面试中最重要的环节）好的自我介绍有什么用？\n体现出你自己的价值和逻辑思维能力，快速让面试官对你感兴趣\n引导面试官对你进行提问\n\n什么是一份好的自我介绍？\n语言的流利程度，表达能力流畅的人，面试成功率会高很多。因为语言表达流利的话，证明了你的思维逻辑是流畅的，沟通能力是OK的。\n把自己相关的优势介绍清楚。\n能够讲清楚自己在项目中的职责，成果，并且有量化的数据支撑（人对数字是比较敏感的）。\n拉平和面试官之间的信息差，让面试官能够快速带入我们的项目中，能清楚他想要问的问题。\n\n很有必要去手写一份800字左右的自我介绍，在面试之前不断的打磨，这样才能在面试的时候流利的阐述。\n八股文怎么去准备怎么去回答？八股文这个东西是必须背的，你很难保证面试官不会去问，特别是对于应届生而言。\n八股文大概考什么？市面上的八股文这么多，动不动就几十万字的，没必要啊。这东西是有重点的：\n\njava基础：集合类、JVM、锁、多线程（这里会有实操，比如写代码实现三个线程交替打印“abc”）。\nJUC、AQS、线程池。线程池的核心参数，拒绝策略，队列有哪些。\nSpring、SpringMVC、SpringBoot：老演员了，问的也就那些东西（这里可以结合设计模式去讲，Spring中运用了大量的设计模式）。\nMySQL：。。。\nRedis：数据结构，一些机制。\n\n这里给鱼皮（B站搜索：程序员鱼皮）的面试鸭刷题网站打一个广告：https://www.mianshiya.com/\n这是一个专门为程序员提供的在线刷题平台，涵盖从IT各大学科的面试经典八股文，支持网页端和小程序端，目前（2024.10.20）永久会员只需要 129 元。\n（不要求每一道八股文你都能回答得很好，但是你必须有一两道八股文讲得非常出彩，结合自己的理解和实际的业务场景）\n总结总的来说，面试的宗旨就是：通过和面试官的沟通，去展示你的优秀，你是一个爱学习、爱动脑、有技术广度和深度并且有实际经验的人。\n","slug":"面试","date":"2024-12-03T12:35:49.000Z","categories_index":"","tags_index":"面试","author_index":"Ivan"},{"id":"e53aef447e609f6346cd88030af73ac8","title":"JDK8有哪些新特性？","content":"JDK8较为重要和平日里经常被问的特性如下：\n1)用元空间替代了永久代因为JDK8要把JRockit虚拟机和Hotspot虚拟机融合，而JRockit没有永久代，所以把Hotspot永久代给去了（本质也是永久代回收效率太低)\n2)引入了Lambda表达式Lambda表达式是Java8中引入的一个重要特性，它允许我们以更简洁和灵活的方式编写代码。Lambda表达式可以看作是匿名函数，它没有方法名，但可以包含参数和函数体。Lambda表达式可以用于简化代码，提高代码的可读性和可维护性。Lambda表达式的基本语法如下：\n123(parameters) -&gt; expression或(parameters) -&gt; &#123; statements; &#125;\n其中，parameters是参数列表，expression是函数体，statements是函数体的多条语句。Lambda表达式可以用于替换匿名内部类，使代码更加简洁和易读。例如，我们可以使用Lambda表达式来简化以下代码：\n1234567List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);Collections.sort(list, new Comparator&lt;String&gt;() &#123;    @Override    public int compare(String s1, String s2) &#123;        return s1.compareTo(s2);    &#125;&#125;);\n使用Lambda表达式可以简化为：\n12List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);Collections.sort(list, (s1, s2) -&gt; s1.compareTo(s2));\nLambda表达式还可以用于简化其他场景，例如线程的创建、集合的遍历等。\n3)引入了日期类、接口默认方法、静态方法Java8引入了新的日期和时间APl(位于java.time包中)，它们更加简洁和易于使用，解决了旧版日期时间AP!的许多问题。例如DateCalendar都是可变类且线程不安全。而新的日期类都是不可变的，一旦创建就不能修改，这样可以避免意外的修改，提升代码的安全性和可维护性。\n123LocalDate date =LocalDate.now();LocalTime time =LocalTime.now();LocalDateTime dateTime =LocalDateTime.now()\nDate本身不包含时区信息，必须使用Calendar类来处理时区，但使用起来非常复杂且容易出错。新API提供了专门的时区类（如ZonedDateTime,OffsetDateTimeZoneId等)，简化了时区处理，并且这些类的方法更加直观和易用。\n接口默认方法、静态默认方法允许在接口中定义方法的默认实现，这样接口的实现类不需要再实现这些方法。之所以提供静态方法，是为了将相关的方法内聚在接口中，而不必创建新的对象。\n4)新增Stream流式接口Stream API是Java8中引入的一个新特性，它提供了一种新的方式来处理数据集合。Stream API允许我们以声明式的方式处理数据，避免了传统的循环和条件语句，使代码更加简洁和易读。Stream API的基本语法如下：\n1Stream&lt;T&gt; stream = collection.stream();\n其中，collection是一个数据集合，可以是List、Set、Map等。stream是一个Stream对象，它表示一个数据流，可以通过一系列的操作来处理数据。Stream API提供了一系列的操作，包括过滤、映射、排序、聚合等。这些操作可以链式调用，使代码更加简洁和易读。例如，我们可以使用Stream API来过滤一个List中的偶数，并计算它们的和：\n123456List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6);int sum = list.stream()    .filter(n -&gt; n % 2 == 0)    .mapToInt(Integer::intValue)    .sum();System.out.println(sum); // 输出：12\n在上面的代码中，我们首先将List转换为一个Stream对象，然后使用filter操作过滤出偶数，再使用mapToInt操作将Stream中的元素转换为int类型，最后使用sum操作计算它们的和。整个操作链式调用，使代码更加简洁和易读。Stream API还提供了一些其他的操作，例如reduce、collect、forEach等，可以满足各种数据处理的需求。通过使用Stream API，我们可以更加高效地处理数据集合，使代码更加简洁和易读。\n5)引入Optional类Optional是Java8引入的一个容器类，用于表示可能为空的值。它通过提供更为清晰的AP!,来减少程序中出现nu11的情况，避免NullPointerException(空指针异常)的发生。Optional可以包含一个值，也可以为空，从而表示“值存在”或“值不存在”这两种状态。作用：\n\n减少NullPointerException:通过Optional提供的操作方法，避免 直接使用 null进行空值检查，从而降低空指针异常的风险。\n提高代码可读性：Optional 提供了一套简洁的API,例如isPresent() ifPresent()和orElse()，可以让代码更具表达性，清晰地展示处理空值的逻辑1234Optional&lt;String&gt; optional = Optional.of(&quot;Hello&quot;);if (optional.isPresent()) &#123;    System.out.println(optional.get());&#125;\n\n6)新增了CompletableFuture、StampedLock等并发实现类。CompletableFuture提供了一个新的异步编程模型，简化了异步任务的编写和管理。StampedLock是一个新的读写锁实现，它提供了一种新的方式来处理读写锁，避免了复杂的锁机制和锁竞争。\n如果你对HashMap、ConcurrentHashMap面试题有准备的话，这时候也可以抛出来，引导面试官来询问。比如：Java8修改了HashMap和ConcurrentHashMap的实现。\n\n","slug":"java基础/八股","date":"2024-11-13T04:14:48.000Z","categories_index":"八股","tags_index":"java","author_index":"Ivan"},{"id":"bc567916c4dc0d8169bd26d18e348d36","title":"test","content":"欢迎使用 Markdown 笔记这是首次使用 Markdown 笔记 自动生成的内容，包含 Markdown 语法和应用介绍\n表格 &amp; 文本样式\n\n\n样式\n语法\n示例\n\n\n\n加粗\n前后 ** 或  __\n加粗1 加粗2\n\n\n斜体\n前后 * 或  _\n斜体1 斜体2\n\n\n删除线\n前后 ~~\n删除线\n\n\n内联代码\n前后 &#96;\ncode\n\n\n下划线\n前 &lt;u&gt;  后 &lt;/u&gt;\n下划线\n\n\n高亮\n前后 ==\n&#x3D;&#x3D;高亮文本&#x3D;&#x3D;\n\n\n引用\n\n\n\n\n\n\n\n\nuTools 新一代效率工具平台\n链接鼠标右击 或 Ctrl 键 + 点击 系统默认浏览器打开链接\nuTools 官网  猿料社区\n图片拖放图片文件、粘贴截图可直接将图片源数据存储到笔记中\n\n图片可拖动为文件到任意窗口使用\n无序列表\n项目\n项目 1\n项目 A\n项目 B\n\n\n项目 2\n\n\n\n有序列表\n项目 1\n项目 A\n项目 B\n\n\n项目 2\n\n任务列表\n A 计划\n A1 计划\n A2 计划\n\n\n B 计划\n\n代码块代码块支持 168 种编程语言\n12345678910111213141516// javascript 冒泡排序function bubbleSort(array) &#123;  let swapped = true;  do &#123;    swapped = false;    for (let j = 0; j &lt; array.length; j++) &#123;      if (array[j] &gt; array[j + 1]) &#123;        let temp = array[j];        array[j] = array[j + 1];        array[j + 1] = temp;        swapped = true;      &#125;    &#125;  &#125; while (swapped);  return array;&#125;\n\nKaTeX 数学公式内联公式质能方程 $E&#x3D;mc^2$\n公式块$$\\displaystyle \\left( \\sum_{k&#x3D;1}^n a_k b_k \\right)^2 \\leq \\left( \\sum_{k&#x3D;1}^n a_k^2 \\right) \\left( \\sum_{k&#x3D;1}^n b_k^2 \\right)$$\n应用介绍特性\n极佳的 Markdown 编辑体验，实时预览、存储\n与传统富文本编辑方式结合，支持通用快捷键\n导出 MD、html、PDF、图片\n可快速搜索全部笔记(内容和标题)\n笔记名称可设置为 uTools 关键字，外部快速打开笔记\n\n使用技巧\n侧边栏文件夹或笔记，拖拽调整位置，鼠标右击 显示操作菜单\n当焦点未在编辑器，键盘上下方向键、 Tab 键切换笔记\n当焦点未在编辑器，Enter 进入编辑\nCommand/Ctrl+F 焦点切换到搜索\n编辑器中列表编辑时，按 Tab 变子项，Shift + Tab 恢复\n\n","slug":"test","date":"2024-11-09T02:38:44.000Z","categories_index":"","tags_index":"test","author_index":"Ivan"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post1$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server1$ hexo server\n\nMore info: Server\nGenerate static files1$ hexo generate\n\nMore info: Generating\nDeploy to remote sites1$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2024-11-07T16:24:53.067Z","categories_index":"","tags_index":"","author_index":"Ivan"}]