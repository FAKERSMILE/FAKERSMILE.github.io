[{"id":"6245dd4deb5ec4d8e16e80935a8a30db","title":"线程基础","content":"线程状态的转换新建（New）创建后未启动。\n可运行（Runable）可能正在运行，也可能等待CPU时间片。\n阻塞（Blocking）等待获取一个排它锁，如果其他线程释放了锁，就会结束该状态。\n无限期等待（Waiting）等待其他线程显式的唤醒，否则不会被分配时间片。\n限期等待（Timed Waiting）无需等待其他线程显式地唤醒，在一定时间之后被系统自动唤醒。\n死亡（Terminated）可以是线程结束任务之后自己结束，或产生异常而结束。\n线程使用方式有三种使用线程的方法:\n\n实现 Runnable 接口；\n实现 Callable 接口；\n继承 Thread 类。\n\n实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。\n1.实现 Runnable 接口123456789101112131415class MyRunable implements Runnable &#123;    @Override    public void run() &#123;        System.out.println(&quot;hello world!&quot;);    &#125;    public static void main(String[] args) throws InterruptedException &#123;        MyRunable myRunable = new MyRunable();        Thread thread = new Thread(myRunable);        thread.start();        thread.join();    &#125;    &#125;\n\n2. 实现 Callable 接口123456789101112131415class MyCallable implements Callable&lt;String&gt; &#123;    @Override    public String call() throws Exception &#123;        return &quot;Hello World!&quot;;    &#125;    public static void main(String[] args) throws InterruptedException, ExecutionException &#123;        MyCallable myCallable = new MyCallable();        FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(myCallable);        Thread thread = new Thread(futureTask);        thread.start();        System.out.println(futureTask.get());    &#125;&#125;\n\n3. 继承Thread类1234567891011121314class MyThread extends Thread &#123;    @Override    public void run() &#123;        System.out.println(&quot;Hello World!&quot;);    &#125;    public static void main(String[] args) throws InterruptedException &#123;        MyThread myThread = new MyThread();        myThread.start();        myThread.join();    &#125;    &#125;\n\n实现接口 VS 继承 Thread 类实现接口会更好一些，因为:\n\nJava 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；\n类可能只要求可执行就行，继承整个 Thread 类开销过大。\n\n基础线程机制ExecutorExecutor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。\n主要有三种 Executor:\n\nCachedThreadPool: 一个任务创建一个线程；\nFixedThreadPool: 所有任务只能使用固定大小的线程；\nSingleThreadExecutor: 相当于大小为 1 的 FixedThreadPool。\n\n123456789101112public class Solution &#123;    public static void main(String[] args) &#123;        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();        for(int i=0;i&lt;5;i++)&#123;            final int I = i;            newCachedThreadPool.execute(() -&gt; &#123;                System.out.println(&quot;hello world! &quot;+I);            &#125;);        &#125;        newCachedThreadPool.shutdown();    &#125;&#125;\n\nDaemon守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。\n当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。\nmain() 属于非守护线程。\n使用 setDaemon() 方法将一个线程设置为守护线程。\n12345678public class Solution &#123;    public static void main(String[] args) &#123;        Thread thread = new Thread(() -&gt; &#123;            System.out.println(&quot;hello world!&quot;);        &#125;);        thread.setDaemon(true);    &#125;&#125;\n\nsleep()Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。\nsleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。\n1234public static void main(String[] args) throws InterruptedException &#123;    Thread.sleep(3000);    System.out.println(&quot;hello world!&quot;);&#125;\n\nyield()对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。\n12345678910111213141516public static void main(String[] args) throws InterruptedException &#123;    Thread thread_01 = new Thread(() -&gt; &#123;        System.out.println(1);        Thread.yield();        System.out.println(3);    &#125;);    Thread thread_02 = new Thread(() -&gt; &#123;        System.out.println(2);        Thread.yield();        System.out.println(4);    &#125;);    thread_01.start();    thread_02.start();    thread_01.join();    thread_02.join();&#125;\n\n线程中断一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。\nInterruptedException通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I&#x2F;O 阻塞和 synchronized 锁阻塞。\n1234567891011121314public static void main(String[] args) throws InterruptedException &#123;    Thread thread = new Thread(() -&gt; &#123;        try &#123;            Thread.sleep(3000);            System.out.println(&quot;hello&quot;);        &#125; catch (InterruptedException e) &#123;            System.out.println(&quot;我被干掉了&quot;);        &#125;    &#125;);    thread.start();    Thread.sleep(1000);    thread.interrupt();    thread.join();&#125;\n\ninterrupted()如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。\n但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。\n123456789101112131415161718class MyThread extends Thread &#123;    @Override    public void run() &#123;        while (!interrupted()) &#123;            System.out.println(&quot;没有被打断&quot;);        &#125;        System.out.println(&quot;完蛋了！&quot;);    &#125;        public static void main(String[] args) throws InterruptedException &#123;        MyThread myThread = new MyThread();        myThread.start();        Thread.sleep(1000);        myThread.interrupt();        myThread.join();    &#125;&#125;\n\nExecutor 的中断操作调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。\n123456789101112public static void main(String[] args) throws InterruptedException &#123;    ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();    newCachedThreadPool.execute(() -&gt; &#123;        try &#123;            Thread.sleep(3000);            System.out.println(&quot;hello world&quot;);        &#125; catch (InterruptedException e) &#123;            System.out.println(&quot;被中断喽&quot;);        &#125;    &#125;);    newCachedThreadPool.shutdownNow();&#125;\n\n如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。\n1234567891011public static void main(String[] args) throws InterruptedException, ExecutionException &#123;    ExecutorService executorService = Executors.newCachedThreadPool();    Future&lt;Object&gt; submit = executorService.submit(() -&gt; &#123;        for(int i=0;i&lt;100000000;i++)&#123;            System.out.println(i);        &#125;        return null;    &#125;);    submit.cancel(true);    System.out.println(&quot;hello&quot;);&#125;\n\n线程互斥同步Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。\nsynchronized1. 同步一个代码块1234567891011121314151617181920class Test &#123;    public void func() &#123;        synchronized (this) &#123;            for (int i = 0; i &lt; 10; i++) &#123;                System.out.println(i);            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        Test test = new Test();        ExecutorService executorService = Executors.newCachedThreadPool();        executorService.execute(() -&gt; &#123;            test.func();        &#125;);        executorService.execute(() -&gt; &#123;            test.func();        &#125;);        executorService.shutdown();    &#125;&#125;\n\n它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步：\n123456789101112131415161718192021class Test &#123;    public void func() &#123;        synchronized (this) &#123;            for (int i = 0; i &lt; 10; i++) &#123;                System.out.println(i);            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        Test test = new Test();        Test test2 = new Test();        ExecutorService executorService = Executors.newCachedThreadPool();        executorService.execute(() -&gt; &#123;            test.func();        &#125;);        executorService.execute(() -&gt; &#123;            test2.func();        &#125;);        executorService.shutdown();    &#125;&#125;\n\n2. 同步一个方法1234567891011121314151617181920class Test &#123;    public synchronized void func() &#123;        for (int i = 0; i &lt; 10; i++) &#123;            System.out.println(i);        &#125;    &#125;    public static void main(String[] args) &#123;        Test test = new Test();        Test test2 = new Test();        ExecutorService executorService = Executors.newCachedThreadPool();        executorService.execute(() -&gt; &#123;            test.func();        &#125;);        executorService.execute(() -&gt; &#123;            test2.func();        &#125;);        executorService.shutdown();    &#125;&#125;\n\n它和同步代码块一样，作用于同一个对象。\n3. 同步一个类12345678910111213141516171819202122class Test &#123;    public void func() &#123;        synchronized (Test.class) &#123;            for (int i = 0; i &lt; 10; i++) &#123;                System.out.println(i);            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        Test test = new Test();        Test test2 = new Test();        ExecutorService executorService = Executors.newCachedThreadPool();        executorService.execute(() -&gt; &#123;            test.func();        &#125;);        executorService.execute(() -&gt; &#123;            test2.func();        &#125;);        executorService.shutdown();    &#125;&#125;\n\n作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。\n4. 同步一个静态方法123456789101112131415161718class Test &#123;    public static synchronized void func() &#123;        for (int i = 0; i &lt; 10; i++) &#123;            System.out.println(i);        &#125;    &#125;    public static void main(String[] args) &#123;        ExecutorService executorService = Executors.newCachedThreadPool();        executorService.execute(() -&gt; &#123;            Test.func();        &#125;);        executorService.execute(() -&gt; &#123;            Test.func();        &#125;);        executorService.shutdown();    &#125;&#125;\n\n作用于整个类。\nReentrantLockReentrantLock 是 java.util.concurrent(J.U.C)包中的锁。\n12345678910111213141516171819202122232425class Test &#123;    private Lock lock;    &#123;        lock = new ReentrantLock();    &#125;    public void func() &#123;        lock.lock();        try &#123;            for(int i=0;i&lt;10;i++)&#123;                System.out.println(i);            &#125;        &#125; finally &#123;            lock.unlock();        &#125;    &#125;    public static void main(String[] args) &#123;        Test test = new Test();        ExecutorService executorService = Executors.newCachedThreadPool();        executorService.execute(() -&gt; test.func());        executorService.execute(() -&gt; test.func());        executorService.shutdown();    &#125;&#125;\n\n比较1. 锁的实现synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。\n2. 性能新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。\n3. 等待可中断当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。\nReentrantLock 可中断，而 synchronized 不行。\n4. 公平锁公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。\nsynchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。\n5. 锁绑定多个条件一个 ReentrantLock 可以同时绑定多个 Condition 对象。\n使用选择除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。\n线程之间的协作当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。\njoin()在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。\n（这里就不掩饰了，经常用的）\nwait() notify() notifyAll()调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。\n它们都属于 Object 的一部分，而不属于 Thread。\n只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateExeception。\n使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。\n12345678910111213141516171819202122232425262728class Test &#123;    public synchronized void before() &#123;        try &#123;            Thread.sleep(1500);        &#125; catch (InterruptedException e) &#123;            System.out.println(&quot;被打断lou&quot;);        &#125;        System.out.println(&quot;before&quot;);        notifyAll();    &#125;    public synchronized void after() &#123;        try &#123;            wait();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(&quot;after&quot;);    &#125;    public static void main(String[] args) &#123;        Test test = new Test();        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();        newCachedThreadPool.execute(() -&gt; test.after());        newCachedThreadPool.execute(() -&gt; test.before());        newCachedThreadPool.shutdown();    &#125;&#125;\n\n（以上代码有死锁的风险，如果是after函数先执行，那没有问题；如果是before先执行，就证明了after没有拿到锁，等before释放锁之后，after拿到锁，然后进入休眠状态，然后也没有人唤醒它）\nwait() 和 sleep() 的区别\nwait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法\nwait() 会释放锁，sleep() 不会\n\nawait() signal() signalAll()java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。\n123456789101112131415161718192021222324252627282930313233343536373839404142class Test &#123;    private Lock lock;    private Condition condition;    &#123;        lock = new ReentrantLock();        condition = lock.newCondition();    &#125;    public void before() &#123;        lock.lock();        try &#123;            Thread.sleep(1500);            System.out.println(&quot;before&quot;);        &#125; catch (InterruptedException e) &#123;            System.out.println(&quot;被打断lou&quot;);        &#125;        finally&#123;            condition.signalAll();            lock.unlock();        &#125;    &#125;    public void after() &#123;        lock.lock();        try &#123;            condition.await();            System.out.println(&quot;after&quot;);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        finally&#123;            lock.unlock();        &#125;    &#125;    public static void main(String[] args) &#123;        Test test = new Test();        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();        newCachedThreadPool.execute(() -&gt; test.after());        newCachedThreadPool.execute(() -&gt; test.before());        newCachedThreadPool.shutdown();    &#125;&#125;\n\n（和上文一下，也是会有死锁的风险，虽然我没有测出来，但是理论上来说，是这样的）\n\n2024.11.03\nwriteBy kaiven\n","slug":"并发/线程基础","date":"2024-12-03T14:40:50.000Z","categories_index":"八股","tags_index":"java,并发框架","author_index":"Ivan"},{"id":"f5276a6470bcf00967ce9121d16c19cd","title":"并发基础","content":"为什么需要多线程？早期的单CPU时代，CPU制作厂商沉迷于提高单个核心的计算能力。但是随着时间的推移，提高单核心的计算能力越来越困难了。于是乎，堆核心成为了快速提高CPU计算能力的另一种途径。这样一来，多个任务就可以并行的跑在CPU的不同核心上。\n一个程序只是一个单线程的应用的话，无法利用现代多核心CPU的优势。所以，学习并发编程可以提高我们程序的运行效率。\n线程安全示例多线程编程虽然可以提高我们程序的运行效率，但是同样也面临着线程安全或者说并发安全问题：\n12345678910111213141516171819202122232425262728public class ThreadUnsafeExample &#123;    private int cnt = 0;    public void add() &#123;        cnt++;    &#125;    public int get() &#123;        return cnt;    &#125;    public static void main(String[] args) throws InterruptedException &#123;        final int threadSize = 1000;        ThreadUnsafeExample example = new ThreadUnsafeExample();        final CountDownLatch countDownLatch = new CountDownLatch(threadSize);        ExecutorService executorService = Executors.newCachedThreadPool();        for (int i = 0; i &lt; threadSize; i++) &#123;            executorService.execute(() -&gt; &#123;                example.add();                countDownLatch.countDown();            &#125;);        &#125;        countDownLatch.await();        executorService.shutdown();        System.out.println(example.get());    &#125;&#125;\n\n运行的结果总是小于1000。\n并发问题发生的三要素1. 可见性：CPU缓存引起的\nCPU直接与自己的L1级缓存进行交互，L1级缓存的数据来自L2，L2中的数据来自L3，L3中的数据来自内存。\n假设线程A和线程B并发的执行这段代码的话，线程A在CPU1上执行，线程B在CPU2上执行，会有以下这种情况：\n线程A将i的值从内存载入CPU1对应的缓存中，此时i的值为0；\n线程B将i的值从内存载入CPU2对应的缓存中，此时i的值为0；\n线程A执行了自增操作，CPU1缓存中的i的值为1；\n线程B执行了自增操作，CPU2缓存中的i的值为1；\n线程A将CPU1缓存i的值写入内存，内存中i的值是1；\n线程B将CPU2缓存i的值写入内存，内存中i的值是1。\n其中一次操作的值将另一次操作的值给覆盖了。\n本质问题就是一个线程在CPU缓存中修改了共享的值，另一个线程并不知道。\n2. 原子性：分时复用引起的对于【i++】操作来说，它对应三条指令：\n\n将变量i从内存中读到寄存器\n将寄存器中i的值+1\n写回内存（由于缓存机制，也可能是缓存，而不是内存）\n\n我们都知道，CPU运作机制就是执行一条又一条的指令。无论是Linux、windows还是Max OS，它们都属于分时操作系统。CPU并发的运行着N多个程序。CPU有一个时钟硬件设备，定期向CPU发送时钟中断信号，CPU收到信号后，操作系统介入，调度下一个程序运行。\n所以，就算是在只有一个CPU的机器上，运行多线程的程序，由于分时复用机制，一个操作如果由多条指令集合构成，那么也会造成并发安全问题。\n3. 有序性：重排序引起1234int i = 0;              boolean flag = false;i = 1;                //语句1  flag = true;          //语句2\n\n从我们开发的角度来看，语句1应该在语句2之前执行的，那事实真的是这样嘛？\n在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：\n\n编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。\n指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。\n内存系统的重排序。由于处理器使用缓存和读 &#x2F; 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。\n\n从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：\n\n上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。\nJava是怎么解决并发问题的？JMM（Java内存模型）。\n理解的第一个维度：核心知识点\nJMM本质上可以理解为，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括：\n\nvolatile、synchronized 和 final 三个关键字\nHappens-Before 规则\n\n理解的第二个维度：可见性，有序性，原子性\n\n原子性\n\n在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。\n请分析以下哪些操作是原子性操作：\n1234x = 10;        //语句1: 直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中y = x;         //语句2: 包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。x++;           //语句3： x++包括3个操作：读取x的值，进行加1操作，写入新的值。x = x + 1;     //语句4： 同语句3\n\n只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。\nJava内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。\n\n可见性\n\nJava提供了volatile关键字来保证可见性。\n当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。\n而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。\n另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。\n\n有序性\n\n在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。当然JMM是通过Happens-Before 规则来保证有序性的。\nHappens-Before 规则上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。\n1. 单一线程原则在一个线程内，在程序前面的操作先行发生于后面的操作。\n2. 管程锁定规则一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。\n3. volatile变量规则对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。\n4. 线程启动规则Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。\n5. 线程加入规则Thread 对象的结束先行发生于 join() 方法返回。\n6. 线程中断规则对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。\n7. 对象终结规则一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始。\n8. 传递性如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。\n线程安全一个类在可以被多个线程安全调用时就是线程安全的。\n线程安全不是一个非真即假的命题，可以将共享数据按照安全程度的强弱顺序分成以下五类: 不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。\n1. 不可变不可变(Immutable)的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。\n多线程环境下，应当尽量使对象成为不可变，来满足线程安全。\n不可变的类型:\n\nfinal 关键字修饰的基本数据类型\nString\n枚举类型\nNumber 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。\n\n2. 相对线程安全相对线程安全需要保证对这个对象单独的操作是线程安全的，在调用的时候不需要做额外的保障措施。但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。\n在 Java 语言中，大部分的线程安全类都属于这种类型，例如 Vector、HashTable、Collections 的 synchronizedCollection() 方法包装的集合等。\n3. 线程兼容线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。Java API 中大部分的类都是属于线程兼容的，如与前面的 Vector 和 HashTable 相对应的集合类 ArrayList 和 HashMap 等。\n4. 线程对立线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于 Java 语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。\n线程安全的实现方法1. 互斥同步synchronized 和 ReentrantLock。\n2. 非阻塞同步互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。\n互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁(这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁)、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。\n（一）CAS随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略: 先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施(不断地重试，直到成功为止)。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。\n乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是: 比较并交换(Compare-and-Swap，CAS)。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。\n（二）ABA如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。\nJ.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。\n3. 无同步方案要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。\n（一）栈封闭多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。\n（二）线程本地存储（Thread Local Storage）如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。\n符合这种特点的应用并不少见，大部分使用消费队列的架构模式(如“生产者-消费者”模式)都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”(Thread-per-Request)的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。\n可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。\nThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。\n在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。\n（三）可重入代码这种代码也叫做纯代码(Pure Code)，可以在代码执行的任何时刻中断它，转而去执行另外一段代码(包括递归调用它本身)，而在控制权返回后，原来的程序不会出现任何错误。\n可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。\n\n2024.11.02\nwriteBy kaiven\n","slug":"并发/并发基础","date":"2024-12-03T14:35:07.000Z","categories_index":"八股","tags_index":"java,并发框架,并发基础","author_index":"Ivan"},{"id":"293c17b4d2a4292133cc4d1ffd7f8725","title":"计算机网络","content":"OSI模型、TCP&#x2F;IP模型、五层模型 ？\n刚开始学习的小伙伴一定会被这些搞懵逼的，傻傻分不清哦。\n这个所谓的七层模型，实际上那帮搞学术的弄出来的，但是很可惜，并没有流行开了，主要原因就是搭建这样的体系架构网络很复杂。（了解一下就行了）\nTCP&#x2F;IP网络模型是目前最流行的网络协议模型。在我们的实际生活中被广泛的使用。\n最后这个五层协议，主要是为了教学需要而设计的，了解一下即可，但是我还是会简单介绍的。\nTCP&#x2F;IP模型每一层的作用？\n应用层\n这是我们大部分开发最为熟悉的一层，应用层对于我们来说，是相对可控的，因为传输层及以下是操作系统的网络协议栈接管，用户态的我怎么敢触碰内核态的你。\n你所熟知的各种协议，比如 HTTP、HTTPS、DNS等，都属于应用层协议。\n\n传输层\n这一层的协议就少了，就两个：TCP和UDP\n之后的文章会做详细的讲解，这里简单说一下两个协议的特点。\nTCP提供面向连接的、可靠的传输服务；UDP提供无连接、尽最大努力交付的传输服务。\n\n网络层\nIP协议起了至关重要的作用，想一下，现在的网络体系，离得开IP嘛？\n\n网络接口层\n对于上层的协议来说，这一层就是数据的发送层，实际上，并不是，后面会说。\n\n\n数据发送的大致流程？\n应用层将需要发送的数据交给传输层，传输层拿到后加上TCP头部，向下交给网络层，网络层又加上IP头部，交给网络接口层，加上帧头和帧尾，然后发出去。\n（上层协议委托的数据对于下层协议来说是透明的，比如说对于网络层来说，它是不知道有TCP头部和应用数据之分的，只会认为是一个整体）\n网络接口层简介物理层没有什么好说的，这里主要说一下数据链路层。\n数据链路层的协议很多，但是他们都面临着三个问题：封装成帧、透明传输和差错检测\n\n封装成帧\n数据链路层会将网络层交付的数据添加首部和尾部，这就封装成了一个帧，首部和尾部就标识了该帧的开始与结束。\n帧长 &#x3D; 首部长度 + 数据段长度 + 尾部长度。\nMTU（最大传输单元） —— 数据部分长度限制，看图：\n\n帧定界符：就是表示一个帧的开始与结束的标志。=&gt; 有个场景，如果发送端发送的时候，突然“掉线”了，那么接收端就永远不会收到帧结束符。等到下一个帧的帧开始符到达时，接收端就知道上一个帧不完整了，就会把它丢弃。\n\n\n透明传输\n这个问题与数据链路层的机制有关系。数据链路层奉行一种“来者不拒”的理念，“只要给我的，我都要”，对于帧的隔离，识别比特流中的定界符就好了。也就是说，数据链路层并不知道你传的内容是些什么玩意儿，它只负责去“截断”（找到帧开始符合帧结束符）。所以，什么样的比特组合都能通过该层。对于这些比特流而言，数据链路层就好像不存在一样。\n但是这样会引发一个什么样的问题呢？对于文本数据还好说，里面的内容都是键盘上录入进去的，帧开始符和帧结束符找两个用户录入不进去的字符就好了。可是，如果是一些音视频或者其他的比特流，很难保证里面其中一个字节的比特组合不会与帧开始符和帧结束符不同（毕竟对于数据链路层来说，它唯一能做的就是扫描字节，找到帧定界符）。\n如果数据段中出现了“帧开始”符，那么前面的数据就会被丢弃；如果数据段中出现了“帧结束符”，那么后面的数据就会被丢弃。\n为了解决该问题，发送端在数据链路层封装成帧的时候，如果数据内容里面出现了帧定界符，那么就在对应的字节前面添加一个转义字符，如果转义字符也重复了，那么就再添加一个转移字符。&#x3D;&gt; 该过程称作字节填充或者字节填充。\n\n\n差错检测\n比特差错 &#x3D;&gt; 世界上没有完美无暇的东西，总会出问题的。数据在传输的过程中，可能会出现0变成1，或者1变成0的情况。\n泼出去的水无法改变，那就只能在收到的时候，利用各种手段去检测数据是否完整了。\n在数据链路层，广泛采用循环冗余检验CRC检错技术 &#x3D;&gt; 其实就是数据段后添加一个冗余码（帧检验序列FCS） &#x3D;&gt; 发送端根据一定的算法生成，接收端根据一定的算法检测（别问，问就是了解就行了，难道我还要把算法的逻辑说出来嘛，呜呜呜）。\n值得一提的是，FCS的生成和CRC的运用，都是在硬件层面进行的，非常之快。\n数据链路层只能以一种无限接近1的概率向上抛出帧，保障帧无差错。\n但是依然会出现这三个问题：帧丢失、帧失序、帧重复 &#x3D;&gt; 不能提供可靠的传输服务\n\n\n关于MAC地址相信大家都听过一个词，叫做“MAC地址”，到底是一个什么东西呢？ 它就是一个硬件地址，网卡（或者说网络适配器）厂商在生产的时候，写死在硬件里面的，全球唯一的。 网络适配器有过滤功能。每收到一个MAC帧，先用硬件检测一下MAC帧中的硬件地址，看一下是不是发往本站的。是，则收下；不是，则丢弃。 （所以，MAC地址也叫做硬件地址）\n\n2024.10.22\nwriteBy kaiven\n","slug":"计网/计算机网络","date":"2024-12-03T14:23:01.000Z","categories_index":"八股","tags_index":"计算机网络","author_index":"Ivan"},{"id":"282ca770e6df8001dbda062738b2a12a","title":"java面向对象","content":"Java给我的感觉就是一个有一个的类，毕竟类是其代码的基本组织单元。\n对象是类实例化的结果，所以对象有时也被称为实例，从类到对象的过程称为实例化。\n面向对象的三大特点：封装、继承、多态\n封装学术上的东西就不讲了，从开发的视角阐述这个概念。\n通常我们都会将字段的可访问性设置为private，然后通过Getter和Setter方法对外提供查看和设置字段值的接口。\n（我习惯于称作字段，貌似大家都喜欢叫属性）\n上代码：\n12345678910111213141516171819202122public class Person &#123;    private String name;    private int age;        public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;&#125;\n\n这是一个Person类，对人这个实体的抽象。类中有两个字段：name和age，代表人的姓名和年龄。从代码层面上看，Person类外面的任何方法都不能直接访问这两个字段，只能通过类中提供的方法进行访问和修改。\n这就是封装！！！\n至于说有什么有点，AI来吧：\n面向对象编程（OOP）中的封装是一个核心概念，它提供了以下优点：\n\n数据隐藏：封装允许对象隐藏其内部状态和复杂性，只暴露一个清晰的接口给外部世界。这降低了代码的复杂性，并提高了代码的可理解性。\n\n实现细节的保护：通过隐藏内部实现，封装防止了外部代码直接访问对象的内部数据，从而防止了可能的错误或不当的修改。\n\n接口与实现的分离：封装使得对象的内部实现可以独立于其接口进行修改，只要接口保持不变，外部代码就不需要修改。\n\n提高代码的可维护性：由于对象的内部实现被隐藏，修改这些实现不会影响依赖于该对象的代码，这使得维护和更新变得更加容易。\n\n增强代码的安全性：封装可以防止外部代码访问或修改对象的私有成员，这有助于防止潜在的安全风险。\n\n促进重用：封装提供了一个清晰的接口，使得对象可以在不同的程序和环境中重用，而不需要了解其内部工作机制。\n\n减少耦合：封装减少了类与类之间的直接依赖，从而降低了系统中各部分之间的耦合度。\n\n提高代码的可测试性：封装使得单元测试可以针对特定的对象进行，而不需要考虑整个系统的复杂性。\n\n支持多态：封装与多态一起工作，允许基于接口而非实现编程，这使得使用基类指针或引用调用派生类的方法成为可能。\n\n封装继承：在支持继承的语言中，封装允许子类继承父类的属性和方法，同时可以扩展或修改这些属性和方法，而不需要更改外部代码。\n\n促进模块化设计：封装鼓励将系统分解成模块或类，每个模块或类都有自己的职责，这有助于构建更大规模的系统。\n\n提高代码的组织性：封装要求将相关的数据和操作这些数据的方法组合在一起，这有助于提高代码的组织性和结构化。\n\n\n总的来说，封装是面向对象设计的一个关键原则，它有助于创建更健壮、更灵活和更易于维护的软件。\n随便扫一眼就行了。。。\n继承这个没有什么好说的，子类可以继承父类非private的字段和方法。\n在实际开发中，我们往往使用父类变量去引用子类对象，除非想调用子类对象的扩展的方法。\n1234567891011121314151617class Student extends Person &#123;    public Student(String name, int age) &#123;        super(name, age);    &#125;    public void sayHello()&#123;        System.out.println(&quot;Hello Java&quot;);    &#125;&#125;class Test &#123;    public static void main(String[] args) &#123;        Person person = new Student(&quot;kaiven&quot;, 20);        System.out.println(person.getName() + person.getAge());    &#125;&#125;\n\n由于Student继承了Person，所以Person类型的变量可以引用Student类型的对象。\n当然，考虑以下语句，能够正常运行：\n如果你尝试了，会发现不行。其实是可以的，因为引用的是Student对象嘛。但是，通不过编译器，因为Person类中没有sayHello这个方法。\n如果我们想调用属于这个子类对象的特有方法，只能通过类型强转去通过编译器的检查：\n1234567class Test &#123;    public static void main(String[] args) &#123;        Person person = new Student(&quot;kaiven&quot;, 20);        Student student = (Student) person;        student.sayHello();    &#125;&#125;\n\n多态不要去抓着这个字眼不放了，你越想就越容易钻牛角尖。\nJava中的多态，分为编译时多态和运行时多态。\n编译时多态指的是方法的重载：\n1234567891011121314class Student extends Person &#123;        public Student(String name, int age) &#123;        super(name, age);    &#125;    public void sayHello()&#123;        System.out.println(&quot;Hello Java&quot;);    &#125;    public void sayHello(String content)&#123;        System.out.println(content);    &#125;&#125;\n\n运行时多态指的是程序中定义的对象引用的具体类型在运行期间才确定。\n运行时多态的三个条件：继承、覆盖（重写）、向上转型\n123456789101112131415161718192021222324252627282930313233class Student extends Person &#123;    public Student(String name, int age) &#123;        super(name, age);    &#125;    @Override    public String getName() &#123;        return &quot;我就不告诉你我的名次&quot;;    &#125;    &#125;class Teacher extends Person&#123;    public Teacher(String name, int age) &#123;        super(name, age);    &#125;        @Override    public String getName() &#123;        return &quot;我可以告诉你我的名字，但是是假的&quot;;    &#125;&#125;class Test &#123;    public static void main(String[] args) &#123;        Person person01 = new Student(&quot;kaiven&quot;, 20);        Person person02 = new Teacher(&quot;jack&quot;, 22);        System.out.println(person01.getName());        System.out.println(person02.getName());    &#125;&#125;\n\nJVM知道应该调用哪个方法的，不用担心。\n\n2024.10.19\nwriteBy kaiven\n","slug":"java基础/javamxdx","date":"2024-12-03T13:21:54.000Z","categories_index":"八股","tags_index":"java","author_index":"Ivan"},{"id":"5d0fb8fa16015e90389a3f31d7e8667c","title":"java导学","content":"恭喜你，成功入坑Java开发，以后将走上后端开发的道路。\nJava是一门什么样的编程语言呢？\n（AI的回答）\nJava 是一种广泛使用的编程语言，它由Sun Microsystems（现在是Oracle Corporation的一部分）在1995年发布。Java 被设计为具有跨平台兼容性、安全性、网络中心化和健壮性等特点，这使得它成为了构建企业级应用、Android 应用、网站后台服务和其他类型软件的热门选择。\n以下是Java的一些关键特性：\n\n跨平台兼容性：Java的口号“一次编写，到处运行”（Write Once, Run Anywhere，简称WORA）强调了其跨平台的能力。这意味着在一台机器上编写的Java程序可以在其他装有Java虚拟机（JVM）的机器上运行，而无需任何修改。\n\n面向对象：Java是一种面向对象的语言，它支持类、对象、封装、继承和多态等概念。\n\n内存管理：Java有自动垃圾回收机制，这意味着程序员不需要（也不能）手动管理内存。这减少了内存泄漏和其他内存管理错误的可能性。\n\n健壮性：Java的设计目标之一是创建一个健壮的语言，这意味着它旨在消除某些类别的错误，例如数组越界、野指针等。\n\n安全性：Java提供了一个安全的环境，其中包括一个沙箱执行环境和一个强大的安全管理体系。\n\n多线程：Java内置了对多线程编程的支持，这使得开发多线程应用程序变得相对容易。\n\n网络编程：Java有强大的网络编程支持，这使得它非常适合创建网络应用程序和服务。\n\n开源：Java有一个活跃的开源社区，提供了大量的库和框架，如Spring、Hibernate等，这些工具可以帮助开发者快速构建高质量的应用程序。\n\n\nJava在企业级应用开发中非常流行，也被广泛应用于Android移动应用开发。此外，Java还被用于桌面应用程序、游戏开发、科学计算和教育等领域。随着技术的发展，Java也在不断更新和改进，以适应新的编程范式和市场需求。\n快速的浏览一下就好了，对于一个小白来说，这些都是废话。学就完事儿了，现在，管这么多的概念干嘛。\n学的东西是不是很多嘞？\n的确是这样的，技术这种东西是学不完的。我之所以入坑Java就是因为觉得Java框架的统一性，就只用学一个Spring框架。可是深入学习后，才知道是我肤浅了。\n（之前是写前端的，然后就是觉得前端的生态太乱了，真的是百花齐放，然后转到Java后端，发现，其实也差不多）\n但是无论技术多么的复杂多样，掌握好基本的开发要求，不断的扩展知识和技术，这才是正解。\n如果你和我一样，学一个东西非要去搞清楚底层的运行原理或者源码实现，那么，恭喜你，你会陷入一个内耗循环。\n不是说这样不好，但是技术这个东西真的太多啦。比如说一个消息中间件，就有ActiveMQ、RabbitMQ、Kafka、RocketMQ。。。\n你去学嘛，你去看源码嘛，哈哈。\n对于一门技术，我们的态度应该是：\n\n搞明白基本的概念和特性，明白大致的应用场景\n学会技术的基本使用以及了解一些高级特性的适用场景\n对于基本原理，围绕面试八股展开，出现频率高的，重点学习\n源码嘛，看时间喽（如果有人给你出视频去讲源码了，那就不要浪费时间自己看）\n\n不要总是想着要把技术搞得多么的牛逼，要让面试官觉得你牛逼，那才是真的牛逼。\n（面试，也是一门技术活）\n不过，现在，不用考虑这么多，干就完事儿！\n\n2024.10.19\n","slug":"java导学","date":"2024-12-03T13:13:19.000Z","categories_index":"八股","tags_index":"java,java基础","author_index":"Ivan"},{"id":"eb843316efe7fc0d2e0c7904a0ae2582","title":"mysql进阶","content":"MySQL的系统架构1、数据库和数据库实例在与MySQL相关的学习和研究中，我们需要搞清楚一些概念：\n\n数据库：按照一定的数据结构来组织、存储和管理数据的仓库，通常由数据库管理系统进行管理。\n数据库管理软件（RDBMS）：就是我们说的数据库管理软件，我们常说的MySQL指的就是它。\n数据库实例：其实就是正在运行的数据库管理程序，一个数据库管理程序我们称作一个数据库实例。\n\n2、MySQL架构\n（现在的话，有个印象就行了）\n（1）MySQL向外提供的交互接口Connectors组件，是MySQL向外提供的交互组件，如java,.net,php等语言可以通过该组件来操作SQL语句，实现\n与SQL的交互。通过客户端&#x2F;服务器通信协议与MySQL建立连接。MySQL 客户端与服务端的通信方式是 “ 半双工\n”。对于每一个 MySQL 的连接，时刻都有一个线程状态来标识这个连接正在做什么。\n（2）管理服务组件和工具组件提供MySQL的各项服务组件和管理工具，如备份(Backup)，恢复(Recovery)，安全管理(Security)等功能。\n（3）连接池组件负责监听客户端向MySQL Server端的各种请求，接收请求，转发请求到目标模块。每个成功连接MySQL Server的客户请求都会被创建或分配一个线程，该线程负责客户端与MySQL Server端的通信，接收客户端发送的命令，传递服务端的结果信息等。\n（4）SQL接口组件接收用户SQL命令，如DML,DDL和存储过程等，并将最终结果返回给用户。\n（5）查询分析器组件首先分析SQL命令语法的合法性，并进行抽象语法树解析，如果sql有语法错误，会抛出异常信息。\n（6）优化器组件对SQL命令按照标准流程进行优化分析，mysql会按照它认为的最优方式进行优化，选用成本最小的执行计划。\n（7）缓存组件缓存和缓冲组件，这里边的内容我们后边会详细的讲解。\n（8）MySQL存储引擎MySQL属于关系型数据库，而关系型数据库的存储是以表的形式进行的，对于表的创建，数据的存储，检索，更新等都是由MySQL存储引擎完成的。\nMySQL存储引擎在MySQL中扮演着重要角色。研究过SQL Server和Oracle的读者可能很清楚，这两种数据库的存\n储引擎只有一个，而MySQL的存储引擎种类比较多，如MyIsam存储引擎，InnoDB存储引擎和Memory存储引\n擎。\n因为mysql本身就是开源的，他允许第三方基于MySQL骨架，开发适合自己业务需求的存储引擎。从MySQL存储引擎种类上来说，可以分为官方存储引擎和第三方存储引擎，比较常用的存储引擎包括InnoDB存储引擎，MyIsam 存储引擎和Momery存储引擎。\n3、SQL语句的执行流程\n（图应该都可以看得懂的吧）\n小问题：MySQL8为什么取消了查询缓存？\n锁争用问题：在高并发环境中，查询缓存会引起锁争用问题。每次对查询缓存的读写操作都需要获取锁，这在高并发下会导致锁的争用，进而引发性能瓶颈。\n缓存无效化问题：查询缓存的无效化机制导致缓存命中率较低。当一个表的数据发生变化时（如INSERT、UPDATE、DELETE操作），与该表相关的所有查询缓存都会被无效化。对于写操作频繁的系统，这意味着查询缓存的有效性非常短暂，导致缓存命中率很低，反而增加了缓存维护的开销而没有带来明显的性能提升。\n内存开销：查询缓存的管理需要额外的内存资源，而且如果查询语句的字符大小写、空格或者注释的不同，查询缓存都会认为是不同的查询（因为他们的hash值会不同），这可能会导致内存资源的过度消耗。\n\nMySQL的目录结构windows中的目录结构在mysql启动的时候，会从【安装目录】加载软件数据，在运行过程中，会从【数据目录】中读取数据。这两个目\n录我们不要放在一起，避免重新安装软件导致数据丢失：\n\n\nbin目录：用于放置一些可执行的工具文件，如mysql.exe、mysqld.exe、mysqlshow.exe等。\ninclude目录：用于放置一些头文件，如：mysql.h、mysql_ername.h等。（MySQL是C语言写的，这个都知道的吧）\nlib目录：用于放置一系列库文件。\ndata目录：用于放置一些日志文件以及数据库。\nmy.ini文件：MySQL的配置文件，MySQL实例初始化时会加载该文件中的内容\n\n\ndata目录中，每个文件夹对应一个数据库，数据库中的表就是一个又一个的文件。\nLinux中的文件目录这个和windows下的文件目录是差不多的，如果是默认的安装方式的话，文件是分散在不同地方的。\n（百度或者问AI）\n字符集和排序规则mysql支持大量的字符集，但是我们通常使用的是utf8，【show collation】命令可以查看mysql支持的所有的排序规则和字符集，如下所示部分：\n1show collation like &#x27;%utf8%&#x27;;\n\n\n一种字符集会对应很多的规则：\n\nutf8-polish-ci，表示utf-8的字符集的波兰语的比较规则，ci代表忽略大小写。\n\nutf8-general-ci，就是通用的忽略大小写的utf8字符集比较规则。\n\nutf8mb4_0900_ai_ci中的0900指的是Unicode 9.0的规范，后边的后缀代表不区分重音也不区分大小写，他是utf8mb4字符集一个新的通用排序归则。\n\n\n\nutf8和utf8mb4的区别：\n\nutf8mb3(utf-8)：使用1~3个字节表示字符，utf8默认就是utf8mb3。\n\nutf8mb4：使用1~4个字节表示字符，他是utf8的超集，甚至可以存储很多【emoji表情?????】，\n\nmysql8.0已经默认字符集设置为utf8mb4。\n\n\n【字符集】和【比较规则】可以作用在全局、数据库、表、甚至是列级别。（想了解的自行百度怎么设置，大家最熟悉的莫过于在创建库和表的时候指定字符集和比较规则吧）\nMySQL修改配置的方法1、修改全局变量很显然，这些东西你百度都能得到的，这里就不去复制粘贴了。全局修改的变量对每一个会话都起作用。\n2、当前会话的变量这个修改的作用域只对某一个会话起作用。\n3、修改配置文件先看一个示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225[client]port = 3306socket = /tmp/mysql.sock[mysqld]port = 3306basedir = /project/mysql/mysql-8.0.18datadir = /project/mysql/datapid-file = /project/mysql/mysql-8.0.18/mysqld.pidsocket = /tmp/mysql.socktmpdir = /project/mysql/tmpuser = mysql#关闭MySQL X plugin（33060）mysqlx=0###日志配置------innodb_log_file_size = 1Glog_error = /project/mysql/mysql-8.0.18/log/error.logslow_query_log = 1long_query_time = 5slow_query_log_file = /project/mysql/mysql-8.0.18/log/slow.log#记录没有索引导致的慢查询###连接配置------#最大连接数max_connections = 3000#最大错误连接数max_connect_errors = 10#连接闲置超时时间interactive_timeout = 1800wait_timeout = 1800#连接响应超时时间connect-timeout = 60###默认配置（插件、字符------default_authentication_plugin = mysql_native_passwordcharacter-set-server = utf8sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLESinnodb_log_file_size = 1024M#关闭InnoDB严格模式，防止报错 Row size too large (&gt; 8126)innodb_strict_mode=0default-storage-engine=INNODBbind-address = 0.0.0.0#域名解析，设置为1之后就不能直接127.0.0.1连接数据库，需要root@127.0.0.1#skip_name_resolve = 1#忽略大小写，此项很重要（MySQL8之后的版本必须在初始化就设定此参数，初始化之后配置更改不生效）lower_case_table_names = 1###主备相关------server-id = 25log-bin = backup.log#二进制日志格式,三种模式：statement语句&gt;模式,row行模式，mixed混合模式binlog_format = mixedmax_binlog_size = 1Gexpire_logs_days = 7#事务提交前产生的日志缓存binlog_cache_size = 16M#Auto_increment_increment和auto_increment_offset用于主－主服务器（master-to-master）复制，避免主键冲突#为了避免两台服务器同时做更新时自增长字段的值之间发生冲突。一般在主主同步配置时，需要将两台服务器的auto_increment_increment增长量都配置为2（根据从库节点数量配置），而要把auto_increment_offset分别配置为1（主库）和2（从库）#递增值auto_increment_increment = 2#初始值auto_increment_offset = 1#表示需要记录二进制日志的数据库binlog_do_db=csspbinlog_do_db=mysql#从库配置replicate_do_db=cssp#表示不需要记录二进制日志的数据库binlog_ignore_db=information_schema#忽略表replicate-wild-ignore-table=pva_db.pva_login_%replicate-wild-ignore-table=pva_db.pva_login_log#忽略错误代码（从库配置）slave-skip-errors = 1032,1062,126,1114,1146,1048,1396#自动清空不再需要中继日志（从库配置）relay-log-purge = 1###系统资源相关------#接收连接请求队列back_log = 600#最大打开文件数（前提mysql用户需要调整最大打开文件数）open_files_limit = 10240#所有线程打开表数量table_open_cache = 512#处理请求包最大大小max_allowed_packet = 32M#临时表最大大小tmp_table_size = 512M#独立内存表所允许最大容量max_heap_table_size = 512M#用于索引块的缓冲区大小key_buffer_size = 64M#查询排序的缓冲区大小sort_buffer_size = 8M#读操作的缓冲区大小read_buffer_size = 8M#联表查询缓冲区大小join_buffer_size = 8M#批量数据插入缓存bulk_insert_buffer_size = 120M#保存索引以及原始数据的缓冲池（原则上最大为系统内存的 80%）innodb_buffer_pool_size = 2G#脏页比例，脏页占innodb_buffer_pool_size的比例时，触发刷脏页到磁盘（25~50）innodb_max_dirty_pages_pct = 30#事务提交 flushinnodb_flush_log_at_trx_commit = 1#1，（默认值）每一次提交刷新日志到磁盘#2，先写入缓存，由系统设置每秒刷新日志到磁盘（可能丢失1~2秒的数据）###多线程优化------#可重新被利用保存在缓存中的线程数量thread_cache_size = 300###其他配置------#占用内存过高调整以下参数配置#table_definition_cache = 400#open_files_limit = 2048#table_open_cache = 256#跳过密码表检查#skip-grant-tables\n\n修改了配置文件需要重启MySQL服务实例重新加载。\n内置数据库\nmysql：这个库很重要，他是mysql的核心数据库，负责存储数据库的用户、权限设置、关键字等mysql自己需要使用，控制和管理的信息。\n\ninformation_schema：这个数据库维护了数据库其他表的一些描述性信息，也称为元数据。比如，当前有哪\n\n\n些表，哪些视图，哪些触发器，哪些列等。\n\nperformation_schema：这个数据库用来存储mysql服务器运行过程中的一些状态信息，是做性能监控的。\n\n比如最近执行了什么sql语句，内存使用情况等\n\nsys：结合information_schema和performation_schema的数据，能更方便的了解mysql服务器的性能信\n\n息。\n\n2024.11.05\nwriteBy kaiven\n","slug":"mysql进阶","date":"2024-12-03T12:56:15.000Z","categories_index":"八股","tags_index":"mysql","author_index":"Ivan"},{"id":"76e26cf6d70a50daf8e75fb7d566964d","title":"面试官到底喜欢什么样的人？","content":"面试官到底喜欢什么样的人？在统一批次的面试中，可能就有好几百号人，无可否认的是，我们都喜欢优秀的人，都想和优秀的人共事，那怎么表现出我们的优秀呢？\n面试官喜欢爱学习、爱动脑、有技术广度和深度并且有实际经验的人。\n面试时间一般30分钟左右，我们必须通过自己的话术，去展现【爱学习、爱动脑、技术广度和深度以及实际经验】给他&#x2F;她看。\n建立正确的面试心态在这种大环境下，面试时间会被拉的很长，一面、二面、三面……面试的环节越多，那么你挂掉的概率也就越大，但没办法，就是这么卷。。。\n我们不需要唬住所有的面试官，因为在面试的过程中，面试官是用他最熟悉的东西去问题，有可能他熟悉的地方你并不是特别的熟悉，所以可能就会出现答得不好或者答不上来的情况，这很正常。。。\n我们做的事情，就是拿下我们能拿下的面试官。其实大部分面试官都是一边工作一边去面试的，所以八股的知识也就一般。比如说大厂的面试官，可能就会对原理性的东西进行深层次的拷打，如果你还只能回答出一些表面性的东西或者说大家都会说的一些东西，那么就不能体现出你的优势，面试挂掉的概率极大。当然，这些面试官也不是我们的菜。\n这小节最重要的一点就是：你对面试准备有多充分，就决定了你能找到什么样的工作！\n（不会说你随便糊弄了一下就能拿到一份很好的offer，而别人准备了大半年却颗粒无收，匹配机制嘛，找到符合自己目前口味的面试官，才是重点）\n如何把面试官拉倒坑里？上文也叙述过，其实大部分面试官的水平也一般，所以他其实也不知道自己该问些什么东西，如果你也没有对他进行相关的引导的话，他不就只能随便问了嘛。\n如何引导面试官？原理其实也比较简单：\n\n自我介绍阶段，突出描述自己擅长的部分\n回答问题的时候，为下一个问题做铺垫\n\n对于自我介绍，下文会进行详细的叙述。\n我们来说一下第二点，往往面试官问的问题都是层层递进的，会从你对某个问题的回答中捕风捉影，想好下一个要问你的问题。那是不是可以提前预判呢？把面试官引导上你准备好的问题链中去。\n还要一个比较重要的点就是拖延时间，或者说扩展描述，做到问一答三，因为你能回答出来的东西，那肯定是你提前准备好的，你给他暴露的信息越多，他问的点也就越多。但是，短短的半小时，他不可能什么都去问你，一定是从你的问答中挑他感兴趣的点，继续追问。你给他的选项，一定是你准备过的，每个点都这样的去扩展描述，一方面体现出你是一个【爱学习、爱动脑、有技术广度和深度并且有实际经验的人】，另一方面这样也将面试时间的主导权交到了自己的手上，你一直再说，面试官一直在听，问个两三个问题后，他可能就不会在问其他的了。\n（面试也要占用面试官的时间，谁不想休息啊，而且人家也有自己的事情要去做）\n面试的本质是什么？问题：面试是介绍你自己还是你的项目？\n答案：一定是介绍你自己。本质上来说，大多数的项目都是CRUD，没有什么特别的亮点。那和面试官对话的时候，就不要关注项目本身了，而是要去关注某个功能的实现，简单描述一下项目中的功能是怎么去实现的，然后重点叙述一下该方式存在什么样的不足，你会怎么去解决这个问题？\n场景：\n假设你现在的项目就是一个纯粹的后端管理系统，登录方式采用的是JavaWeb的Cookie + Session。\n针对该功能的叙述：\n由于我这个项目其实是一个学习项目，算不上真正意义上的生产级别的项目，所以登录功能只是采用了JavaWeb的 Cookie + Session 这样一种简单的形式。但是呢，这样做存在一些问题。比如说在分布式的环境中，多个JVM实例无法共享 Session ，就会出现明明用户已经登录了，但是后续的请求打在了其他机器上，导致用户会出现重复登录的情况，用户体验感不好。针对这个问题，需要我们去实现session的共享嘛，常见的实现方式就是将 Session 对象序列化放入 Redis 中进行共享，然后每一次的登录请求都去查询Redis。但是呢，这种方式也会出现一定的问题，。。。。。\n（你需要根据实际的场景去提前写好这些话术，你这一套话术下来，是不是达到了拖延时间的效果？你准备的这些话术中的内容的扩展问题你也回去准备的，是不是将面试官引入坑里面了？这一堆东西下来，是不是体现了你是一个【爱学习、爱动脑、有技术广度和深度并且有实际经验的人】？）\n公司招你肯定不是简单的让你做你熟悉的业务，而是想给你什么业务你都能够应对。\n你是一个厨师，业务需求就是食材，只会做几道菜的不叫做厨师。\n项目的亮点角度：架构、业务拆分、技术选型、大数据量处理\n如何写好简历避免已读不回？简历到底看什么？（校招）\n学历（至少全日制本科）\n专业排名（非科班成绩优异也可以，至少证明学习能力很强 &#x3D;&gt; 黑魔法）\n荣誉奖项（黑魔法，如果是大厂的话，斟酌一下，很有可能会让你提供证明材料）\n实习经历（大厂很加分，也可以黑魔法，但是不建议）\n\n学历这个东西确实没有办法，现在的大环境就是这样的，如果你是专科的同学，那么请先专升本，否则你可能会感慨世界的炎凉。（专升本你就写你本科的学历就好了，装傻）\n专业排名真的是最好造假的了，前20%？可以不？谁会去管呢？\n荣誉奖项也是，基本上不会查的，而且你也不会写什么特别高级的奖项，比如说 ACM金牌。。。（当然，如果是大厂的话，背景调查可能比较严格哦，请斟酌）\n实习经历也可以造假的，对，没错，只要你能唬住面试官。（大厂同样需要斟酌）\n如果是找实习的同学，那么肯定是没有实习经历这么一说的（除非你有过一段），那么重点在你的项目经历上。\n虽然说面试是介绍我们自己，但是前提是简历得入得了面试官的法眼，否则面试的资格都没有。\n一个项目的基本元素：\n项目名称（次要，但是不能太土）\n个人职责（在项目中负责什么，应届生次要）\n项目的线上地址（重要，增加项目的真实度）\n项目简介（重要，让面试官能够了解你这个项目的业务类型）\n项目的亮点（重要）\n\n对于项目简介，一定要言简意赅，主要是要让面试官知道你这个项目的大概业务有哪些。你做的那些项目基本上都能找到相似且开源的（大部分同学的项目也是根据这些开源的项目改的），所以没必要去过多的介绍。所以，这里你的项目名称最好是见名知意，比如说xx在线教育平台，面试官甚至都不用去读你的项目简介，就知道你这个项目的业务有哪些。\n对于项目的亮点，这个东西，得从实际的项目出发，体现出你的思考，还是那句话，可能项目真的没有什么亮点，就是一个很普通的CURD。但是，你可以通过引入一些其他的技术，去解决了什么问题，优化了什么东西。（无论是公司里面的大项目还是你的小项目，都会有bug和不足，不然为什么要持续的更新迭代，总会有问题的。）而且，你的亮点话术，要做到有针对性，而不是这些语句迁移到其他的项目上都能使用。\n(什么样的场景，通过什么方式，解决了什么问题或者优化了什么东西)\n如何做好自我介绍？（面试中最重要的环节）好的自我介绍有什么用？\n体现出你自己的价值和逻辑思维能力，快速让面试官对你感兴趣\n引导面试官对你进行提问\n\n什么是一份好的自我介绍？\n语言的流利程度，表达能力流畅的人，面试成功率会高很多。因为语言表达流利的话，证明了你的思维逻辑是流畅的，沟通能力是OK的。\n把自己相关的优势介绍清楚。\n能够讲清楚自己在项目中的职责，成果，并且有量化的数据支撑（人对数字是比较敏感的）。\n拉平和面试官之间的信息差，让面试官能够快速带入我们的项目中，能清楚他想要问的问题。\n\n很有必要去手写一份800字左右的自我介绍，在面试之前不断的打磨，这样才能在面试的时候流利的阐述。\n八股文怎么去准备怎么去回答？八股文这个东西是必须背的，你很难保证面试官不会去问，特别是对于应届生而言。\n八股文大概考什么？市面上的八股文这么多，动不动就几十万字的，没必要啊。这东西是有重点的：\n\njava基础：集合类、JVM、锁、多线程（这里会有实操，比如写代码实现三个线程交替打印“abc”）。\nJUC、AQS、线程池。线程池的核心参数，拒绝策略，队列有哪些。\nSpring、SpringMVC、SpringBoot：老演员了，问的也就那些东西（这里可以结合设计模式去讲，Spring中运用了大量的设计模式）。\nMySQL：。。。\nRedis：数据结构，一些机制。\n\n这里给鱼皮（B站搜索：程序员鱼皮）的面试鸭刷题网站打一个广告：https://www.mianshiya.com/\n这是一个专门为程序员提供的在线刷题平台，涵盖从IT各大学科的面试经典八股文，支持网页端和小程序端，目前（2024.10.20）永久会员只需要 129 元。\n（不要求每一道八股文你都能回答得很好，但是你必须有一两道八股文讲得非常出彩，结合自己的理解和实际的业务场景）\n总结总的来说，面试的宗旨就是：通过和面试官的沟通，去展示你的优秀，你是一个爱学习、爱动脑、有技术广度和深度并且有实际经验的人。\n","slug":"面试","date":"2024-12-03T12:35:49.000Z","categories_index":"","tags_index":"面试","author_index":"Ivan"},{"id":"e53aef447e609f6346cd88030af73ac8","title":"JDK8有哪些新特性？","content":"JDK8较为重要和平日里经常被问的特性如下：\n1)用元空间替代了永久代因为JDK8要把JRockit虚拟机和Hotspot虚拟机融合，而JRockit没有永久代，所以把Hotspot永久代给去了（本质也是永久代回收效率太低)\n2)引入了Lambda表达式Lambda表达式是Java8中引入的一个重要特性，它允许我们以更简洁和灵活的方式编写代码。Lambda表达式可以看作是匿名函数，它没有方法名，但可以包含参数和函数体。Lambda表达式可以用于简化代码，提高代码的可读性和可维护性。Lambda表达式的基本语法如下：\n123(parameters) -&gt; expression或(parameters) -&gt; &#123; statements; &#125;\n其中，parameters是参数列表，expression是函数体，statements是函数体的多条语句。Lambda表达式可以用于替换匿名内部类，使代码更加简洁和易读。例如，我们可以使用Lambda表达式来简化以下代码：\n1234567List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);Collections.sort(list, new Comparator&lt;String&gt;() &#123;    @Override    public int compare(String s1, String s2) &#123;        return s1.compareTo(s2);    &#125;&#125;);\n使用Lambda表达式可以简化为：\n12List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);Collections.sort(list, (s1, s2) -&gt; s1.compareTo(s2));\nLambda表达式还可以用于简化其他场景，例如线程的创建、集合的遍历等。\n3)引入了日期类、接口默认方法、静态方法Java8引入了新的日期和时间APl(位于java.time包中)，它们更加简洁和易于使用，解决了旧版日期时间AP!的许多问题。例如DateCalendar都是可变类且线程不安全。而新的日期类都是不可变的，一旦创建就不能修改，这样可以避免意外的修改，提升代码的安全性和可维护性。\n123LocalDate date =LocalDate.now();LocalTime time =LocalTime.now();LocalDateTime dateTime =LocalDateTime.now()\nDate本身不包含时区信息，必须使用Calendar类来处理时区，但使用起来非常复杂且容易出错。新API提供了专门的时区类（如ZonedDateTime,OffsetDateTimeZoneId等)，简化了时区处理，并且这些类的方法更加直观和易用。\n接口默认方法、静态默认方法允许在接口中定义方法的默认实现，这样接口的实现类不需要再实现这些方法。之所以提供静态方法，是为了将相关的方法内聚在接口中，而不必创建新的对象。\n4)新增Stream流式接口Stream API是Java8中引入的一个新特性，它提供了一种新的方式来处理数据集合。Stream API允许我们以声明式的方式处理数据，避免了传统的循环和条件语句，使代码更加简洁和易读。Stream API的基本语法如下：\n1Stream&lt;T&gt; stream = collection.stream();\n其中，collection是一个数据集合，可以是List、Set、Map等。stream是一个Stream对象，它表示一个数据流，可以通过一系列的操作来处理数据。Stream API提供了一系列的操作，包括过滤、映射、排序、聚合等。这些操作可以链式调用，使代码更加简洁和易读。例如，我们可以使用Stream API来过滤一个List中的偶数，并计算它们的和：\n123456List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6);int sum = list.stream()    .filter(n -&gt; n % 2 == 0)    .mapToInt(Integer::intValue)    .sum();System.out.println(sum); // 输出：12\n在上面的代码中，我们首先将List转换为一个Stream对象，然后使用filter操作过滤出偶数，再使用mapToInt操作将Stream中的元素转换为int类型，最后使用sum操作计算它们的和。整个操作链式调用，使代码更加简洁和易读。Stream API还提供了一些其他的操作，例如reduce、collect、forEach等，可以满足各种数据处理的需求。通过使用Stream API，我们可以更加高效地处理数据集合，使代码更加简洁和易读。\n5)引入Optional类Optional是Java8引入的一个容器类，用于表示可能为空的值。它通过提供更为清晰的AP!,来减少程序中出现nu11的情况，避免NullPointerException(空指针异常)的发生。Optional可以包含一个值，也可以为空，从而表示“值存在”或“值不存在”这两种状态。作用：\n\n减少NullPointerException:通过Optional提供的操作方法，避免 直接使用 null进行空值检查，从而降低空指针异常的风险。\n提高代码可读性：Optional 提供了一套简洁的API,例如isPresent() ifPresent()和orElse()，可以让代码更具表达性，清晰地展示处理空值的逻辑1234Optional&lt;String&gt; optional = Optional.of(&quot;Hello&quot;);if (optional.isPresent()) &#123;    System.out.println(optional.get());&#125;\n\n6)新增了CompletableFuture、StampedLock等并发实现类。CompletableFuture提供了一个新的异步编程模型，简化了异步任务的编写和管理。StampedLock是一个新的读写锁实现，它提供了一种新的方式来处理读写锁，避免了复杂的锁机制和锁竞争。\n如果你对HashMap、ConcurrentHashMap面试题有准备的话，这时候也可以抛出来，引导面试官来询问。比如：Java8修改了HashMap和ConcurrentHashMap的实现。\n\n","slug":"java基础/八股","date":"2024-11-13T04:14:48.000Z","categories_index":"八股","tags_index":"java","author_index":"Ivan"},{"id":"bc567916c4dc0d8169bd26d18e348d36","title":"test","content":"欢迎使用 Markdown 笔记这是首次使用 Markdown 笔记 自动生成的内容，包含 Markdown 语法和应用介绍\n表格 &amp; 文本样式\n\n\n样式\n语法\n示例\n\n\n\n加粗\n前后 ** 或  __\n加粗1 加粗2\n\n\n斜体\n前后 * 或  _\n斜体1 斜体2\n\n\n删除线\n前后 ~~\n删除线\n\n\n内联代码\n前后 &#96;\ncode\n\n\n下划线\n前 &lt;u&gt;  后 &lt;/u&gt;\n下划线\n\n\n高亮\n前后 ==\n&#x3D;&#x3D;高亮文本&#x3D;&#x3D;\n\n\n引用\n\n\n\n\n\n\n\n\nuTools 新一代效率工具平台\n链接鼠标右击 或 Ctrl 键 + 点击 系统默认浏览器打开链接\nuTools 官网  猿料社区\n图片拖放图片文件、粘贴截图可直接将图片源数据存储到笔记中\n\n图片可拖动为文件到任意窗口使用\n无序列表\n项目\n项目 1\n项目 A\n项目 B\n\n\n项目 2\n\n\n\n有序列表\n项目 1\n项目 A\n项目 B\n\n\n项目 2\n\n任务列表\n A 计划\n A1 计划\n A2 计划\n\n\n B 计划\n\n代码块代码块支持 168 种编程语言\n12345678910111213141516// javascript 冒泡排序function bubbleSort(array) &#123;  let swapped = true;  do &#123;    swapped = false;    for (let j = 0; j &lt; array.length; j++) &#123;      if (array[j] &gt; array[j + 1]) &#123;        let temp = array[j];        array[j] = array[j + 1];        array[j + 1] = temp;        swapped = true;      &#125;    &#125;  &#125; while (swapped);  return array;&#125;\n\nKaTeX 数学公式内联公式质能方程 $E&#x3D;mc^2$\n公式块$$\\displaystyle \\left( \\sum_{k&#x3D;1}^n a_k b_k \\right)^2 \\leq \\left( \\sum_{k&#x3D;1}^n a_k^2 \\right) \\left( \\sum_{k&#x3D;1}^n b_k^2 \\right)$$\n应用介绍特性\n极佳的 Markdown 编辑体验，实时预览、存储\n与传统富文本编辑方式结合，支持通用快捷键\n导出 MD、html、PDF、图片\n可快速搜索全部笔记(内容和标题)\n笔记名称可设置为 uTools 关键字，外部快速打开笔记\n\n使用技巧\n侧边栏文件夹或笔记，拖拽调整位置，鼠标右击 显示操作菜单\n当焦点未在编辑器，键盘上下方向键、 Tab 键切换笔记\n当焦点未在编辑器，Enter 进入编辑\nCommand/Ctrl+F 焦点切换到搜索\n编辑器中列表编辑时，按 Tab 变子项，Shift + Tab 恢复\n\n","slug":"test","date":"2024-11-09T02:38:44.000Z","categories_index":"","tags_index":"test","author_index":"Ivan"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post1$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server1$ hexo server\n\nMore info: Server\nGenerate static files1$ hexo generate\n\nMore info: Generating\nDeploy to remote sites1$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2024-11-07T16:24:53.067Z","categories_index":"","tags_index":"","author_index":"Ivan"}]