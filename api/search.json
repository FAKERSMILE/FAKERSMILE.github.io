[{"id":"60619d060d49b9e7a2a341a834e58b47","title":"Java集合面试题","content":"# Java集合面试题# 概念# 数组与集合区别，用过哪些？数组和集合的区别：\n\n数组是固定长度的数据结构，一旦创建长度就无法改变，而集合是动态长度的数据结构，可以根据需要动态增加或减少元素。\n数组可以包含基本数据类型和对象，而集合只能包含对象。\n数组可以直接访问元素，而集合需要通过迭代器或其他方法访问元素。\n\n我用过的一些 Java 集合类：\n\nArrayList： 动态数组，实现了List接口，支持动态增长。\nLinkedList： 双向链表，也实现了List接口，支持快速的插入和删除操作。\nHashMap： 基于哈希表的Map实现，存储键值对，通过键快速查找值。\nHashSet： 基于HashMap实现的Set集合，用于存储唯一元素。\nTreeMap： 基于红黑树实现的有序Map集合，可以按照键的顺序进行排序。\nLinkedHashMap： 基于哈希表和双向链表实现的Map集合，保持插入顺序或访问顺序。\nPriorityQueue： 优先队列，可以按照比较器或元素的自然顺序进行排序。\n\n# 说说Java中的集合？List是有序的Collection，使用此接口能够精确的控制每个元素的插入位置，用户能根据索引访问List中元素。常用的实现List的类有LinkedList，ArrayList，Vector，Stack。\n\nArrayList是容量可变的非线程安全列表，其底层使用数组实现。当几何扩容时，会创建更大的数组，并把原数组复制到新数组。ArrayList支持对元素的快速随机访问，但插入与删除速度很慢。\nLinkedList本质是一个双向链表，与ArrayList相比，，其插入和删除速度更快，但随机访问速度更慢。\n\nSet不允许存在重复的元素，与List不同，set中的元素是无序的。常用的实现有HashSet，LinkedHashSet和TreeSet。\n\nHashSet通过HashMap实现，HashMap的Key即HashSet存储的元素，所有Key都是用相同的Value，一个名为PRESENT的Object类型常量。使用Key保证元素唯一性，但不保证有序性。由于HashSet是HashMap实现的，因此线程不安全。\nLinkedHashSet继承自HashSet，通过LinkedHashMap实现，使用双向链表维护元素插入顺序。\nTreeSet通过TreeMap实现的，添加元素到集合时按照比较规则将其插入合适的位置，保证插入后的集合仍然有序。\n\nMap 是一个键值对集合，存储键、值和之间的映射。Key 无序，唯一；value 不要求有序，允许重复。Map 没有继承于 Collection 接口，从 Map 集合中检索元素时，只要给出键对象，就会返回对应的值对象。主要实现有TreeMap、HashMap、HashTable、LinkedHashMap、ConcurrentHashMap\n\nHashMap：JDK1.8 之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突），JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间\nLinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。\nHashTable：数组+链表组成的，数组是 HashTable 的主体，链表则是主要为了解决哈希冲突而存在的\nTreeMap：红黑树（自平衡的排序二叉树）\nConcurrentHashMap：Node数组+链表+红黑树实现，线程安全的（jdk1.8以前Segment锁，1.8以后volatile + CAS 或者 synchronized）\n\n# Java中的线程安全的集合是什么？在 java.util 包中的线程安全的类主要 2 个，其他都是非线程安全的。\n\nVector：线程安全的动态数组，其内部方法基本都经过synchronized修饰，如果不需要线程安全，并不建议选择，毕竟同步是有额外开销的。Vector 内部是使用对象数组来保存数据，可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据。\nHashtable：线程安全的哈希表，HashTable 的加锁方法是给每个方法加上 synchronized 关键字，这样锁住的是整个 Table 对象，不支持 null 键和值，由于同步导致的性能开销，所以已经很少被推荐使用，如果要保证线程安全的哈希表，可以用ConcurrentHashMap。\n\njava.util.concurrent 包提供的都是线程安全的集合：\n并发Map：\n\nConcurrentHashMap：它与 HashTable 的主要区别是二者加锁粒度的不同，在JDK1.7，ConcurrentHashMap加的是分段锁，也就是Segment锁，每个Segment 含有整个 table 的一部分，这样不同分段之间的并发操作就互不影响。在JDK 1.8 ，它取消了Segment字段，直接在table元素上加锁，实现对每一行进行加锁，进一步减小了并发冲突的概率。对于put操作，如果Key对应的数组元素为null，则通过CAS操作（Compare and Swap）将其设置为当前值。如果Key对应的数组元素（也即链表表头或者树的根元素）不为null，则对该元素使用 synchronized 关键字申请锁，然后进行操作。如果该 put 操作使得当前链表长度超过一定阈值，则将该链表转换为红黑树，从而提高寻址效率。\nConcurrentSkipListMap：实现了一个基于SkipList（跳表）算法的可排序的并发集合，SkipList是一种可以在对数预期时间内完成搜索、插入、删除等操作的数据结构，通过维护多个指向其他元素的“跳跃”链接来实现高效查找。\n\n并发Set：\n\nConcurrentSkipListSet：是线程安全的有序的集合。底层是使用ConcurrentSkipListMap实现。\nCopyOnWriteArraySet：是线程安全的Set实现，它是线程安全的无序的集合，可以将它理解成线程安全的HashSet。有意思的是，CopyOnWriteArraySet和HashSet虽然都继承于共同的父类AbstractSet；但是，HashSet是通过“散列表”实现的，而CopyOnWriteArraySet则是通过“动态数组(CopyOnWriteArrayList)”实现的，并不是散列表。\n\n并发List：\n\nCopyOnWriteArrayList：它是 ArrayList 的线程安全的变体，其中所有写操作（add，set等）都通过对底层数组进行全新复制来实现，允许存储 null 元素。即当对象进行写操作时，使用了Lock锁做同步处理，内部拷贝了原数组，并在新数组上进行添加操作，最后将新数组替换掉旧数组；若进行的读操作，则直接返回结果，操作过程中不需要进行同步。\n\n并发 Queue：\n\nConcurrentLinkedQueue：是一个适用于高并发场景下的队列，它通过无锁的方式(CAS)，实现了高并发状态下的高性能。通常，ConcurrentLinkedQueue 的性能要好于 BlockingQueue 。\nBlockingQueue：与 ConcurrentLinkedQueue 的使用场景不同，BlockingQueue 的主要功能并不是在于提升高并发时的队列性能，而在于简化多线程间的数据共享。BlockingQueue 提供一种读写阻塞等待的机制，即如果消费者速度较快，则 BlockingQueue 则可能被清空，此时消费线程再试图从 BlockingQueue 读取数据时就会被阻塞。反之，如果生产线程较快，则 BlockingQueue 可能会被装满，此时，生产线程再试图向 BlockingQueue 队列装入数据时，便会被阻塞等待。\n\n并发 Deque：\n\nLinkedBlockingDeque：是一个线程安全的双端队列实现。它的内部使用链表结构，每一个节点都维护了一个前驱节点和一个后驱节点。LinkedBlockingDeque 没有进行读写锁的分离，因此同一时间只能有一个线程对其进行操作\nConcurrentLinkedDeque：ConcurrentLinkedDeque是一种基于链接节点的无限并发链表。可以安全地并发执行插入、删除和访问操作。当许多线程同时访问一个公共集合时，ConcurrentLinkedDeque是一个合适的选择。\n\n# Collections和Collection的区别\nCollection是Java集合框架中的一个接口，它是所有集合类的基础接口。它定义了一组通用的操作和方法，如添加、删除、遍历等，用于操作和管理一组对象。Collection接口有许多实现类，如List、Set和Queue等。\nCollections（注意有一个s）是Java提供的一个工具类，位于java.util包中。它提供了一系列静态方法，用于对集合进行操作和算法。Collections类中的方法包括排序、查找、替换、反转、随机化等等。这些方法可以对实现了Collection接口的集合进行操作，如List和Set。\n\n# 集合遍历的方法有哪些？在Java中，集合的遍历方法主要有以下几种：\n\n普通 for 循环： 可以使用带有索引的普通 for 循环来遍历 List。\n\n123456789List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;A&quot;);list.add(&quot;B&quot;);list.add(&quot;C&quot;);for (int i = 0; i &lt; list.size(); i++) &#123;    String element = list.get(i);    System.out.println(element);&#125;\n\n\n增强 for 循环（for-each循环）： 用于循环访问数组或集合中的元素。\n\n12345678List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;A&quot;);list.add(&quot;B&quot;);list.add(&quot;C&quot;);for (String element : list) &#123;    System.out.println(element);&#125;\n\n\nIterator 迭代器： 可以使用迭代器来遍历集合，特别适用于需要删除元素的情况。\n\n12345678910List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;A&quot;);list.add(&quot;B&quot;);list.add(&quot;C&quot;);Iterator&lt;String&gt; iterator = list.iterator();while(iterator.hasNext()) &#123;    String element = iterator.next();    System.out.println(element);&#125;\n\n\nListIterator 列表迭代器： ListIterator是迭代器的子类，可以双向访问列表并在迭代过程中修改元素。\n\n12345678910List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;A&quot;);list.add(&quot;B&quot;);list.add(&quot;C&quot;);ListIterator&lt;String&gt; listIterator= list.listIterator();while(listIterator.hasNext()) &#123;    String element = listIterator.next();    System.out.println(element);&#125;\n\n\n使用 forEach 方法： Java 8引入了 forEach 方法，可以对集合进行快速遍历。\n\n123456List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;A&quot;);list.add(&quot;B&quot;);list.add(&quot;C&quot;);list.forEach(element -&gt; System.out.println(element));\n\n\nStream API： Java 8的Stream API提供了丰富的功能，可以对集合进行函数式操作，如过滤、映射等。\n\n123456List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;A&quot;);list.add(&quot;B&quot;);list.add(&quot;C&quot;);list.stream().forEach(element -&gt; System.out.println(element));\n\n这些是常用的集合遍历方法，根据情况选择合适的方法来遍历和操作集合。\n# List# 讲一下java里面list的几种实现，几种实现有什么不同？在Java中，List接口是最常用的集合类型之一，用于存储元素的有序集合。以下是Java中常见的List实现及其特点： \n\nVector 是 Java 早期提供的线程安全的动态数组，如果不需要线程安全，并不建议选择，毕竟同步是有额外开销的。Vector 内部是使用对象数组来保存数据，可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据。\nArrayList 是应用更加广泛的动态数组实现，它本身不是线程安全的，所以性能要好很多。与 Vector 近似，ArrayList 也是可以根据需要调整容量，不过两者的调整逻辑有所区别，Vector 在扩容时会提高 1 倍，而 ArrayList 则是增加 50%。\nLinkedList 顾名思义是 Java 提供的双向链表，所以它不需要像上面两种那样调整容量，它也不是线程安全的。\n\n\n\n\n\n\n\n\n\n\n这几种实现具体在什么场景下应该用哪种？\n\nVector 和 ArrayList 作为动态数组，其内部元素以数组形式顺序存储的，所以非常适合随机访问的场合。除了尾部插入和删除元素，往往性能会相对较差，比如我们在中间位置插入一个元素，需要移动后续所有元素。\n而 LinkedList 进行节点插入、删除却要高效得多，但是随机访问性能则要比动态数组慢。\n\n# Arraylist和LinkedList的区别，哪个集合是线程安全的？ArrayList和LinkedList都是Java中常见的集合类，它们都实现了List接口。\n\n底层数据结构不同：ArrayList使用数组实现，通过索引进行快速访问元素。LinkedList使用链表实现，通过节点之间的指针进行元素的访问和操作。\n插入和删除操作的效率不同：ArrayList在尾部的插入和删除操作效率较高，但在中间或开头的插入和删除操作效率较低，需要移动元素。LinkedList在任意位置的插入和删除操作效率都比较高，因为只需要调整节点之间的指针，但是LinkedList是不支持随机访问的，所以除了头结点外插入和删除的时间复杂度都是0(n)，效率也不是很高所以LinkedList基本没人用。\n随机访问的效率不同：ArrayList支持通过索引进行快速随机访问，时间复杂度为O(1)。LinkedList需要从头或尾开始遍历链表，时间复杂度为O(n)。\n空间占用：ArrayList在创建时需要分配一段连续的内存空间，因此会占用较大的空间。LinkedList每个节点只需要存储元素和指针，因此相对较小。\n使用场景：ArrayList适用于频繁随机访问和尾部的插入删除操作，而LinkedList适用于频繁的中间插入删除操作和不需要随机访问的场景。\n线程安全：这两个集合都不是线程安全的，Vector是线程安全的\n\n# ArrayList线程安全吗？把ArrayList变成线程安全有哪些方法？不是线程安全的，ArrayList变成线程安全的方式有：\n\n使用Collections类的synchronizedList方法将ArrayList包装成线程安全的List：\n\n1List&lt;String&gt; synchronizedList = Collections.synchronizedList(arrayList);\n\n\n使用CopyOnWriteArrayList类代替ArrayList，它是一个线程安全的List实现：\n\n1CopyOnWriteArrayList&lt;String&gt; copyOnWriteArrayList = new CopyOnWriteArrayList&lt;&gt;(arrayList);\n\n\n使用Vector类代替ArrayList，Vector是线程安全的List实现：\n\n1Vector&lt;String&gt; vector = new Vector&lt;&gt;(arrayList);\n\n# 为什么ArrayList不是线程安全的，具体来说是哪里不安全？在高并发添加数据下，ArrayList会暴露三个问题;\n\n部分值为null（我们并没有add null进去）\n索引越界异常\nsize与我们add的数量不符\n\n为了知道这三种情况是怎么发生的，ArrayList，add 增加元素的代码如下：\n12345public boolean add(E e) &#123;        ensureCapacityInternal(size + 1);  // Increments modCount!!        elementData[size++] = e;        return true;    &#125;\n\nensureCapacityInternal()这个方法的详细代码我们可以暂时不看，它的作用就是判断如果将当前的新元素加到列表后面，列表的elementData数组的大小是否满足，如果size + 1的这个需求长度大于了elementData这个数组的长度，那么就要对这个数组进行扩容。\n大体可以分为三步：\n\n判断数组需不需要扩容，如果需要的话，调用grow方法进行扩容；\n将数组的size位置设置值（因为数组的下标是从0开始的）；\n将当前集合的大小加1\n\n下面我们来分析三种情况都是如何产生的：\n\n部分值为null：当线程1走到了扩容那里发现当前size是9，而数组容量是10，所以不用扩容，这时候cpu让出执行权，线程2也进来了，发现size是9，而数组容量是10，所以不用扩容，这时候线程1继续执行，将数组下标索引为9的位置set值了，还没有来得及执行size++，这时候线程2也来执行了，又把数组下标索引为9的位置set了一遍，这时候两个先后进行size++，导致下标索引10的地方就为null了。\n索引越界异常：线程1走到扩容那里发现当前size是9，数组容量是10不用扩容，cpu让出执行权，线程2也发现不用扩容，这时候数组的容量就是10，而线程1 set完之后size++，这时候线程2再进来size就是10，数组的大小只有10，而你要设置下标索引为10的就会越界（数组的下标索引从0开始）；\nsize与我们add的数量不符：这个基本上每次都会发生，这个理解起来也很简单，因为size++本身就不是原子操作，可以分为三步：获取size的值，将size的值加1，将新的size值覆盖掉原来的，线程1和线程2拿到一样的size值加完了同时覆盖，就会导致一次没有加上，所以肯定不会与我们add的数量保持一致的；\n\n# ArrayList 和 LinkedList 的应用场景？\nArrayList适用于需要频繁访问集合元素的场景。它基于数组实现，可以通过索引快速访问元素，因此在按索引查找、遍历和随机访问元素的操作上具有较高的性能。当需要频繁访问和遍历集合元素，并且集合大小不经常改变时，推荐使用ArrayList\nLinkedList适用于频繁进行插入和删除操作的场景。它基于链表实现，插入和删除元素的操作只需要调整节点的指针，因此在插入和删除操作上具有较高的性能。当需要频繁进行插入和删除操作，或者集合大小经常改变时，可以考虑使用LinkedList。\n\n# ArrayList的扩容机制说一下ArrayList在添加元素时，如果当前元素个数已经达到了内部数组的容量上限，就会触发扩容操作。ArrayList的扩容操作主要包括以下几个步骤：\n\n计算新的容量：一般情况下，新的容量会扩大为原容量的1.5倍（在JDK 10之后，扩容策略做了调整），然后检查是否超过了最大容量限制。\n创建新的数组：根据计算得到的新容量，创建一个新的更大的数组。\n将元素复制：将原来数组中的元素逐个复制到新数组中。\n更新引用：将ArrayList内部指向原数组的引用指向新数组。\n完成扩容：扩容完成后，可以继续添加新元素。\n\nArrayList的扩容操作涉及到数组的复制和内存的重新分配，所以在频繁添加大量元素时，扩容操作可能会影响性能。为了减少扩容带来的性能损耗，可以在初始化ArrayList时预分配足够大的容量，避免频繁触发扩容操作。\n之所以扩容是 1.5 倍，是因为 1.5 可以充分利用移位操作，减少浮点数或者运算时间和运算次数。\n12// 新容量计算int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);\n\n# 线程安全的 List， CopyonWriteArraylist是如何实现线程安全的CopyOnWriteArrayList底层也是通过一个数组保存数据，使用volatile关键字修饰数组，保证当前线程对数组对象重新赋值后，其他线程可以及时感知到。\n1private transient volatile Object[] array;\n\n在写入操作时，加了一把互斥锁ReentrantLock以保证线程安全。\n12345678910111213141516171819202122public boolean add(E e) &#123;    //获取锁    final ReentrantLock lock = this.lock;    //加锁    lock.lock();    try &#123;        //获取到当前List集合保存数据的数组        Object[] elements = getArray();        //获取该数组的长度（这是一个伏笔，同时len也是新数组的最后一个元素的索引值）        int len = elements.length;        //将当前数组拷贝一份的同时，让其长度加1        Object[] newElements = Arrays.copyOf(elements, len + 1);        //将加入的元素放在新数组最后一位，len不是旧数组长度吗，为什么现在用它当成新数组的最后一个元素的下标？建议自行画图推演，就很容易理解。        newElements[len] = e;        //替换引用，将数组的引用指向给新数组的地址        setArray(newElements);        return true;    &#125; finally &#123;        //释放锁        lock.unlock();    &#125;&#125;\n\n看到源码可以知道写入新元素时，首先会先将原来的数组拷贝一份并且让原来数组的长度+1后就得到了一个新数组，新数组里的元素和旧数组的元素一样并且长度比旧数组多一个长度，然后将新加入的元素放置都在新数组最后一个位置后，用新数组的地址替换掉老数组的地址就能得到最新的数据了。\n在我们执行替换地址操作之前，读取的是老数组的数据，数据是有效数据；执行替换地址操作之后，读取的是新数组的数据，同样也是有效数据，而且使用该方式能比读写都加锁要更加的效率。\n现在我们来看读操作，读是没有加锁的，所以读是一直都能读\n123public E get(int index) &#123;    return get(getArray(), index);&#125;\n\n# Map# HashMap实现原理介绍一下？在 JDK 1.7 版本之前， HashMap 数据结构是数组和链表，HashMap通过哈希算法将元素的键（Key）映射到数组中的槽位（Bucket）。如果多个键映射到同一个槽位，它们会以链表的形式存储在同一个槽位上，因为链表的查询时间是O(n)，所以冲突很严重，一个索引上的链表非常长，效率就很低了。  所以在 JDK 1.8 版本的时候做了优化，当一个链表的长度超过8的时候就转换数据结构，不再使用链表存储，而是使用红黑树，查找时使用红黑树，时间复杂度O（log n），可以提高查询性能，但是在数量较少时，即数量小于6时，会将红黑树转换回链表。\n\n# 了解的哈希冲突解决方法有哪些？\n链接法：使用链表或其他数据结构来存储冲突的键值对，将它们链接在同一个哈希桶中。\n开放寻址法：在哈希表中找到另一个可用的位置来存储冲突的键值对，而不是存储在链表中。常见的开放寻址方法包括线性探测、二次探测和双重散列。\n再哈希法（Rehashing）：当发生冲突时，使用另一个哈希函数再次计算键的哈希值，直到找到一个空槽来存储键值对。\n哈希桶扩容：当哈希冲突过多时，可以动态地扩大哈希桶的数量，重新分配键值对，以减少冲突的概率。\n\n# HashMap是线程安全的吗？hashmap不是线程安全的，hashmap在多线程会存在下面的问题：\n\nJDK 1.7 HashMap 采用数组 + 链表的数据结构，多线程背景下，在数组扩容的时候，存在 Entry 链死循环和数据丢失问题。\nJDK 1.8 HashMap 采用数组 + 链表 + 红黑二叉树的数据结构，优化了 1.7 中数组扩容的方案，解决了 Entry 链死循环和数据丢失问题。但是多线程背景下，put 方法存在数据覆盖的问题。\n\n如果要保证线程安全，可以通过这些方法来保证：\n\n多线程环境可以使用Collections.synchronizedMap同步加锁的方式，还可以使用HashTable，但是同步的方式显然性能不达标，而ConurrentHashMap更适合高并发场景使用。\n\nConcurrentHashmap在JDK1.7和1.8的版本改动比较大，1.7使用Segment+HashEntry分段锁的方式实现，1.8则抛弃了Segment，改为使用CAS+synchronized+Node实现，同样也加入了红黑树，避免链表过长导致性能的问题。\n\n\n# hashmap的put过程介绍一下\nHashMap HashMap的put()方法用于向HashMap中添加键值对，当调用HashMap的put()方法时，会按照以下详细流程执行（JDK8 1.8版本）：\n\n\n\n\n\n\n\n\n\n第一步：根据要添加的键的哈希码计算在数组中的位置（索引）。\n\n\n\n\n\n\n\n\n\n第二步：检查该位置是否为空（即没有键值对存在）\n\n如果为空，则直接在该位置创建一个新的Entry对象来存储键值对。将要添加的键值对作为该Entry的键和值，并保存在数组的对应位置。将HashMap的修改次数（modCount）加1，以便在进行迭代时发现并发修改。\n\n\n\n\n\n\n\n\n\n\n第三步：如果该位置已经存在其他键值对，检查该位置的第一个键值对的哈希码和键是否与要添加的键值对相同？\n\n如果相同，则表示找到了相同的键，直接将新的值替换旧的值，完成更新操作。\n\n\n\n\n\n\n\n\n\n\n第四步：如果第一个键值对的哈希码和键不相同，则需要遍历链表或红黑树来查找是否有相同的键：\n如果键值对集合是链表结构，从链表的头部开始逐个比较键的哈希码和equals()方法，直到找到相同的键或达到链表末尾。\n\n如果找到了相同的键，则使用新的值取代旧的值，即更新键对应的值。\n如果没有找到相同的键，则将新的键值对添加到链表的头部。\n\n如果键值对集合是红黑树结构，在红黑树中使用哈希码和equals()方法进行查找。根据键的哈希码，定位到红黑树中的某个节点，然后逐个比较键，直到找到相同的键或达到红黑树末尾。\n\n如果找到了相同的键，则使用新的值取代旧的值，即更新键对应的值。\n如果没有找到相同的键，则将新的键值对添加到红黑树中。\n\n\n\n\n\n\n\n\n\n\n第五步：检查链表长度是否达到阈值（默认为8）：\n\n如果链表长度超过阈值，且HashMap的数组长度大于等于64，则会将链表转换为红黑树，以提高查询效率。\n\n\n\n\n\n\n\n\n\n\n第六步：检查负载因子是否超过阈值（默认为0.75）：\n\n如果键值对的数量（size）与数组的长度的比值大于阈值，则需要进行扩容操作。\n\n\n\n\n\n\n\n\n\n\n第七步：扩容操作：\n\n创建一个新的两倍大小的数组。\n将旧数组中的键值对重新计算哈希码并分配到新数组中的位置。\n更新HashMap的数组引用和阈值参数。\n\n\n\n\n\n\n\n\n\n\n第八步：完成添加操作。\n此外，HashMap是非线程安全的，如果在多线程环境下使用，需要采取额外的同步措施或使用线程安全的ConcurrentHashMap。\n# HashMap的put(key,val)和get(key)过程\n存储对象时，我们将K&#x2F;V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。\n获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。\n\n# hashmap 调用get方法一定安全吗？不是，调用 get 方法有几点需要注意的地方：\n\n空指针异常（NullPointerException）：如果你尝试用 null 作为键调用 get 方法，而 HashMap 没有被初始化（即为 null），那么会抛出空指针异常。不过，如果 HashMap 已经初始化，使用 null 作为键是允许的，因为 HashMap 支持 null 键。\n线程安全：HashMap 本身不是线程安全的。如果在多线程环境中，没有适当的同步措施，同时对 HashMap 进行读写操作可能会导致不可预测的行为。例如，在一个线程中调用 get 方法读取数据，而另一个线程同时修改了结构（如增加或删除元素），可能会导致读取操作得到错误的结果或抛出 ConcurrentModificationException。如果需要在多线程环境中使用类似 HashMap 的数据结构，可以考虑使用 ConcurrentHashMap。\n\n# HashMap一般用什么做Key？为啥String适合做Key呢？用 string 做 key，因为 String对象是不可变的，一旦创建就不能被修改，这确保了Key的稳定性。如果Key是可变的，可能会导致hashCode和equals方法的不一致，进而影响HashMap的正确性。\n# 为什么HashMap要用红黑树而不是平衡二叉树？\n平衡二叉树追求的是一种 “完全平衡” 状态：任何结点的左右子树的高度差不会超过 1，优势是树的结点是很平均分配的。这个要求实在是太严了，导致每次进行插入&#x2F;删除节点的时候，几乎都会破坏平衡树的第二个规则，进而我们都需要通过左旋和右旋来进行调整，使之再次成为一颗符合要求的平衡树。\n红黑树不追求这种完全平衡状态，而是追求一种 “弱平衡” 状态：整个树最长路径不会超过最短路径的 2 倍。优势是虽然牺牲了一部分查找的性能效率，但是能够换取一部分维持树平衡状态的成本。与平衡树不同的是，红黑树在插入、删除等操作，不会像平衡树那样，频繁着破坏红黑树的规则，所以不需要频繁着调整，这也是我们为什么大多数情况下使用红黑树的原因。\n\n# hashmap key可以为null吗？可以为 null。\n\nhashMap中使用hash()方法来计算key的哈希值，当key为空时，直接另key的哈希值为0，不走key.hashCode()方法；\n\n\n\nhashMap虽然支持key和value为null，但是null作为key只能有一个，null作为value可以有多个；\n因为hashMap中，如果key值一样，那么会覆盖相同key值的value为最新，所以key为null只能有一个。\n\n# 重写HashMap的equal和hashcode方法需要注意什么？HashMap使用Key对象的hashCode()和equals方法去决定key-value对的索引。当我们试着从HashMap中获取值的时候，这些方法也会被用到。如果这些方法没有被正确地实现，在这种情况下，两个不同Key也许会产生相同的hashCode()和equals()输出，HashMap将会认为它们是相同的，然后覆盖它们，而非把它们存储到不同的地方。\n同样的，所有不允许存储重复数据的集合类都使用hashCode()和equals()去查找重复，所以正确实现它们非常重要。equals()和hashCode()的实现应该遵循以下规则：\n\n如果o1.equals(o2)，那么o1.hashCode() &#x3D;&#x3D; o2.hashCode()总是为true的。\n如果o1.hashCode() &#x3D;&#x3D; o2.hashCode()，并不意味着o1.equals(o2)会为true。\n\n# 重写HashMap的equal方法不当会出现什么问题？HashMap在比较元素时，会先通过hashCode进行比较，相同的情况下再通过equals进行比较。\n所以 equals相等的两个对象，hashCode一定相等。hashCode相等的两个对象，equals不一定相等（比如散列冲突的情况）\n重写了equals方法，不重写hashCode方法时，可能会出现equals方法返回为true，而hashCode方法却返回false，这样的一个后果会导致在hashmap等类中存储多个一模一样的对象，导致出现覆盖存储的数据的问题，这与hashmap只能有唯一的key的规范不符合。\n# 列举HashMap在多线程下可能会出现的问题？\nJDK1.7中的 HashMap 使用头插法插入元素，在多线程的环境下，扩容的时候有可能导致环形链表的出现，形成死循环。因此，JDK1.8使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。\n多线程同时执行 put 操作，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。此问题在JDK 1.7和 JDK 1.8 中都存在。\n\n# HashMap的扩容机制介绍一下hashMap默认的负载因子是0.75，即如果hashmap中的元素个数超过了总容量75%，则会触发扩容，扩容分为两个步骤：\n\n第1步是对哈希表长度的扩展（2倍）\n第2步是将旧哈希表中的数据放到新的哈希表中。\n\n因为我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。\n如我们从16扩展为32时，具体的变化如下所示：\n\n因此元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：\n\n因此，我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。可以看看下图为16扩充为32的resize示意图：\n\n这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。\n# HashMap的大小为什么是2的n次方大小呢？在 JDK1.7 中，HashMap 整个扩容过程就是分别取出数组元素，一般该元素是最后一个放入链表中的元素，然后遍历以该元素为头的单向链表元素，依据每个被遍历元素的 hash 值计算其在新数组中的下标，然后进行交换。这样的扩容方式会将原来哈希冲突的单向链表尾部变成扩容后单向链表的头部。\n而在 JDK 1.8 中，HashMap 对扩容操作做了优化。由于扩容数组的长度是 2 倍关系，所以对于假设初始 tableSize &#x3D; 4 要扩容到 8 来说就是 0100 到 1000 的变化（左移一位就是 2 倍），在扩容中只用判断原来的 hash 值和左移动的一位（newtable 的值）按位与操作是 0 或 1 就行，0 的话索引不变，1 的话索引变成原索引加上扩容前数组。\n之所以能通过这种“与运算“来重新分配索引，是因为 hash 值本来就是随机的，而 hash 按位与上 newTable 得到的 0（扩容前的索引位置）和 1（扩容前索引位置加上扩容前数组长度的数值索引处）就是随机的，所以扩容的过程就能把之前哈希冲突的元素再随机分布到不同的索引中去。\n# 往hashmap存20个元素，会扩容几次？当插入 20 个元素时，HashMap 的扩容过程如下：\n初始容量：16\n\n插入第 1 到第 12 个元素时，不需要扩容。\n插入第 13 个元素时，达到负载因子限制，需要扩容。此时，HashMap 的容量从 16 扩容到 32。\n\n扩容后的容量：32\n\n插入第 14 到第 24 个元素时，不需要扩容。\n\n因此，总共会进行一次扩容。\n# 说说hashmap的负载因子HashMap 负载因子 loadFactor 的默认值是 0.75，当 HashMap 中的元素个数超过了容量的 75% 时，就会进行扩容。\n默认负载因子为 0.75，是因为它提供了空间和时间复杂度之间的良好平衡。\n负载因子太低会导致大量的空桶浪费空间，负载因子太高会导致大量的碰撞，降低性能。0.75 的负载因子在这两个因素之间取得了良好的平衡。\n# Hashmap和Hashtable有什么不一样的？Hashmap一般怎么用？\nHashMap线程不安全，效率高一点，可以存储null的key和value，null的key只能有一个，null的value可以有多个。默认初始容量为16，每次扩充变为原来2倍。创建时如果给定了初始容量，则扩充为2的幂次方大小。底层数据结构为数组+链表，插入元素后如果链表长度大于阈值（默认为8），先判断数组长度是否小于64，如果小于，则扩充数组，反之将链表转化为红黑树，以减少搜索时间。\nHashTable线程安全，效率低一点，其内部方法基本都经过synchronized修饰，不可以有null的key和value。默认初始容量为11，每次扩容变为原来的2n+1。创建时给定了初始容量，会直接用给定的大小。底层数据结构为数组+链表。它基本被淘汰了，要保证线程安全可以用ConcurrentHashMap。\n怎么用：HashMap主要用来存储键值对，可以调用put方法向其中加入元素，调用get方法获取某个键对应的值，也可以通过containsKey方法查看某个键是否存在等\n\n# ConcurrentHashMap怎么实现的？\n\n\n\n\n\n\n\n\nJDK 1.7 ConcurrentHashMap\n在 JDK 1.7 中它使用的是数组加链表的形式实现的，而数组又分为：大数组 Segment 和小数组 HashEntry。 Segment 是一种可重入锁（ReentrantLock），在 ConcurrentHashMap 里扮演锁的角色；HashEntry 则用于存储键值对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组，一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素。\n\nJDK 1.7 ConcurrentHashMap 分段锁技术将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，能够实现真正的并发访问。\n\n\n\n\n\n\n\n\n\nJDK 1.8 ConcurrentHashMap\n在 JDK 1.7 中，ConcurrentHashMap 虽然是线程安全的，但因为它的底层实现是数组 + 链表的形式，所以在数据比较多的情况下访问是很慢的，因为要遍历整个链表，而 JDK 1.8 则使用了数组 + 链表&#x2F;红黑树的方式优化了 ConcurrentHashMap 的实现，具体实现结构如下：\n\nJDK 1.8 ConcurrentHashMap JDK 1.8 ConcurrentHashMap 主要通过 volatile + CAS 或者 synchronized 来实现的线程安全的。添加元素时首先会判断容器是否为空：\n\n如果为空则使用 volatile 加 CAS 来初始化\n如果容器不为空，则根据存储的元素计算该位置是否为空。\n如果根据存储的元素计算结果为空，则利用 CAS 设置该节点；\n如果根据存储的元素计算结果不为空，则使用 synchronized ，然后，遍历桶中的数据，并替换或新增节点到桶中，最后再判断是否需要转为红黑树，这样就能保证并发访问时的线程安全了。\n\n\n\n如果把上面的执行用一句话归纳的话，就相当于是ConcurrentHashMap通过对头结点加锁来保证线程安全的，锁的粒度相比 Segment 来说更小了，发生冲突和加锁的频率降低了，并发操作的性能就提高了。\n而且 JDK 1.8 使用的是红黑树优化了之前的固定链表，那么当数据量比较大的时候，查询性能也得到了很大的提升，从之前的 O(n) 优化到了 O(logn) 的时间复杂度。\n# 分段锁怎么加锁的？在 ConcurrentHashMap 中，将整个数据结构分为多个 Segment，每个 Segment 都类似于一个小的 HashMap，每个 Segment 都有自己的锁，不同 Segment 之间的操作互不影响，从而提高并发性能。\n在 ConcurrentHashMap 中，对于插入、更新、删除等操作，需要先定位到具体的 Segment，然后再在该 Segment 上加锁，而不是像传统的 HashMap 一样对整个数据结构加锁。这样可以使得不同 Segment 之间的操作并行进行，提高了并发性能。\n# 分段锁是可重入的吗？JDK 1.7 ConcurrentHashMap中的分段锁是用了 ReentrantLock，是一个可重入的锁。\n# 已经用了synchronized，为什么还要用CAS呢？ConcurrentHashMap使用这两种手段来保证线程安全主要是一种权衡的考虑，在某些操作中使用synchronized，还是使用CAS，主要是根据锁竞争程度来判断的。\n比如：在putVal中，如果计算出来的hash槽没有存放元素，那么就可以直接使用CAS来进行设置值，这是因为在设置元素的时候，因为hash值经过了各种扰动后，造成hash碰撞的几率较低，那么我们可以预测使用较少的自旋来完成具体的hash落槽操作。\n当发生了hash碰撞的时候说明容量不够用了或者已经有大量线程访问了，因此这时候使用synchronized来处理hash碰撞比CAS效率要高，因为发生了hash碰撞大概率来说是线程竞争比较强烈。\n# ConcurrentHashMap用了悲观锁还是乐观锁?悲观锁和乐观锁都有用到。\n添加元素时首先会判断容器是否为空：\n\n如果为空则使用 volatile 加 CAS （乐观锁） 来初始化。\n\n如果容器不为空，则根据存储的元素计算该位置是否为空。\n\n如果根据存储的元素计算结果为空，则利用 CAS（乐观锁） 设置该节点；\n\n如果根据存储的元素计算结果不为空，则使用 synchronized（悲观锁） ，然后，遍历桶中的数据，并替换或新增节点到桶中，最后再判断是否需要转为红黑树，这样就能保证并发访问时的线程安全了。\n\n\n# HashTable 底层实现原理是什么？\n\nHashtable的底层数据结构主要是数组加上链表，数组是主体，链表是解决hash冲突存在的。\nHashTable是线程安全的，实现方式是Hashtable的所有公共方法均采用synchronized关键字，当一个线程访问同步方法，另一个线程也访问的时候，就会陷入阻塞或者轮询的状态。\n\n# HashTable线程安全是怎么实现的？因为它的put，get做成了同步方法，保证了Hashtable的线程安全性，每个操作数据的方法都进行同步控制之后，由此带来的问题任何一个时刻只能有一个线程可以操纵Hashtable，所以其效率比较低。\nHashtable 的 put(K key, V value) 和 get(Object key) 方法的源码：\n123456789101112131415161718192021222324252627282930313233public synchronized V put(K key, V value) &#123;// Make sure the value is not nullif (value == null) &#123;    throw new NullPointerException();&#125; // Makes sure the key is not already in the hashtable.Entry&lt;?,?&gt; tab[] = table;int hash = key.hashCode();int index = (hash &amp; 0x7FFFFFFF) % tab.length;@SuppressWarnings(&quot;unchecked&quot;)Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];for(; entry != null ; entry = entry.next) &#123;    if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;        V old = entry.value;        entry.value = value;        return old;    &#125;&#125; addEntry(hash, key, value, index);return null;&#125;public synchronized V get(Object key) &#123;Entry&lt;?,?&gt; tab[] = table;int hash = key.hashCode();int index = (hash &amp; 0x7FFFFFFF) % tab.length;for (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) &#123;    if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;        return (V)e.value;    &#125;&#125;return null;&#125;\n\n可以看到，Hashtable是通过使用了 synchronized 关键字来保证其线程安全。\n在Java中，可以使用synchronized关键字来标记一个方法或者代码块，当某个线程调用该对象的synchronized方法或者访问synchronized代码块时，这个线程便获得了该对象的锁，其他线程暂时无法访问这个方法，只有等待这个方法执行完毕或者代码块执行完毕，这个线程才会释放该对象的锁，其他线程才能执行这个方法或者代码块。\n# hashtable 和concurrentHashMap有什么区别底层数据结构：\n\njdk7之前的ConcurrentHashMap底层采用的是分段的数组+链表实现，jdk8之后采用的是数组+链表&#x2F;红黑树；\nHashTable采用的是数组+链表，数组是主体，链表是解决hash冲突存在的。\n\n实现线程安全的方式：\n\njdk8以前，ConcurrentHashMap采用分段锁，对整个数组进行了分段分割，每一把锁只锁容器里的一部分数据，多线程访问不同数据段里的数据，就不会存在锁竞争，提高了并发访问；jdk8以后，直接采用数组+链表&#x2F;红黑树，并发控制使用CAS和synchronized操作，更加提高了速度。\nHashTable：所有的方法都加了锁来保证线程安全，但是效率非常的低下，当一个线程访问同步方法，另一个线程也访问的时候，就会陷入阻塞或者轮询的状态。\n\n# 说一下HashMap和Hashtable、ConcurrentMap的区别\nHashMap线程不安全，效率高一点，可以存储null的key和value，null的key只能有一个，null的value可以有多个。默认初始容量为16，每次扩充变为原来2倍。创建时如果给定了初始容量，则扩充为2的幂次方大小。底层数据结构为数组+链表，插入元素后如果链表长度大于阈值（默认为8），先判断数组长度是否小于64，如果小于，则扩充数组，反之将链表转化为红黑树，以减少搜索时间。\nHashTable线程安全，效率低一点，其内部方法基本都经过synchronized修饰，不可以有null的key和value。默认初始容量为11，每次扩容变为原来的2n+1。创建时给定了初始容量，会直接用给定的大小。底层数据结构为数组+链表。它基本被淘汰了，要保证线程安全可以用ConcurrentHashMap。\nConcurrentHashMap是Java中的一个线程安全的哈希表实现，它可以在多线程环境下并发地进行读写操作，而不需要像传统的HashTable那样在读写时加锁。ConcurrentHashMap的实现原理主要基于分段锁和CAS操作。它将整个哈希表分成了多Segment（段），每个Segment都类似于一个小的HashMap，它拥有自己的数组和一个独立的锁。在ConcurrentHashMap中，读操作不需要锁，可以直接对Segment进行读取，而写操作则只需要锁定对应的Segment，而不是整个哈希表，这样可以大大提高并发性能。\n\n# Set# Set集合有什么特点？如何实现key无重复的？\nset集合特点：Set集合中的元素是唯一的，不会出现重复的元素。\nset实现原理：Set集合通过内部的数据结构（如哈希表、红黑树等）来实现key的无重复。当向Set集合中插入元素时，会先根据元素的hashCode值来确定元素的存储位置，然后再通过equals方法来判断是否已经存在相同的元素，如果存在则不会再次插入，保证了元素的唯一性。\n\n# 有序的Set是什么？记录插入顺序的集合是什么？\n有序的 Set 是TreeSet和LinkedHashSet。TreeSet是基于红黑树实现，保证元素的自然顺序。LinkedHashSet是基于双重链表和哈希表的结合来实现元素的有序存储，保证元素添加的自然顺序\n记录插入顺序的集合通常指的是LinkedHashSet，它不仅保证元素的唯一性，还可以保持元素的插入顺序。当需要在Set集合中记录元素的插入顺序时，可以选择使用LinkedHashSet来实现。\n\n\n","slug":"java集合/Java集合面试题","date":"2024-12-03T17:46:32.000Z","categories_index":"八股","tags_index":"java,精选,java集合","author_index":"Ivan"},{"id":"556da6649af123abe80f5a17d5a2547b","title":"并发常见面试题","content":"# Java并发编程面试题# 多线程# java里面的线程和操作系统的线程一样吗？Java 底层会调用 pthread_create 来创建线程，所以本质上 java 程序创建的线程，就是和操作系统线程是一样的，是 1 对 1 的线程模型。\n\n# 使用多线程要注意哪些问题？要保证多线程的允许是安全，不要出现数据竞争造成的数据混乱的问题。\nJava的线程安全在三个方面体现：\n\n原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，在Java中使用了atomic和synchronized这两个关键字来确保原子性；\n可见性：一个线程对主内存的修改可以及时地被其他线程看到，在Java中使用了synchronized和volatile这两个关键字确保可见性；\n有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，在Java中使用了happens-before原则来确保有序性。\n\n# 保证数据的一致性有哪些方案呢？\n事务管理：使用数据库事务来确保一组数据库操作要么全部成功提交，要么全部失败回滚。通过ACID（原子性、一致性、隔离性、持久性）属性，数据库事务可以保证数据的一致性。\n锁机制：使用锁来实现对共享资源的互斥访问。在 Java 中，可以使用 synchronized 关键字、ReentrantLock 或其他锁机制来控制并发访问，从而避免并发操作导致数据不一致。\n版本控制：通过乐观锁的方式，在更新数据时记录数据的版本信息，从而避免同时对同一数据进行修改，进而保证数据的一致性。\n\n# 线程的创建方式有哪些?\n\n\n\n\n\n\n\n\n1.继承Thread类\n这是最直接的一种方式，用户自定义类继承java.lang.Thread类，重写其run()方法，run()方法中定义了线程执行的具体任务。创建该类的实例后，通过调用start()方法启动线程。\n1234567891011class MyThread extends Thread &#123;    @Override    public void run() &#123;        // 线程执行的代码    &#125;&#125;public static void main(String[] args) &#123;    MyThread t = new MyThread();    t.start();&#125;\n\n采用继承Thread类方式\n\n优点: 编写简单，如果需要访问当前线程，无需使用Thread.currentThread ()方法，直接使用this，即可获得当前线程\n缺点:因为线程类已经继承了Thread类，所以不能再继承其他的父类\n\n\n\n\n\n\n\n\n\n\n2.实现Runnable接口\n如果一个类已经继承了其他类，就不能再继承Thread类，此时可以实现java.lang.Runnable接口。实现Runnable接口需要重写run()方法，然后将此Runnable对象作为参数传递给Thread类的构造器，创建Thread对象后调用其start()方法启动线程。\n1234567891011class MyRunnable implements Runnable &#123;    @Override    public void run() &#123;        // 线程执行的代码    &#125;&#125;public static void main(String[] args) &#123;    Thread t = new Thread(new MyRunnable());    t.start();&#125;\n\n采用实现Runnable接口方式：\n\n优点：线程类只是实现了Runable接口，还可以继承其他的类。在这种方式下，可以多个线程共享同一个目标对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。\n缺点：编程稍微复杂，如果需要访问当前线程，必须使用Thread.currentThread()方法。\n\n\n\n\n\n\n\n\n\n\n\n实现Callable接口与FutureTask\n\njava.util.concurrent.Callable接口类似于Runnable，但Callable的call()方法可以有返回值并且可以抛出异常。要执行Callable任务，需将它包装进一个FutureTask，因为Thread类的构造器只接受Runnable参数，而FutureTask实现了Runnable接口。\n123456789101112131415161718192021class MyCallable implements Callable&lt;Integer&gt; &#123;    @Override    public Integer call() throws Exception &#123;        // 线程执行的代码，这里返回一个整型结果        return 1;    &#125;&#125;public static void main(String[] args) &#123;    MyCallable task = new MyCallable();    FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(task);    Thread t = new Thread(futureTask);    t.start();    try &#123;        Integer result = futureTask.get();  // 获取线程执行结果        System.out.println(&quot;Result: &quot; + result);    &#125; catch (InterruptedException | ExecutionException e) &#123;        e.printStackTrace();    &#125;&#125;\n\n采用实现Callable接口方式：\n\n缺点：编程稍微复杂，如果需要访问当前线程，必须调用Thread.currentThread()方法。\n优点：线程只是实现Runnable或实现Callable接口，还可以继承其他类。这种方式下，多个线程可以共享一个target对象，非常适合多线程处理同一份资源的情形。\n\n\n\n\n\n\n\n\n\n\n\n使用线程池（Executor框架）\n\n从Java 5开始引入的java.util.concurrent.ExecutorService和相关类提供了线程池的支持，这是一种更高效的线程管理方式，避免了频繁创建和销毁线程的开销。可以通过Executors类的静态方法创建不同类型的线程池。\n1234567891011121314class Task implements Runnable &#123;    @Override    public void run() &#123;        // 线程执行的代码    &#125;&#125;public static void main(String[] args) &#123;    ExecutorService executor = Executors.newFixedThreadPool(10);  // 创建固定大小的线程池    for (int i = 0; i &lt; 100; i++) &#123;        executor.submit(new Task());  // 提交任务到线程池执行    &#125;    executor.shutdown();  // 关闭线程池&#125;\n\n采用线程池方式：\n\n缺点：程池增加了程序的复杂度，特别是当涉及线程池参数调整和故障排查时。错误的配置可能导致死锁、资源耗尽等问题，这些问题的诊断和修复可能较为复杂。\n优点：线程池可以重用预先创建的线程，避免了线程创建和销毁的开销，显著提高了程序的性能。对于需要快速响应的并发请求，线程池可以迅速提供线程来处理任务，减少等待时间。并且，线程池能够有效控制运行的线程数量，防止因创建过多线程导致的系统资源耗尽（如内存溢出）。通过合理配置线程池大小，可以最大化CPU利用率和系统吞吐量。\n\n# 怎么启动线程 ？启动线程的通过Thread类的**start()**。\n12345//创建两个线程，用start启动线程MyThread myThread1 = new MyThread();  MyThread myThread2 = new MyThread();  myThread1.start();  myThread2.start();  \n\n# 如何停止一个线程的运行?主要有这些方法：\n\n异常法停止：线程调用interrupt()方法后，在线程的run方法中判断当前对象的interrupted()状态，如果是中断状态则抛出异常，达到中断线程的效果。\n在沉睡中停止：先将线程sleep，然后调用interrupt标记中断状态，interrupt会将阻塞状态的线程中断。会抛出中断异常，达到停止线程的效果\nstop()暴力停止：线程调用stop()方法会被暴力停止，方法已弃用，该方法会有不好的后果：强制让线程停止有可能使一些请理性的工作得不到完成。\n使用return停止线程：调用interrupt标记为中断状态后，在run方法中判断当前线程状态，如果为中断状态则return，能达到停止线程的效果。\n\n# 调用 interrupt 是如何让线程抛出异常的?每个线程都一个与之关联的布尔属性来表示其中断状态，中断状态的初始值为false，当一个线程被其它线程调用Thread.interrupt()方法中断时，会根据实际情况做出响应。\n\n如果该线程正在执行低级别的可中断方法（如Thread.sleep()、Thread.join()或Object.wait()），则会解除阻塞并抛出InterruptedException异常。\n否则Thread.interrupt()仅设置线程的中断状态，在该被中断的线程中稍后可通过轮询中断状态来决定是否要停止当前正在执行的任务。\n\n# Java线程的状态有哪些？\n源自《Java并发编程艺术》 java.lang.Thread.State枚举类中定义了六种线程的状态，可以调用线程Thread中的getState()方法获取当前线程的状态。\n\n\n\n线程状态\n解释\n\n\n\nNEW\n尚未启动的线程状态，即线程创建，还未调用start方法\n\n\nRUNNABLE\n就绪状态（调用start，等待调度）+正在运行\n\n\nBLOCKED\n等待监视器锁时，陷入阻塞状态\n\n\nWAITING\n等待状态的线程正在等待另一线程执行特定的操作（如notify）\n\n\nTIMED_WAITING\n具有指定等待时间的等待状态\n\n\nTERMINATED\n线程完成执行，终止状态\n\n\n# blocked和waiting有啥区别\n触发条件:线程进入BLOCKED状态通常是因为试图获取一个对象的锁（monitor lock），但该锁已经被另一个线程持有。这通常发生在尝试进入synchronized块或方法时，如果锁已被占用，则线程将被阻塞直到锁可用。线程进入WAITING状态是因为它正在等待另一个线程执行某些操作，例如调用Object.wait()方法、Thread.join()方法或LockSupport.park()方法。在这种状态下，线程将不会消耗CPU资源，并且不会参与锁的竞争。\n唤醒机制:当一个线程被阻塞等待锁时，一旦锁被释放，线程将有机会重新尝试获取锁。如果锁此时未被其他线程获取，那么线程可以从BLOCKED状态变为RUNNABLE状态。线程在WAITING状态中需要被显式唤醒。例如，如果线程调用了Object.wait()，那么它必须等待另一个线程调用同一对象上的Object.notify()或Object.notifyAll()方法才能被唤醒。\n\n# wait 状态下的线程如何进行恢复到 running 状态?\n等待的线程被其他线程对象唤醒，notify()和notifyAll()。\n如果线程没有获取到锁则会直接进入 Waiting 状态，其实这种本质上它就是执行了 LockSupport.park() 方法进入了Waiting 状态，那么解锁的时候会执行LockSupport.unpark(Thread)，与上面park方法对应，给出许可证，解除等待状态。\n\n# notify 和 notifyAll 的区别?同样是唤醒等待的线程，同样最多只有一个线程能获得锁，同样不能控制哪个线程获得锁。\n区别在于：\n\nnotify：唤醒一个线程，其他线程依然处于wait的等待唤醒状态，如果被唤醒的线程结束时没调用notify，其他线程就永远没人去唤醒，只能等待超时，或者被中断\nnotifyAll：所有线程退出wait的状态，开始竞争锁，但只有一个线程能抢到，这个线程执行完后，其他线程又会有一个幸运儿脱颖而出得到锁\n\n# notify 选择哪个线程?notify在源码的注释中说到notify选择唤醒的线程是任意的，但是依赖于具体实现的jvm。\n\nJVM有很多实现，比较流行的就是hotspot，hotspot对notofy()的实现并不是我们以为的随机唤醒,，而是“先进先出”的顺序唤醒。\n# 并发安全# 怎么保证多线程安全？\nsynchronized关键字:可以使用synchronized关键字来同步代码块或方法，确保同一时刻只有一个线程可以访问这些代码。对象锁是通过synchronized关键字锁定对象的监视器（monitor）来实现的。\n\n1234567public synchronized void someMethod() &#123; /* ... */ &#125;public void anotherMethod() &#123;    synchronized (someObject) &#123;        /* ... */    &#125;&#125;\n\n\nvolatile关键字:volatile关键字用于变量，确保所有线程看到的是该变量的最新值，而不是可能存储在本地寄存器中的副本。\n\n1public volatile int sharedVariable;\n\n\nLock接口和ReentrantLock类:java.util.concurrent.locks.Lock接口提供了比synchronized更强大的锁定机制，ReentrantLock是一个实现该接口的例子，提供了更灵活的锁管理和更高的性能。\n\n12345678910private final ReentrantLock lock = new ReentrantLock();public void someMethod() &#123;    lock.lock();    try &#123;        /* ... */    &#125; finally &#123;        lock.unlock();    &#125;&#125;\n\n\n原子类：Java并发库（java.util.concurrent.atomic）提供了原子类，如AtomicInteger、AtomicLong等，这些类提供了原子操作，可以用于更新基本类型的变量而无需额外的同步。\n\n示例：\n123AtomicInteger counter = new AtomicInteger(0);int newValue = counter.incrementAndGet();\n\n\n线程局部变量:ThreadLocal类可以为每个线程提供独立的变量副本，这样每个线程都拥有自己的变量，消除了竞争条件。\n\n1234ThreadLocal&lt;Integer&gt; threadLocalVar = new ThreadLocal&lt;&gt;();threadLocalVar.set(10);int value = threadLocalVar.get();\n\n\n并发集合:使用java.util.concurrent包中的线程安全集合，如ConcurrentHashMap、ConcurrentLinkedQueue等，这些集合内部已经实现了线程安全的逻辑。\nJUC工具类: 使用java.util.concurrent包中的一些工具类可以用于控制线程间的同步和协作。例如：Semaphore和CyclicBarrier等。\n\n# Java中有哪些常用的锁，在什么场景下使用？ava中的锁是用于管理多线程并发访问共享资源的关键机制。锁可以确保在任意给定时间内只有一个线程可以访问特定的资源，从而避免数据竞争和不一致性。Java提供了多种锁机制，可以分为以下几类：\n\n内置锁（synchronized）：Java中的synchronized关键字是内置锁机制的基础，可以用于方法或代码块。当一个线程进入synchronized代码块或方法时，它会获取关联对象的锁；当线程离开该代码块或方法时，锁会被释放。如果其他线程尝试获取同一个对象的锁，它们将被阻塞，直到锁被释放。其中，syncronized加锁时有无锁、偏向锁、轻量级锁和重量级锁几个级别。偏向锁用于当一个线程进入同步块时，如果没有任何其他线程竞争，就会使用偏向锁，以减少锁的开销。轻量级锁使用线程栈上的数据结构，避免了操作系统级别的锁。重量级锁则涉及操作系统级的互斥锁。\nReentrantLock：java.util.concurrent.locks.ReentrantLock是一个显式的锁类，提供了比synchronized更高级的功能，如可中断的锁等待、定时锁等待、公平锁选项等。ReentrantLock使用lock()和unlock()方法来获取和释放锁。其中，公平锁按照线程请求锁的顺序来分配锁，保证了锁分配的公平性，但可能增加锁的等待时间。非公平锁不保证锁分配的顺序，可以减少锁的竞争，提高性能，但可能造成某些线程的饥饿。\n读写锁（ReadWriteLock）：java.util.concurrent.locks.ReadWriteLock接口定义了一种锁，允许多个读取者同时访问共享资源，但只允许一个写入者。读写锁通常用于读取远多于写入的情况，以提高并发性。\n乐观锁和悲观锁：悲观锁（Pessimistic Locking）通常指在访问数据前就锁定资源，假设最坏的情况，即数据很可能被其他线程修改。synchronized和ReentrantLock都是悲观锁的例子。乐观锁（Optimistic Locking）通常不锁定资源，而是在更新数据时检查数据是否已被其他线程修改。乐观锁常使用版本号或时间戳来实现。\n自旋锁：自旋锁是一种锁机制，线程在等待锁时会持续循环检查锁是否可用，而不是放弃CPU并阻塞。通常可以使用CAS来实现。这在锁等待时间很短的情况下可以提高性能，但过度自旋会浪费CPU资源。\n\n# 怎么在实践中用锁的？Java提供了多种锁的实现，包括synchronized关键字、java.util.concurrent.locks包下的Lock接口及其具体实现如ReentrantLock、ReadWriteLock等。下面我们来看看这些锁的使用方式。\n\n\n\n\n\n\n\n\n\n\nsynchronized\n\nsynchronized关键字可以用于方法或代码块，它是Java中最早的锁实现，使用起来非常简单。\n示例：synchronized方法\n1234567891011public class Counter &#123;    private int count = 0;    public synchronized void increment() &#123;        count++;    &#125;    public synchronized int getCount() &#123;        return count;    &#125;&#125;\n\n示例：synchronized代码块\n12345678910public class Counter &#123;    private Object lock = new Object();    private int count = 0;    public void increment() &#123;        synchronized (lock) &#123;            count++;        &#125;    &#125;&#125;\n\n\n\n\n\n\n\n\n\n\n\n使用Lock接口\n\nLock接口提供了比synchronized更灵活的锁操作，包括尝试锁、可中断锁、定时锁等。ReentrantLock是Lock接口的一个实现。\n示例：使用ReentrantLock\n12345678910111213141516import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class Counter &#123;    private Lock lock = new ReentrantLock();    private int count = 0;    public void increment() &#123;        lock.lock();        try &#123;            count++;        &#125; finally &#123;            lock.unlock();        &#125;    &#125;&#125;\n\n\n\n\n\n\n\n\n\n\n\n使用ReadWriteLock\n\nReadWriteLock接口提供了一种读写锁的实现，允许多个读操作同时进行，但写操作是独占的。\n示例：使用ReadWriteLock\n12345678910111213141516171819202122232425262728import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReadWriteLock;import java.util.concurrent.locks.ReentrantReadWriteLock;public class Cache &#123;    private ReadWriteLock lock = new ReentrantReadWriteLock();    private Lock readLock = lock.readLock();    private Lock writeLock = lock.writeLock();    private Object data;    public Object readData() &#123;        readLock.lock();        try &#123;            return data;        &#125; finally &#123;            readLock.unlock();        &#125;    &#125;    public void writeData(Object newData) &#123;        writeLock.lock();        try &#123;            data = newData;        &#125; finally &#123;            writeLock.unlock();        &#125;    &#125;&#125;\n\n# synchronized和reentrantlock及其应用场景？\n\n\n\n\n\n\n\n\nsynchronized 工作原理\nsynchronized是Java提供的原子性内置锁，这种内置的并且使用者看不到的锁也被称为监视器锁，\n使用synchronized之后，会在编译之后在同步的代码块前后加上monitorenter和monitorexit字节码指令，他依赖操作系统底层互斥锁实现。他的作用主要就是实现原子性操作和解决共享变量的内存可见性问题。\n执行monitorenter指令时会尝试获取对象锁，如果对象没有被锁定或者已经获得了锁，锁的计数器+1。此时其他竞争锁的线程则会进入等待队列中。执行monitorexit指令时则会把计数器-1，当计数器值为0时，则锁释放，处于等待队列中的线程再继续竞争锁。\nsynchronized是排它锁，当一个线程获得锁之后，其他线程必须等待该线程释放锁后才能获得锁，而且由于Java中的线程和操作系统原生线程是一一对应的，线程被阻塞或者唤醒时时会从用户态切换到内核态，这种转换非常消耗性能。\n从内存语义来说，加锁的过程会清除工作内存中的共享变量，再从主内存读取，而释放锁的过程则是将工作内存中的共享变量写回主内存。\n实际上大部分时候我认为说到monitorenter就行了，但是为了更清楚的描述，还是再具体一点。\n如果再深入到源码来说，synchronized实际上有两个队列waitSet和entryList。\n\n当多个线程进入同步代码块时，首先进入entryList\n有一个线程获取到monitor锁后，就赋值给当前线程，并且计数器+1\n如果线程调用wait方法，将释放锁，当前线程置为null，计数器-1，同时进入waitSet等待被唤醒，调用notify或者notifyAll之后又会进入entryList竞争锁\n如果线程执行完毕，同样释放锁，计数器-1，当前线程置为null\n\n\n\n\n\n\n\n\n\n\nreentrantlock工作原理\nReentrantLock 的底层实现主要依赖于 AbstractQueuedSynchronizer（AQS）这个抽象类。AQS 是一个提供了基本同步机制的框架，其中包括了队列、状态值等。\nReentrantLock 在 AQS 的基础上通过内部类 Sync 来实现具体的锁操作。不同的 Sync 子类实现了公平锁和非公平锁的不同逻辑：\n\n可中断性： ReentrantLock 实现了可中断性，这意味着线程在等待锁的过程中，可以被其他线程中断而提前结束等待。在底层，ReentrantLock 使用了与 LockSupport.park() 和 LockSupport.unpark() 相关的机制来实现可中断性。\n设置超时时间： ReentrantLock 支持在尝试获取锁时设置超时时间，即等待一定时间后如果还未获得锁，则放弃锁的获取。这是通过内部的 tryAcquireNanos 方法来实现的。\n公平锁和非公平锁： 在直接创建 ReentrantLock 对象时，默认情况下是非公平锁。公平锁是按照线程等待的顺序来获取锁，而非公平锁则允许多个线程在同一时刻竞争锁，不考虑它们申请锁的顺序。公平锁可以通过在创建 ReentrantLock 时传入 true 来设置，例如：\n\n1ReentrantLock fairLock = new ReentrantLock(true);\n\n\n多个条件变量： ReentrantLock 支持多个条件变量，每个条件变量可以与一个 ReentrantLock 关联。这使得线程可以更灵活地进行等待和唤醒操作，而不仅仅是基于对象监视器的 wait() 和 notify()。多个条件变量的实现依赖于 Condition 接口，例如：\n\n12345ReentrantLock lock = new ReentrantLock();Condition condition = lock.newCondition();// 使用下面方法进行等待和唤醒condition.await();condition.signal();\n\n\n可重入性： ReentrantLock 支持可重入性，即同一个线程可以多次获得同一把锁，而不会造成死锁。这是通过内部的 holdCount 计数来实现的。当一个线程多次获取锁时，holdCount 递增，释放锁时递减，只有当 holdCount 为零时，其他线程才有机会获取锁。\n\n\n\n\n\n\n\n\n\n\n应用场景的区别\nsynchronized：\n\n简单同步需求： 当你需要对代码块或方法进行简单的同步控制时，synchronized是一个很好的选择。它使用起来简单，不需要额外的资源管理，因为锁会在方法退出或代码块执行完毕后自动释放。\n代码块同步： 如果你想对特定代码段进行同步，而不是整个方法，可以使用synchronized代码块。这可以让你更精细地控制同步的范围，从而减少锁的持有时间，提高并发性能。\n内置锁的使用： synchronized关键字使用对象的内置锁（也称为监视器锁），这在需要使用对象作为锁对象的情况下很有用，尤其是在对象状态与锁保护的代码紧密相关时。\n\nReentrantLock：\n\n高级锁功能需求： ReentrantLock提供了synchronized所不具备的高级功能，如公平锁、响应中断、定时锁尝试、以及多个条件变量。当你需要这些功能时，ReentrantLock是更好的选择。\n性能优化： 在高度竞争的环境中，ReentrantLock可以提供比synchronized更好的性能，因为它提供了更细粒度的控制，如尝试锁定和定时锁定，可以减少线程阻塞的可能性。\n复杂同步结构： 当你需要更复杂的同步结构，如需要多个条件变量来协调线程之间的通信时，ReentrantLock及其配套的Condition对象可以提供更灵活的解决方案。\n\n综上，synchronized适用于简单同步需求和不需要额外锁功能的场景，而ReentrantLock适用于需要更高级锁功能、性能优化或复杂同步逻辑的情况。选择哪种同步机制取决于具体的应用需求和性能考虑。\n# synchronized和reentrantlock区别？synchronized 和 ReentrantLock 都是 Java 中提供的可重入锁：\n\n用法不同：synchronized 可用来修饰普通方法、静态方法和代码块，而 ReentrantLock 只能用在代码块上。\n获取锁和释放锁方式不同：synchronized 会自动加锁和释放锁，当进入 synchronized 修饰的代码块之后会自动加锁，当离开 synchronized 的代码段之后会自动释放锁。而 ReentrantLock 需要手动加锁和释放锁\n锁类型不同：synchronized 属于非公平锁，而 ReentrantLock 既可以是公平锁也可以是非公平锁。\n响应中断不同：ReentrantLock 可以响应中断，解决死锁的问题，而 synchronized 不能响应中断。\n底层实现不同：synchronized 是 JVM 层面通过监视器实现的，而 ReentrantLock 是基于 AQS 实现的。\n\n# 怎么理解可重入锁？可重入锁是指同一个线程在获取了锁之后，可以再次重复获取该锁而不会造成死锁或其他问题。当一个线程持有锁时，如果再次尝试获取该锁，就会成功获取而不会被阻塞。\nReentrantLock实现可重入锁的机制是基于线程持有锁的计数器。\n\n当一个线程第一次获取锁时，计数器会加1，表示该线程持有了锁。在此之后，如果同一个线程再次获取锁，计数器会再次加1。每次线程成功获取锁时，都会将计数器加1。\n当线程释放锁时，计数器会相应地减1。只有当计数器减到0时，锁才会完全释放，其他线程才有机会获取锁。\n\n这种计数器的设计使得同一个线程可以多次获取同一个锁，而不会造成死锁或其他问题。每次获取锁时，计数器加1；每次释放锁时，计数器减1。只有当计数器减到0时，锁才会完全释放。\nReentrantLock通过这种计数器的方式，实现了可重入锁的机制。它允许同一个线程多次获取同一个锁，并且能够正确地处理锁的获取和释放，避免了死锁和其他并发问题。\n# synchronized 支持重入吗？如何实现的?synchronized是基于原子性的内部锁机制，是可重入的，因此在一个线程调用synchronized方法的同时在其方法体内部调用该对象另一个synchronized方法，也就是说一个线程得到一个对象锁后再次请求该对象锁，是允许的，这就是synchronized的可重入性。\nsynchronized底层是利用计算机系统mutex Lock实现的。每一个可重入锁都会关联一个线程ID和一个锁状态status。\n当一个线程请求方法时，会去检查锁状态。\n\n如果锁状态是0，代表该锁没有被占用，使用CAS操作获取锁，将线程ID替换成自己的线程ID。\n如果锁状态不是0，代表有线程在访问该方法。此时，如果线程ID是自己的线程ID，如果是可重入锁，会将status自增1，然后获取到该锁，进而执行相应的方法；如果是非重入锁，就会进入阻塞队列等待。\n\n在释放锁时，\n\n如果是可重入锁的，每一次退出方法，就会将status减1，直至status的值为0，最后释放该锁。\n如果非可重入锁的，线程退出方法，直接就会释放该锁。\n\n# syncronized锁升级的过程讲一下具体的锁升级的过程是：无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁。\n\n无锁：这是没有开启偏向锁的时候的状态，在JDK1.6之后偏向锁的默认开启的，但是有一个偏向延迟，需要在JVM启动之后的多少秒之后才能开启，这个可以通过JVM参数进行设置，同时是否开启偏向锁也可以通过JVM参数设置。\n偏向锁：这个是在偏向锁开启之后的锁的状态，如果还没有一个线程拿到这个锁的话，这个状态叫做匿名偏向，当一个线程拿到偏向锁的时候，下次想要竞争锁只需要拿线程ID跟MarkWord当中存储的线程ID进行比较，如果线程ID相同则直接获取锁（相当于锁偏向于这个线程），不需要进行CAS操作和将线程挂起的操作。\n轻量级锁：在这个状态下线程主要是通过CAS操作实现的。将对象的MarkWord存储到线程的虚拟机栈上，然后通过CAS将对象的MarkWord的内容设置为指向Displaced Mark Word的指针，如果设置成功则获取锁。在线程出临界区的时候，也需要使用CAS，如果使用CAS替换成功则同步成功，如果失败表示有其他线程在获取锁，那么就需要在释放锁之后将被挂起的线程唤醒。\n重量级锁：当有两个以上的线程获取锁的时候轻量级锁就会升级为重量级锁，因为CAS如果没有成功的话始终都在自旋，进行while循环操作，这是非常消耗CPU的，但是在升级为重量级锁之后，线程会被操作系统调度然后挂起，这可以节约CPU资源。\n\n了解完 4 种锁状态之后，我们就可以整体的来看一下锁升级的过程了。  线程A进入 synchronized 开始抢锁，JVM 会判断当前是否是偏向锁的状态，如果是就会根据 Mark Word 中存储的线程 ID 来判断，当前线程A是否就是持有偏向锁的线程。如果是，则忽略 check，线程A直接执行临界区内的代码。\n但如果 Mark Word 里的线程不是线程 A，就会通过自旋尝试获取锁，如果获取到了，就将 Mark Word 中的线程 ID 改为自己的;如果竞争失败，就会立马撤销偏向锁，膨胀为轻量级锁。\n后续的竞争线程都会通过自旋来尝试获取锁，如果自旋成功那么锁的状态仍然是轻量级锁。然而如果竞争失败，锁会膨胀为重量级锁，后续等待的竞争的线程都会被阻塞。\n# JVM对Synchornized的优化？synchronized 核心优化方案主要包含以下 4 个：\n\n锁膨胀：synchronized 从无锁升级到偏向锁，再到轻量级锁，最后到重量级锁的过程，它叫做锁膨胀也叫做锁升级。JDK 1.6 之前，synchronized 是重量级锁，也就是说 synchronized 在释放和获取锁时都会从用户态转换成内核态，而转换的效率是比较低的。但有了锁膨胀机制之后，synchronized 的状态就多了无锁、偏向锁以及轻量级锁了，这时候在进行并发操作时，大部分的场景都不需要用户态到内核态的转换了，这样就大幅的提升了 synchronized 的性能。\n锁消除：指的是在某些情况下，JVM 虚拟机如果检测不到某段代码被共享和竞争的可能性，就会将这段代码所属的同步锁消除掉，从而到底提高程序性能的目的。\n锁粗化：将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。\n自适应自旋锁：指通过自身循环，尝试获取锁的一种方式，优点在于它避免一些线程的挂起和恢复操作，因为挂起线程和恢复线程都需要从用户态转入内核态，这个过程是比较慢的，所以通过自旋的方式可以一定程度上避免线程挂起和恢复所造成的性能开销。\n\n# 介绍一下AQSAQS全称为AbstractQueuedSynchronizer，是Java中的一个抽象类。 AQS是一个用于构建锁、同步器、协作工具类的工具类（框架）。\nAQS核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。\nCLH：Craig、Landin and Hagersten队列，是单向链表，AQS中的队列是CLH变体的虚拟双向队列（FIFO），AQS是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配。\n主要原理图如下： \nAQS使用一个Volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。\nAQS广泛用于控制并发流程的类，如下图：\n\n其中Sync是这些类中都有的内部类，其结构如下：\n\n可以看到：Sync是AQS的实现。 AQS主要完成的任务：\n\n同步状态（比如说计数器）的原子性管理；\n线程的阻塞和解除阻塞；\n队列的管理。\n\n\n\n\n\n\n\n\n\n\nAQS原理\nAQS最核心的就是三大部分：\n\n状态：state；\n控制线程抢锁和配合的FIFO队列（双向链表）；\n期望协作工具类去实现的获取&#x2F;释放等重要方法（重写）。\n\n状态state\n\n这里state的具体含义，会根据具体实现类的不同而不同：比如在Semapore里，他表示剩余许可证的数量；在CountDownLatch里，它表示还需要倒数的数量；在ReentrantLock中，state用来表示“锁”的占有情况，包括可重入计数，当state的值为0的时候，标识该Lock不被任何线程所占有。\nstate是volatile修饰的，并被并发修改，所以修改state的方法都需要保证线程安全，比如getState、setState以及compareAndSetState操作来读取和更新这个状态。这些方法都依赖于unsafe类。\n\nFIFO队列\n\n这个队列用来存放“等待的线程，AQS就是“排队管理器”，当多个线程争用同一把锁时，必须有排队机制将那些没能拿到锁的线程串在一起。当锁释放时，锁管理器就会挑选一个合适的线程来占有这个刚刚释放的锁。\nAQS会维护一个等待的线程队列，把线程都放到这个队列里，这个队列是双向链表形式。\n\n实现获取&#x2F;释放等方法\n\n这里的获取和释放方法，是利用AQS的协作工具类里最重要的方法，是由协作类自己去实现的，并且含义各不相同；\n获取方法：获取操作会以来state变量，经常会阻塞（比如获取不到锁的时候）。在Semaphore中，获取就是acquire方法，作用是获取一个许可证； 而在CountDownLatch里面，获取就是await方法，作用是等待，直到倒数结束；\n释放方法：在Semaphore中，释放就是release方法，作用是释放一个许可证； 在CountDownLatch里面，获取就是countDown方法，作用是将倒数的数减一；\n需要每个实现类重写tryAcquire和tryRelease等方法。\n\n# Threadlocal作用，原理，具体里面存的key value是啥，会有什么问题，如何解决?ThreadLocal是Java中用于解决线程安全问题的一种机制，它允许创建线程局部变量，即每个线程都有自己独立的变量副本，从而避免了线程间的资源共享和同步问题。\n\n从内存结构图，我们可以看到：\n\nThread类中，有个ThreadLocal.ThreadLocalMap 的成员变量。\nThreadLocalMap内部维护了Entry数组，每个Entry代表一个完整的对象，key是ThreadLocal本身，value是ThreadLocal的泛型对象值。\n\n\n\n\n\n\n\n\n\n\nThreadLocal的作用\n\n线程隔离：ThreadLocal为每个线程提供了独立的变量副本，这意味着线程之间不会相互影响，可以安全地在多线程环境中使用这些变量而不必担心数据竞争或同步问题。\n降低耦合度：在同一个线程内的多个函数或组件之间，使用ThreadLocal可以减少参数的传递，降低代码之间的耦合度，使代码更加清晰和模块化。\n性能优势：由于ThreadLocal避免了线程间的同步开销，所以在大量线程并发执行时，相比传统的锁机制，它可以提供更好的性能。\n\n\n\n\n\n\n\n\n\n\nThreadLocal的原理\nThreadLocal的实现依赖于Thread类中的一个ThreadLocalMap字段，这是一个存储ThreadLocal变量本身和对应值的映射。每个线程都有自己的ThreadLocalMap实例，用于存储该线程所持有的所有ThreadLocal变量的值。\n当你创建一个ThreadLocal变量时，它实际上就是一个ThreadLocal对象的实例。每个ThreadLocal对象都可以存储任意类型的值，这个值对每个线程来说是独立的。\n\n当调用ThreadLocal的get()方法时，ThreadLocal会检查当前线程的ThreadLocalMap中是否有与之关联的值。\n\n如果有，返回该值；\n\n如果没有，会调用initialValue()方法（如果重写了的话）来初始化该值，然后将其放入ThreadLocalMap中并返回。\n\n当调用set()方法时，ThreadLocal会将给定的值与当前线程关联起来，即在当前线程的ThreadLocalMap中存储一个键值对，键是ThreadLocal对象自身，值是传入的值。\n\n当调用remove()方法时，会从当前线程的ThreadLocalMap中移除与该ThreadLocal对象关联的条目。\n\n\n\n\n\n\n\n\n\n\n\n可能存在的问题\n当一个线程结束时，其ThreadLocalMap也会随之销毁，但是ThreadLocal对象本身不会立即被垃圾回收，直到没有其他引用指向它为止。\n因此，在使用ThreadLocal时需要注意，如果不显式调用remove()方法，或者线程结束时未正确清理ThreadLocal变量，可能会导致内存泄漏，因为ThreadLocalMap会持续持有ThreadLocal变量的引用，即使这些变量不再被其他地方引用。\n因此，实际应用中需要在使用完ThreadLocal变量后调用remove()方法释放资源。\n# 悲观锁和乐观锁的区别？\n乐观锁： 就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总 是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。\n悲观锁： 还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总 是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像 synchronized，不管三七二十一，直接上了锁就操作资源了。\n\n# Java中想实现一个乐观锁，都有哪些方式？\nCAS（Compare and Swap）操作： CAS 是乐观锁的基础。Java 提供了 java.util.concurrent.atomic 包，包含各种原子变量类（如 AtomicInteger、AtomicLong），这些类使用 CAS 操作实现了线程安全的原子操作，可以用来实现乐观锁。\n版本号控制：增加一个版本号字段记录数据更新时候的版本，每次更新时递增版本号。在更新数据时，同时比较版本号，若当前版本号和更新前获取的版本号一致，则更新成功，否则失败。\n时间戳：使用时间戳记录数据的更新时间，在更新数据时，在比较时间戳。如果当前时间戳大于数据的时间戳，则说明数据已经被其他线程更新，更新失败。\n\n# CAS 有什么缺点？CAS的缺点主要有3点：\n\nABA问题：ABA的问题指的是在CAS更新的过程中，当读取到的值是A，然后准备赋值的时候仍然是A，但是实际上有可能A的值被改成了B，然后又被改回了A，这个CAS更新的漏洞就叫做ABA。只是ABA的问题大部分场景下都不影响并发的最终效果。Java中有AtomicStampedReference来解决这个问题，他加入了预期标志和更新后标志两个字段，更新时不光检查值，还要检查当前的标志是否等于预期标志，全部相等的话才会更新。\n循环时间长开销大：自旋CAS的方式如果长时间不成功，会给CPU带来很大的开销。\n只能保证一个共享变量的原子操作：只对一个共享变量操作可以保证原子性，但是多个则不行，多个可以通过AtomicReference来处理或者使用锁synchronized实现。\n\n# 为什么不能所有的锁都用CAS？CAS操作是基于循环重试的机制，如果CAS操作一直未能成功，线程会一直自旋重试，占用CPU资源。在高并发情况下，大量线程自旋会导致CPU资源浪费。\n# voliatle关键字有什么作用？volatite作用有 2 个：\n\n保证变量对所有线程的可见性。当一个变量被声明为volatile时，它会保证对这个变量的写操作会立即刷新到主存中，而对这个变量的读操作会直接从主存中读取，从而确保了多线程环境下对该变量访问的可见性。这意味着一个线程修改了volatile变量的值，其他线程能够立刻看到这个修改，不会受到各自线程工作内存的影响。\n\n禁止指令重排序优化。volatile关键字在Java中主要通过内存屏障来禁止特定类型的指令重排序。\n\n1）写-写（Write-Write）屏障：在对volatile变量执行写操作之前，会插入一个写屏障。这确保了在该变量写操作之前的所有普通写操作都已完成，防止了这些写操作被移到volatile写操作之后。\n\n2）读-写（Read-Write）屏障：在对volatile变量执行读操作之后，会插入一个读屏障。它确保了对volatile变量的读操作之后的所有普通读操作都不会被提前到volatile读之前执行，保证了读取到的数据是最新的。\n\n3）写-读（Write-Read）屏障：这是最重要的一个屏障，它发生在volatile写之后和volatile读之前。这个屏障确保了volatile写操作之前的所有内存操作（包括写操作）都不会被重排序到volatile读之后，同时也确保了volatile读操作之后的所有内存操作（包括读操作）都不会被重排序到volatile写之前。\n\n\n\n\n# 指令重排序的原理是什么？在执行程序时，为了提高性能，处理器和编译器常常会对指令进行重排序，但是重排序要满足下面 2 个条件才能进行：\n\n在单线程环境下不能改变程序运行的结果\n存在数据依赖关系的不允许重排序。\n\n所以重排序不会对单线程有影响，只会破坏多线程的执行语义。\n我们看这个例子，A和C之间存在数据依赖关系，同时B和C之间也存在数据依赖关系。因此在最终执行的指令序列中，C不能被重排序到A和B的前面，如果C排到A和B的前面，那么程序的结果将会被改变。但A和B之间没有数据依赖关系，编译器和处理器可以重排序A和B之间的执行顺序。\n\n# volatile可以保证线程安全吗？volatile关键字可以保证可见性，但不能保证原子性，因此不能完全保证线程安全。volatile关键字用于修饰变量，当一个线程修改了volatile修饰的变量的值，其他线程能够立即看到最新的值，从而避免了线程之间的数据不一致。\n但是，volatile并不能解决多线程并发下的复合操作问题，比如i++这种操作不是原子操作，如果多个线程同时对i进行自增操作，volatile不能保证线程安全。对于复合操作，需要使用synchronized关键字或者Lock来保证原子性和线程安全。\n# volatile和sychronized比较？Synchronized解决了多线程访问共享资源时可能出现的竞态条件和数据不一致的问题，保证了线程安全性。Volatile解决了变量在多线程环境下的可见性和有序性问题，确保了变量的修改对其他线程是可见的。\n\nSynchronized: Synchronized是一种排他性的同步机制，保证了多个线程访问共享资源时的互斥性，即同一时刻只允许一个线程访问共享资源。通过对代码块或方法添加Synchronized关键字来实现同步。\nVolatile: Volatile是一种轻量级的同步机制，用来保证变量的可见性和禁止指令重排序。当一个变量被声明为Volatile时，线程在读取该变量时会直接从内存中读取，而不会使用缓存，同时对该变量的写操作会立即刷回主内存，而不是缓存在本地内存中。\n\n# 什么是公平锁和非公平锁？\n公平锁： 指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点在于各个线程公平平等，每个线程等待一段时间后，都有执行的机会，而它的缺点就在于整体执行速度更慢，吞吐量更小。\n非公平锁： 多个线程加锁时直接尝试获取锁，能抢到锁到直接占有锁，抢不到才会到等待队列的队尾等待。非公平锁的优势就在于整体执行速度更快，吞吐量更大，但同时也可能产生线程饥饿问题，也就是说如果一直有线程插队，那么在等待队列中的线程可能长时间得不到运行。\n\n# 非公平锁吞吐量为什么比公平锁大？\n公平锁执行流程：获取锁时，先将线程自己添加到等待队列的队尾并休眠，当某线程用完锁之后，会去唤醒等待队列中队首的线程尝试去获取锁，锁的使用顺序也就是队列中的先后顺序，在整个过程中，线程会从运行状态切换到休眠状态，再从休眠状态恢复成运行状态，但线程每次休眠和恢复都需要从用户态转换成内核态，而这个状态的转换是比较慢的，所以公平锁的执行速度会比较慢。\n非公平锁执行流程：当线程获取锁时，会先通过 CAS 尝试获取锁，如果获取成功就直接拥有锁，如果获取锁失败才会进入等待队列，等待下次尝试获取锁。这样做的好处是，获取锁不用遵循先到先得的规则，从而避免了线程休眠和恢复的操作，这样就加速了程序的执行效率。\n\n# Synchronized是公平锁吗？Synchronized不属于公平锁，ReentrantLock是公平锁。\n# ReentrantLock是怎么实现公平锁的？我们来看一下公平锁与非公平锁的加锁方法的源码。公平锁的锁获取源码如下：\n12345678910111213141516171819202122232425262728protected final boolean tryAcquire(int acquires) &#123;    final Thread current = Thread.currentThread();    int c = getState();    if (c == 0) &#123;        if (!hasQueuedPredecessors() &amp;&amp; //这里判断了 hasQueuedPredecessors()                compareAndSetState(0, acquires)) &#123;                        setExclusiveOwnerThread(current);                        return true;        &#125;    &#125; else if (current == getExclusiveOwnerThread()) &#123;        int nextc = c + acquires;        if (nextc &lt; 0) &#123;            throw new Error(&quot;Maximum lock count exceeded&quot;);        &#125;        setState(nextc);        return true;    &#125;    return false;&#125;\n\n非公平锁的锁获取源码如下：\n12345678910111213141516171819202122232425262728293031323334final boolean nonfairTryAcquire(int acquires) &#123;    final Thread current = Thread.currentThread();    int c = getState();    if (c == 0) &#123;        if (compareAndSetState(0, acquires)) &#123; //这里没有判断      hasQueuedPredecessors()            setExclusiveOwnerThread(current);            return true;        &#125;    &#125;    else if (current == getExclusiveOwnerThread()) &#123;        int nextc = c + acquires;        if (nextc &lt; 0) // overflow        throw new Error(&quot;Maximum lock count exceeded&quot;);        setState(nextc);        return true;    &#125;    return false;&#125;\n\n通过对比，我们可以明显的看出公平锁与非公平锁的 lock() 方法唯一的区别就在于公平锁在获取锁时多了一个限制条件：hasQueuedPredecessors() 为 false，这个方法就是判断在等待队列中是否已经有线程在排队了。\n这也就是公平锁和非公平锁的核心区别，如果是公平锁，那么一旦已经有线程在排队了，当前线程就不再尝试获取锁；对于非公平锁而言，无论是否已经有线程在排队，都会尝试获取一下锁，获取不到的话，再去排队。这里有一个特例需要我们注意，针对 tryLock() 方法，它不遵守设定的公平原则。\n例如，当有线程执行 tryLock() 方法的时候，一旦有线程释放了锁，那么这个正在 tryLock 的线程就能获取到锁，即使设置的是公平锁模式，即使在它之前已经有其他正在等待队列中等待的线程，简单地说就是 tryLock 可以插队。\n看它的源码就会发现：\n12345public boolean tryLock() &#123;    return sync.nonfairTryAcquire(1);&#125;\n\n这里调用的就是 nonfairTryAcquire()，表明了是不公平的，和锁本身是否是公平锁无关。综上所述，公平锁就是会按照多个线程申请锁的顺序来获取锁，从而实现公平的特性。\n非公平锁加锁时不考虑排队等待情况，直接尝试获取锁，所以存在后申请却先获得锁的情况，但由此也提高了整体的效率。\n# 线程池# 介绍一下线程池的工作原理线程池是为了减少频繁的创建线程和销毁线程带来的性能损耗，线程池的工作原理如下图：\n\n线程池分为核心线程池，线程池的最大容量，还有等待任务的队列，提交一个任务，如果核心线程没有满，就创建一个线程，如果满了，就是会加入等待队列，如果等待队列满了，就会增加线程，如果达到最大线程数量，如果都达到最大线程数量，就会按照一些丢弃的策略进行处理。\n# 线程池的参数有哪些？线程池的构造函数有7个参数：\n\n\ncorePoolSize：线程池核心线程数量。默认情况下，线程池中线程的数量如果 &lt;&#x3D; corePoolSize，那么即使这些线程处于空闲状态，那也不会被销毁。\nmaximumPoolSize：线程池中最多可容纳的线程数量。当一个新任务交给线程池，如果此时线程池中有空闲的线程，就会直接执行，如果没有空闲的线程且当前线程池的线程数量小于corePoolSize，就会创建新的线程来执行任务，否则就会将该任务加入到阻塞队列中，如果阻塞队列满了，就会创建一个新线程，从阻塞队列头部取出一个任务来执行，并将新任务加入到阻塞队列末尾。如果当前线程池中线程的数量等于maximumPoolSize，就不会创建新线程，就会去执行拒绝策略。\nkeepAliveTime：当线程池中线程的数量大于corePoolSize，并且某个线程的空闲时间超过了keepAliveTime，那么这个线程就会被销毁。\nunit：就是keepAliveTime时间的单位。\nworkQueue：工作队列。当没有空闲的线程执行新任务时，该任务就会被放入工作队列中，等待执行。\nthreadFactory：线程工厂。可以用来给线程取名字等等\nhandler：拒绝策略。当一个新任务交给线程池，如果此时线程池中有空闲的线程，就会直接执行，如果没有空闲的线程，就会将该任务加入到阻塞队列中，如果阻塞队列满了，就会创建一个新线程，从阻塞队列头部取出一个任务来执行，并将新任务加入到阻塞队列末尾。如果当前线程池中线程的数量等于maximumPoolSize，就不会创建新线程，就会去执行拒绝策略\n\n# 线程池工作队列满了有哪些拒接策略？当线程池的任务队列满了之后，线程池会执行指定的拒绝策略来应对，常用的四种拒绝策略包括：CallerRunsPolicy、AbortPolicy、DiscardPolicy、DiscardOldestPolicy，此外，还可以通过实现RejectedExecutionHandler接口来自定义拒绝策略。\n四种预置的拒绝策略：\n\nCallerRunsPolicy，使用线程池的调用者所在的线程去执行被拒绝的任务，除非线程池被停止或者线程池的任务队列已有空缺。\nAbortPolicy，直接抛出一个任务被线程池拒绝的异常。\nDiscardPolicy，不做任何处理，静默拒绝提交的任务。\nDiscardOldestPolicy，抛弃最老的任务，然后执行该任务。\n自定义拒绝策略，通过实现接口可以自定义任务拒绝策略。\n\n# 有线程池参数设置的经验吗？\nCPU密集型：corePoolSize &#x3D; CPU核数 + 1\nIO密集型：corePoolSize &#x3D; CPU核数 * 2\n\n# 核心线程数设置为0可不可以？可以，当核心线程数为0的时候，会创建一个非核心线程进行执行。\n从下面的源码也可以看到，当核心线程数为 0 时，来了一个任务之后，会先将任务添加到任务队列，同时也会判断当前工作的线程数是否为 0，如果为 0，则会创建线程来执行线程池的任务。\n\n# 线程池种类有哪些？\nScheduledThreadPool：可以设置定期的执行任务，它支持定时或周期性执行任务，比如每隔 10 秒钟执行一次任务，我通过这个实现类设置定期执行任务的策略。\nFixedThreadPool：它的核心线程数和最大线程数是一样的，所以可以把它看作是固定线程数的线程池，它的特点是线程池中的线程数除了初始阶段需要从 0 开始增加外，之后的线程数量就是固定的，就算任务数超过线程数，线程池也不会再创建更多的线程来处理任务，而是会把超出线程处理能力的任务放到任务队列中进行等待。而且就算任务队列满了，到了本该继续增加线程数的时候，由于它的最大线程数和核心线程数是一样的，所以也无法再增加新的线程了。\nCachedThreadPool：可以称作可缓存线程池，它的特点在于线程数是几乎可以无限增加的（实际最大可以达到 Integer.MAX_VALUE，为 2^31-1，这个数非常大，所以基本不可能达到），而当线程闲置时还可以对线程进行回收。也就是说该线程池的线程数量不是固定不变的，当然它也有一个用于存储提交任务的队列，但这个队列是 SynchronousQueue，队列的容量为0，实际不存储任何任务，它只负责对任务进行中转和传递，所以效率比较高。\nSingleThreadExecutor：它会使用唯一的线程去执行任务，原理和 FixedThreadPool 是一样的，只不过这里线程只有一个，如果线程在执行任务的过程中发生异常，线程池也会重新创建一个线程来执行后续的任务。这种线程池由于只有一个线程，所以非常适合用于所有任务都需要按被提交的顺序依次执行的场景，而前几种线程池不一定能够保障任务的执行顺序等于被提交的顺序，因为它们是多线程并行执行的。\nSingleThreadScheduledExecutor：它实际和 ScheduledThreadPool 线程池非常相似，它只是 ScheduledThreadPool 的一个特例，内部只有一个线程。\n\n# 线程池一般是怎么用的？Java 中的 Executors 类定义了一些快捷的工具方法，来帮助我们快速创建线程池。《阿里巴巴 Java 开发手册》中提到，禁止使用这些方法来创建线程池，而应该手动 new ThreadPoolExecutor 来创建线程池。这一条规则的背后，是大量血淋淋的生产事故，最典型的就是 newFixedThreadPool 和 newCachedThreadPool，可能因为资源耗尽导致 OOM 问题。\n所以，不建议使用 Executors 提供的两种快捷的线程池，原因如下：\n\n我们需要根据自己的场景、并发情况来评估线程池的几个核心参数，包括核心线程数、最大线程数、线程回收策略、工作队列的类型，以及拒绝策略，确保线程池的工作行为符合需求，一般都需要设置有界的工作队列和可控的线程数。\n任何时候，都应该为自定义线程池指定有意义的名称，以方便排查问题。当出现线程数量暴增、线程死锁、线程占用大量 CPU、线程执行出现异常等问题时，我们往往会抓取线程栈。此时，有意义的线程名称，就可以方便我们定位问题。\n\n除了建议手动声明线程池以外，我还建议用一些监控手段来观察线程池的状态。线程池这个组件往往会表现得任劳任怨、默默无闻，除非是出现了拒绝策略，否则压力再大都不会抛出一个异常。如果我们能提前观察到线程池队列的积压，或者线程数量的快速膨胀，往往可以提早发现并解决问题。\n# 线程池中shutdown ()，shutdownNow()这两个方法有什么作用？从源码【高亮】注释可以很清晰的看出两者的区别：\n\nshutdown使用了以后会置状态为SHUTDOWN，正在执行的任务会继续执行下去，没有被执行的则中断。此时，则不能再往线程池中添加任何任务，否则将会抛出 RejectedExecutionException 异常\n而 shutdownNow 为STOP，并试图停止所有正在执行的线程，不再处理还在池队列中等待的任务，当然，它会返回那些未执行的任务。 它试图终止线程的方法是通过调用 Thread.interrupt() 方法来实现的，但是这种方法的作用有限，如果线程中没有sleep 、wait、Condition、定时锁等应用, interrupt()方法是无法中断当前的线程的。所以，ShutdownNow()并不代表线程池就一定立即就能退出，它可能必须要等待所有正在执行的任务都执行完成了才能退出。\n\nshutdown 源码：\n1234567891011121314public void shutdown() &#123;\tfinal ReentrantLock mainLock = this.mainLock;\tmainLock.lock();\ttry &#123;\t\tcheckShutdownAccess();\t\t// 高亮\t\tadvanceRunState(SHUTDOWN);\t\tinterruptIdleWorkers();\t\tonShutdown();\t&#125; finally &#123;\t\tmainLock.unlock();\t&#125;\ttryTerminate();&#125;\n\nshutdownNow 源码：\n123456789101112131415161718public List&lt;Runnable&gt; shutdownNow() &#123;\tList&lt;Runnable&gt; tasks;\tfinal ReentrantLock mainLock = this.mainLock;\tmainLock.lock();\ttry &#123;\t\tcheckShutdownAccess();\t\t// 高亮\t\tadvanceRunState(STOP);\t\tinterruptWorkers();\t\t// 高亮\t\ttasks = drainQueue();\t&#125; finally &#123;\t\tmainLock.unlock();\t&#125;\ttryTerminate();\t// 高亮\treturn tasks;&#125;\n\n# 提交给线程池中的任务可以被撤回吗？可以，当向线程池提交任务时，会得到一个Future对象。这个Future对象提供了几种方法来管理任务的执行，包括取消任务。\n取消任务的主要方法是Future接口中的cancel(boolean mayInterruptIfRunning)方法。这个方法尝试取消执行的任务。参数mayInterruptIfRunning指示是否允许中断正在执行的任务。如果设置为true，则表示如果任务已经开始执行，那么允许中断任务；如果设置为false，任务已经开始执行则不会被中断。\n12345678910111213public interface Future&lt;V&gt; &#123;    // 是否取消线程的执行    boolean cancel(boolean mayInterruptIfRunning);    // 线程是否被取消    boolean isCancelled();    //线程是否执行完毕    boolean isDone();      // 立即获得线程返回的结果    V get() throws InterruptedException, ExecutionException;      // 延时时间后再获得线程返回的结果    V get(long timeout, TimeUnit unit)        throws InterruptedException, ExecutionException, TimeoutException;&#125;\n\n取消线程池中任务的方式，代码如下，通过 future 对象的 cancel(boolean) 函数来定向取消特定的任务。\n12345678910111213141516public static void main(String[] args) &#123;        ExecutorService service = Executors.newSingleThreadExecutor();        Future future = service.submit(new TheradDemo());        try &#123;          // 可能抛出异常            future.get();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; catch (ExecutionException e) &#123;            e.printStackTrace();        &#125;finally &#123;          //终止任务的执行            future.cancel(true);        &#125; &#125;\n\n# 场景# 多线程打印奇偶数，怎么控制打印的顺序可以利用wait()和notify()来控制线程的执行顺序。\n以下是一个基于这种方法的简单示例：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class PrintOddEven &#123;    private static final Object lock = new Object();    private static int count = 1;    private static final int MAX_COUNT = 10;    public static void main(String[] args) &#123;        Runnable printOdd = () -&gt; &#123;            synchronized (lock) &#123;                while (count &lt;= MAX_COUNT) &#123;                    if (count % 2 != 0) &#123;                        System.out.println(Thread.currentThread().getName() + &quot;: &quot; + count++);                        lock.notify();                    &#125; else &#123;                        try &#123;                            lock.wait();                        &#125; catch (InterruptedException e) &#123;                            e.printStackTrace();                        &#125;                    &#125;                &#125;            &#125;        &#125;;        Runnable printEven = () -&gt; &#123;            synchronized (lock) &#123;                while (count &lt;= MAX_COUNT) &#123;                    if (count % 2 == 0) &#123;                        System.out.println(Thread.currentThread().getName() + &quot;: &quot; + count++);                        lock.notify();                    &#125; else &#123;                        try &#123;                            lock.wait();                        &#125; catch (InterruptedException e) &#123;                            e.printStackTrace();                        &#125;                    &#125;                &#125;            &#125;        &#125;;        Thread oddThread = new Thread(printOdd, &quot;OddThread&quot;);        Thread evenThread = new Thread(printEven, &quot;EvenThread&quot;);        oddThread.start();        evenThread.start();    &#125;&#125;\n\n在上面的示例中，通过一个共享的锁对象lock来控制两个线程的交替执行。一个线程负责打印奇数，另一个线程负责打印偶数，通过wait()和notify()方法来在两个线程之间实现顺序控制。当当前应该打印奇数时，偶数线程会进入等待状态，反之亦然。\n\n","slug":"并发/并发常见面试题（上）","date":"2024-12-03T17:21:45.000Z","categories_index":"八股","tags_index":"java,并发框架,精选","author_index":"Ivan"},{"id":"5bcef49cfc4866658bd7f1721b4f6cb7","title":"反射机制","content":"对于Java的反射机制，精炼一点就是，可以在程序运行时获取类和对象的信息，包括属性和方法。\n反射基础Class类和普通的类没有什么区别，有属性，有方法。\n我们编写的类在被编译后，都会附带一个Class对象，表示创建类的类型信息，被写入在同名的class字节码文件中。\n我们无法手动创建Class类的对象，因为其构造函数是私有化的。\nClass对象的作用是运行时提供某个对象的类型信息。\n反射的使用对于对象，我们的常规操作是什么？\n无非就是new一个对象出来、改变对象的状态（修改属性值）、调用对象方法。\n不过，现在，我们要使用反射机制来完成这些操作。\nClass类对象的获取在类加载的时候，jvm会创建一个class对象。\n获取class对象的三种方式：\n\n类名.class\n对象.getClass()\nClass.forName(全限定类名)\n\n（这里简单演示一下就行了，毕竟平时开发的时候真的很少用这玩意儿啦）\n1234567891011121314151617181920212223242526272829303132333435class Person &#123;    private String name;    private int age;    public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    private void sayHello()&#123;        System.out.println(&quot;hello&quot;);    &#125;    @Override    public String toString() &#123;        return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;    &#125;&#125;\n\n创建一个新的对象：\n12345678public class Test &#123;    public static void main(String[] args) throws NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException &#123;       Constructor&lt;Person&gt; constructor = Person.class.getDeclaredConstructor(String.class,int.class);       Person person = constructor.newInstance(&quot;kaiven&quot;,20);       System.out.println(person);    &#125;&#125;\n\n改变对象的状态：\n1234567891011public class Test &#123;    public static void main(String[] args) throws NoSuchMethodException, SecurityException, InstantiationException,            IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchFieldException &#123;        Person person = new Person(&quot;kaiven&quot;, 20);        Field namField = person.getClass().getDeclaredField(&quot;name&quot;);        namField.setAccessible(true);        namField.set(person, &quot;lucy&quot;);        System.out.println(person.getName());    &#125;&#125;\n\n调用对象方法：\n12345678910public class Test &#123;    public static void main(String[] args) throws NoSuchMethodException, SecurityException, InstantiationException,            IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchFieldException &#123;        Person person = new Person(&quot;kaiven&quot;, 20);        Method method = person.getClass().getDeclaredMethod(&quot;sayHello&quot;);        method.setAccessible(true);        method.invoke(person);    &#125;&#125;\n\n（想玩儿的时候自己去查阅文档玩儿一下就行了）\n反射机制执行的流程（等我去搞一下JVM，哈哈。先欠着，以后还。）\n\n","slug":"java基础/反射机制","date":"2024-12-03T16:33:37.000Z","categories_index":"八股","tags_index":"java","author_index":"Ivan"},{"id":"ffb5215d2da6c9afc674d09b81aafa43","title":"注解机制","content":"注解基础注解是JDK1.5版本引入的一个新特性，用于对代码进行说明。\n注解的作用\n通过代码里标识的元数据生成javadoc文档\n编译检查\n编译时动态处理，比如说动态生成代码\n运行时动态处理，比如说使用反射注入实例\n\n注解的分类\nJava自带的标准注解，包括@Override、@Deprecated和@SuppressWarnings，分别用于标明重写某个方法、标明某个类或方法过时、标明要忽略的警告，用这些注解标明后编译器就会进行检查。\n元注解，元注解是用于定义注解的注解，包括@Retention、@Target、@Inherited、@Documented，@Retention用于标明注解被保留的阶段，@Target用于标明注解使用的范围，@Inherited用于标明注解可继承，@Documented用于标明是否生成javadoc文档。\n自定义注解，可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。\n\nJava内置注解12345678910111213141516171819202122232425262728293031public class Solution &#123;    public void test()&#123;&#125;&#125;class Test extends Solution &#123;    /**     * 重写父类方法     */    @Override    public void test() &#123;            &#125;    /**     * 被弃用的方法（后续版本可能移除，不推荐再使用）     */    @Deprecated    public void oldMethod()&#123;    &#125;    /**     * 忽略警告     */    @SuppressWarnings(&quot;rawtypes&quot;)    public List list()&#123;        return new ArrayList&lt;&gt;();    &#125;&#125;\n\n@Override我们来看一下这个注解的内部是什么样子：\n1234@Target(ElementType.METHOD) // 表示该注解用来修饰方法的@Retention(RetentionPolicy.SOURCE) // 表示该注解仅在编译时有效public @interface Override &#123;&#125;\n\n@Deprecated123456789101112131415161718192021222324@Documented // 能够被文档化@Retention(RetentionPolicy.RUNTIME) // 可以保留到运行时@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE, PARAMETER, TYPE&#125;) // 作用域相当的广泛public @interface Deprecated &#123;    /**     * Returns the version in which the annotated element became deprecated.     * The version string is in the same format and namespace as the value of     * the &#123;@code @since&#125; javadoc tag. The default value is the empty     * string.     *     * @return the version string     * @since 9     */    String since() default &quot;&quot;;    /**     * Indicates whether the annotated element is subject to removal in a     * future version. The default value is &#123;@code false&#125;.     *     * @return whether the element is subject to removal     * @since 9     */    boolean forRemoval() default false;&#125;\n\n@SuppressWarnings123456789101112131415161718192021@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE&#125;) // 作用域相当广泛@Retention(RetentionPolicy.SOURCE) // 仅在编译时有效public @interface SuppressWarnings &#123;    /**     * The set of warnings that are to be suppressed by the compiler in the     * annotated element.  Duplicate names are permitted.  The second and     * successive occurrences of a name are ignored.  The presence of     * unrecognized warning names is &lt;i&gt;not&lt;/i&gt; an error: Compilers must     * ignore any warning names they do not recognize.  They are, however,     * free to emit a warning if an annotation contains an unrecognized     * warning name.     *     * &lt;p&gt; The string &#123;@code &quot;unchecked&quot;&#125; is used to suppress     * unchecked warnings. Compiler vendors should document the     * additional warning names they support in conjunction with this     * annotation type. They are encouraged to cooperate to ensure     * that the same names work across multiple compilers.     * @return the set of warnings to be suppressed     */    String[] value();&#125;\n\n元注解@Target123456789101112@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Target &#123;    /**     * Returns an array of the kinds of elements an annotation interface     * can be applied to.     * @return an array of the kinds of elements an annotation interface     * can be applied to     */    ElementType[] value();&#125;\n\n该注解的作用就是限定注解的使用范围，具体范围如下：\n1234567891011121314151617181920212223public enum ElementType &#123;     TYPE, // 类、接口、枚举类     FIELD, // 成员变量（包括：枚举常量）     METHOD, // 成员方法     PARAMETER, // 方法参数     CONSTRUCTOR, // 构造方法     LOCAL_VARIABLE, // 局部变量     ANNOTATION_TYPE, // 注解类     PACKAGE, // 可用于修饰：包     TYPE_PARAMETER, // 类型参数，JDK 1.8 新增     TYPE_USE // 使用类型的任何地方，JDK 1.8 新增 &#125;\n\n我们可以看到该注解自身也加上了一个 @Target(ElementType.ANNOTATION_TYPE) 。\n@Retention12345678910@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Retention &#123;    /**     * Returns the retention policy.     * @return the retention policy     */    RetentionPolicy value();&#125;\n\n该注解的作用就是描述注解保留的时间（或者叫做阶段吧）。总共有三个阶段：\n123456789101112131415161718192021public enum RetentionPolicy &#123;    /**     * Annotations are to be discarded by the compiler.     */    SOURCE,    /**     * Annotations are to be recorded in the class file by the compiler     * but need not be retained by the VM at run time.  This is the default     * behavior.     */    CLASS,    /**     * Annotations are to be recorded in the class file by the compiler and     * retained by the VM at run time, so they may be read reflectively.     *     * @see java.lang.reflect.AnnotatedElement     */    RUNTIME&#125;\n\n（英文描述得已经很清晰了）\n@Documented该注解的作用就是在使用 javadoc 工具为类生成帮助文档时保留注解信息。\n12345@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Documented &#123;&#125;\n\n@Inherited如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。\n12345@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Inherited &#123;&#125;\n\n注解与反射在使用SpringBoot进行开发的时候，你会感慨为什么写几个注解就能够将项目跑起来，那肯定是因为框架的开发者在你看不见的地方替你完成了某些操作。\n注意：注解的生命周期只有是 RUNTIME 才能通过反射去获取。\n自定义注解我们来编写一个属于自己的注解吧。\n123456789101112package com.kaiven.anno;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.METHOD) // 作用在方法上@Retention(RetentionPolicy.RUNTIME) // 保留到运行时，否则无法通过反射获取public @interface GetMapping &#123;    String value() default &quot;&quot;;&#125;\n\n123456789101112131415161718192021package com.kaiven;import com.kaiven.anno.GetMapping;import java.lang.reflect.Method;public class Main &#123;    public static void main(String[] args) throws NoSuchMethodException &#123;        Method hello = Main.class.getMethod(&quot;hello&quot;);        // 如果该方法上有GetMapping注解        if (hello.isAnnotationPresent(GetMapping.class)) &#123;            GetMapping annotation = hello.getAnnotation(GetMapping.class);            System.out.println(annotation.value());        &#125;    &#125;    @GetMapping(&quot;/hello&quot;)    public String hello()&#123;        return &quot;Hello world!&quot;;    &#125;&#125;\n\n有没有那一点点的味道了？\n深入理解注解注解支持继承嘛？注解是不支持继承的，但注解在编译之后，编译器会自动继承java.lang.annotation.Annotation接口。\n注解实现的原理？https://blog.csdn.net/qq\\_20009015/article/details/106038023\n（对于注解的应用，大多还是与Spring相关的，最大的一个变化就是从xml配置项目到注解化的转变）\n\n","slug":"java基础/注解机制","date":"2024-12-03T16:29:44.000Z","categories_index":"八股","tags_index":"java","author_index":"Ivan"},{"id":"5fa7811420fef5e890cc85bbf0c3fa40","title":"SPI","content":"什么是 SPI 机制？SPI（Service Provider Interface），是 JDK 内置的一种服务提供发现机制，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用，Java的SPI机制可以为某个接口寻找服务实现。\nJava中SPI机制的主要思想是将装配的控制权转移到程序外，降低耦合度。\n\n当服务的提供者提供了一种接口的实现之后，需要在classpath下的META-INF/services/目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的META-INF/services/中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。JDK中查找服务的实现的工具类是：java.util.ServiceLoader。\nSPI机制的简单示例定义一个搜索接口，搜索关键词是一个参数，返回对应的搜索结果：\n123public interface Search &#123;    String search(String keywords);&#125;\n\n文件搜索的具体实现：\n123456public class FileSearchImpl implements Search&#123;    @Override    public String search(String keywords) &#123;        return &quot;我是文件搜索功能的具体实现&quot;;    &#125;&#125;\n\n数据库搜索的具体实现：\n123456public class DataBaseSearchImpl implements Search&#123;    @Override    public String search(String keywords) &#123;        return &quot;我是数据库搜索功能的实现&quot;;    &#125;&#125;\n\n接下来可以在resources下新建META-INF&#x2F;services&#x2F;目录，然后新建接口全限定名的文件：com.kaiven.spi.Search，里面加上我们需要用到的实现类。\n12com.kaiven.spi.DataBaseSearchImplcom.kaiven.spi.FileSearchImpl\n\n测试：\n12345678public class Main &#123;    public static void main(String[] args) &#123;        ServiceLoader&lt;Search&gt; load = ServiceLoader.load(Search.class);        for (Search search : load) &#123;            System.out.println(search.search(&quot;&quot;));        &#125;    &#125;&#125;\n\n（好玩吧，哈哈）\nSPI机制的典型应用数据库JDBC提供了统一的数据库相关操作的接口：\n123456789101112131415public interface Driver &#123;    Connection connect(String url, java.util.Properties info)        throws SQLException;    boolean acceptsURL(String url) throws SQLException;    DriverPropertyInfo[] getPropertyInfo(String url, java.util.Properties info)                         throws SQLException;    int getMajorVersion();    int getMinorVersion();    public Logger getParentLogger() throws SQLFeatureNotSupportedException;&#125;\n\n这就是所谓的数据库驱动接口。\n让我们看一下mysql是怎么实现的：\n\n是不是和我们上面写的例子一模一样呢？哈哈。\n（其他的应用场景可以自行百度扩展一下，特别是Spring的，想一下没有SpringBoot之前，是不是一大堆的xml配置文件）\nSPI机制深入理解SPI和API的区别？使用SPI机制的时候，我们会将具体的实现抽离出程序外，也就是相当于接口的定义与实现不在同一个包中，比如 JDBC和MySQL驱动的实现。对于API的话，平时的开发中，会将接口与实现类放在同一个包中。前者强调调用方，后者强调实现方。\nSPI机制的实现原理（这个感兴趣的可以自行去查看JDK中ServiceLoader&lt;S&gt;方法的具体实现，面试的话，这里你能讲出一些自己的理解就行了）\nSPI机制的缺陷\n不能按需加载，需要遍历所有实现，并实例化，然后再循环中才能找到我们的实现。如果不想使用某些实现类，或者某些类实例化很耗时，它也被载入并实例化，这就造成了浪费。\n获取某个实现类的方式不够灵活，只能通过Iterator形式获取，不能根据某个参数来获取对应的实现类。\n多线程使用 ServiceLoader 类的实例是不安全的。\n\n\n","slug":"java基础/SPI","date":"2024-12-03T16:25:08.000Z","categories_index":"八股","tags_index":"java","author_index":"Ivan"},{"id":"da333f82be06d5afcb21795dbc6a2364","title":"final详解","content":"final基础使用修饰类当某个类的整体定义为final时，就表明了你不能打算继承该类，而且也不允许别人这么做。即这个类是不能有子类的。\n注意：final类中的所有方法都隐式为final，因为无法覆盖他们，所以在final类中给任何方法添加final关键字是没有任何意义的。\n修饰方法\nprivate 方法是隐式的final\n类中所有private方法都隐式地指定为final的，由于无法取用private方法，所以也就不能覆盖它。可以对private方法增添final关键字，但这样做并没有什么好处。\n\nfinal方法是可以被重载的\n1234567public class FinalExampleParent &#123;    public final void test() &#123;    &#125;    public final void test(String str) &#123;    &#125;&#125;\n\n修饰参数Java允许在参数列表中以声明的方式将参数指明为final，这意味这你无法在方法中更改参数引用所指向的对象。这个特性主要用来向匿名内部类传递数据。\n修饰变量所有被final修饰的变量都是编译期常量嘛？12345678910111213public class Test &#123;    //编译期常量    final int i = 1;    final static int J = 1;    final int[] a = &#123;1,2,3,4&#125;;    //非编译期常量    Random r = new Random();    final int k = r.nextInt();    public static void main(String[] args) &#123;    &#125;&#125;\n\nk的值由随机数对象决定，所以不是所有的final修饰的字段都是编译期常量，只是k的值在被初始化后无法被更改。\nstatci final一个既是static又是final 的字段只占据一段不能改变的存储空间，它必须在定义的时候进行赋值，否则编译器将不予通过。\n1234567891011public class Test &#123;    static Random r = new Random();    final int k = r.nextInt(10);    static final int k2 = r.nextInt(10);     public static void main(String[] args) &#123;        Test t1 = new Test();        System.out.println(&quot;k=&quot;+t1.k+&quot; k2=&quot;+t1.k2);        Test t2 = new Test();        System.out.println(&quot;k=&quot;+t2.k+&quot; k2=&quot;+t2.k2);    &#125;&#125;\n\n我们可以发现对于不同的对象k的值是不同的，但是k2的值却是相同的，这是为什么呢? 因为static关键字所修饰的字段并不属于一个对象，而是属于这个类的。也可简单的理解为static final所修饰的字段仅占据内存的一个一份空间，一旦被初始化之后便不会被更改。\nfinal域重排序规则Java中，无非就是两种数据类型，基本数据类型和引用（对象）。在下文中，我们展开来看：\nfinal域为基本类型写final域的重排序规则写final域的重排序规则禁止对final域的写重排序到构造函数之外，这个规则的实现主要包含了两个方面：\n\nJMM禁止编译器把final域的写重排序到构造函数之外；\n编译器会在final域写之后，构造函数return之前，插入一个storestore屏障。这个屏障可以禁止处理器把final域的写重排序到构造函数之外。\n\n1234567891011121314151617181920public class FinalDemo &#123;    private int a;  //普通域    private final int b; //final域    private static FinalDemo finalDemo;    public FinalDemo() &#123;        a = 1; // 1. 写普通域        b = 2; // 2. 写final域    &#125;    public static void writer() &#123;        finalDemo = new FinalDemo();    &#125;    public static void reader() &#123;        FinalDemo demo = finalDemo; // 3.读对象引用        int a = demo.a;    //4.读普通域        int b = demo.b;    //5.读final域    &#125;&#125;\n\n假设线程A执行writer方法，线程B执行reader方法。\n线程A在进行对象的构造时，由于b带有final域，所以写指令不会被重排序到构造函数外，而a是普通域，可能会被重排序到构造函数外。线程B读取b的值的时候，一定是可以读到最新值2的（假设对象已经构造完毕），读取a的值就不一定了，可能会读取到默认值。\n读final域重排序规则读final域重排序规则为：在一个线程中，初次读对象引用和初次读该对象包含的final域，JMM会禁止这两个操作的重排序。(注意，这个规则仅仅是针对处理器)，处理器会在读final域操作的前面插入一个LoadLoad屏障。实际上，读对象的引用和读该对象的final域存在间接依赖性，一般处理器不会重排序这两个操作。但是有一些处理器会重排序，因此，这条禁止重排序规则就是针对这些处理器而设定的。\n上文的线程B在进行final域变量值b的读取时，一定会先读取对象的引用，在通过对象的引用读取对应的值。\n读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读这个包含这个final域的对象的引用。\nfinal域为引用类型对final修饰的对象的成员域写操作针对引用数据类型，final域写针对编译器和处理器重排序增加了这样的约束：在构造函数内对一个final修饰的对象的成员域的写入，与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量，这两个操作是不能被重排序的。注意这里的是“增加”也就说前面对final基本数据类型的重排序规则在这里还是使用。\n1234567891011121314151617181920212223public class FinalReferenceDemo &#123;    final int[] arrays;    private FinalReferenceDemo finalReferenceDemo;    public FinalReferenceDemo() &#123;        arrays = new int[1];  //1        arrays[0] = 1;        //2    &#125;    public void writerOne() &#123;        finalReferenceDemo = new FinalReferenceDemo(); //3    &#125;    public void writerTwo() &#123;        arrays[0] = 2;  //4    &#125;    public void reader() &#123;        if (finalReferenceDemo != null) &#123;  //5            int temp = finalReferenceDemo.arrays[0];  //6        &#125;    &#125;&#125;\n\n针对上面的实例程序，线程线程A执行wirterOne方法，执行完后线程B执行writerTwo方法，然后线程C执行reader方法。\n由于对final域的写禁止重排序到构造方法外，因此1和3不能被重排序。由于一个final域的引用对象的成员域写入不能与随后将这个被构造出来的对象赋给引用变量重排序，因此2和3不能重排序。\n对final修饰的对象的成员域读操作JMM可以确保线程C至少能看到写线程A对final引用的对象的成员域的写入，即能看下arrays[0] &#x3D; 1，而写线程B对数组元素的写入可能看到可能看不到。JMM不保证线程B的写入对线程C可见，线程B和线程C之间存在数据竞争，此时的结果是不可预知的。如果可见的，可使用锁或者volatile。\n关于final域重排序的总结按照final修饰的数据类型分类：\n\n基本数据类型:\nfinal域写：禁止final域写与构造方法重排序，即禁止final域写重排序到构造方法之外，从而保证该对象对所有线程可见时，该对象的final域全部已经初始化过。\nfinal域读：禁止初次读对象的引用与读该对象包含的final域的重排序。\n\n\n引用数据类型：\n额外增加约束：禁止在构造函数对一个final修饰的对象的成员域的写入与随后将这个被构造的对象的引用赋值给引用变量 重排序\n\n\n\n\n","slug":"并发/final详解","date":"2024-12-03T15:28:28.000Z","categories_index":"八股","tags_index":"java,并发框架","author_index":"Ivan"},{"id":"2d6047dcb37a308542a367e2837e0e0c","title":"Sychronized详解","content":"synchronized的使用在应用Sychronized关键字时需要把握如下注意点：\n\n一把锁只能同时被一个线程获取，没有获得锁的线程只能等待；\n每个实例都对应有自己的一把锁(this),不同实例之间互不影响；例外：锁对象是*.class以及synchronized修饰的是static方法的时候，所有对象公用同一把锁\nsynchronized修饰的方法，无论方法正常执行完毕还是抛出异常，都会释放锁\n\nsynchronized原理分析加锁和释放锁的原理1234567891011121314public class Test &#123;    Object object = new Object();        public void func()&#123;        synchronized(object)&#123;        &#125;        method();    &#125;    private static void method()&#123;        System.out.println(1);    &#125;&#125;\n\n生成的字节码（非完整，只关注函数func）：\n123456789101112131415161718192021222324public void func();    descriptor: ()V    flags: (0x0001) ACC_PUBLIC    Code:      stack=2, locals=3, args_size=1         0: aload_0         1: getfield      #7                  // Field object:Ljava/lang/Object;         4: dup         5: astore_1         6: monitorenter // 注意这里         7: aload_1         8: monitorexit // 注意这里         9: goto          17        12: astore_2        13: aload_1        14: monitorexit // 注意这里        15: aload_2        16: athrow        17: invokestatic  #13                 // Method method:()V        20: return      Exception table:         from    to  target type             7     9    12   any            12    15    12   any\n\nMonitorenter和Monitorexit指令，会让对象在执行，使其锁计数器加1或者减1。每一个对象在同一时间只与一个monitor(锁)相关联，而一个monitor在同一时间只能被一个线程获得，一个对象在尝试获得与这个对象相关联的Monitor锁的所有权的时候，monitorenter指令会发生如下3中情况之一：\n\nmonitor计数器为0，意味着目前还没有被获得，那这个线程就会立刻获得然后把锁计数器+1，一旦+1，别的线程再想获取，就需要等待\n如果这个monitor已经拿到了这个锁的所有权，又重入了这把锁，那锁计数器就会累加，变成2，并且随着重入的次数，会一直累加\n这把锁已经被别的线程获取了，等待锁释放\n\nmonitorexit指令：释放对于monitor的所有权，释放过程很简单，就是讲monitor的计数器减1，如果减完以后，计数器不是0，则代表刚才是重入进来的，当前线程还继续持有这把锁的所有权，如果计数器变成0，则代表当前线程不再拥有该monitor的所有权，即释放锁。\n\n该图可以看出，任意线程对Object的访问，首先要获得Object的监视器，如果获取失败，该线程就进入同步状态，线程状态变为BLOCKED，当Object的监视器占有者释放后，在同步队列中得线程就会有机会重新获取该监视器.\n(这也是可重入的原理)\n保证可见性的原理：内存模型和happens-before规则Synchronized的happens-before规则，即监视器锁规则：对同一个监视器的解锁，happens-before于对该监视器的加锁。\n（这是JVM对你的一个承诺）\nJVM中锁的优化简单来说在JVM中monitorenter和monitorexit字节码依赖于底层的操作系统的Mutex Lock来实现的，但是由于使用Mutex Lock需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的；然而在现实中的大部分情况下，同步方法是运行在单线程环境(无锁竞争环境)如果每次都调用Mutex Lock那么将严重的影响程序的性能。不过在jdk1.6中对锁的实现引入了大量的优化，如锁粗化(Lock Coarsening)、锁消除(Lock Elimination)、轻量级锁(Lightweight Locking)、偏向锁(Biased Locking)、适应性自旋(Adaptive Spinning)等技术来减少锁操作的开销。\n\n锁粗化(Lock Coarsening)：也就是减少不必要的紧连在一起的unlock，lock操作，将多个连续的锁扩展成一个范围更大的锁。\n锁消除(Lock Elimination)：通过运行时JIT编译器的逃逸分析来消除一些没有在当前同步块以外被其他线程共享的数据的锁保护，通过逃逸分析也可以在线程本的Stack上进行对象空间的分配(同时还可以减少Heap上的垃圾收集开销)。\n轻量级锁(Lightweight Locking)：这种锁实现的背后基于这样一种假设，即在真实的情况下我们程序中的大部分同步代码一般都处于无锁竞争状态(即单线程执行环境)，在无锁竞争的情况下完全可以避免调用操作系统层面的重量级互斥锁，取而代之的是在monitorenter和monitorexit中只需要依靠一条CAS原子指令就可以完成锁的获取及释放。当存在锁竞争的情况下，执行CAS指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒(具体处理步骤下面详细讨论)。\n偏向锁(Biased Locking)：是为了在无锁竞争的情况下避免在锁获取过程中执行不必要的CAS原子指令，因为CAS原子指令虽然相对于重量级锁来说开销比较小但还是存在非常可观的本地延迟。\n适应性自旋(Adaptive Spinning)：当线程在获取轻量级锁的过程中执行CAS操作失败时，在进入与monitor相关联的操作系统重量级锁(mutex semaphore)前会进入忙等待(Spinning)然后再次尝试，当尝试一定的次数后如果仍然没有成功则调用与该monitor关联的semaphore(即互斥锁)进入到阻塞状态。\n\n锁的类型在Java SE 1.6里Synchronied同步锁，一共有四种状态：无锁、偏向锁、轻量级锁、重量级锁，它会随着竞争情况逐渐升级。锁可以升级但是不可以降级，目的是为了提供获取锁和释放锁的效率。\n（ 锁膨胀方向： 无锁 → 偏向锁 → 轻量级锁 → 重量级锁 (此过程是不可逆的) ）\n自旋锁与自适应自旋锁引入背景：大家都知道，在没有加入锁优化时，Synchronized是一个非常“胖大”的家伙。在多线程竞争锁时，当一个线程获取锁时，它会阻塞所有正在竞争的线程，这样对性能带来了极大的影响。在挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作对系统的并发性能带来了很大的压力。同时HotSpot团队注意到在很多情况下，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和回复阻塞线程并不值得。在如今多处理器环境下，完全可以让另一个没有获取到锁的线程在门外等待一会(自旋)，但不放弃CPU的执行时间。等待持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需要让线程执行一个忙循环(自旋)，这便是自旋锁由来的原因。\n自旋锁早在JDK1.4 中就引入了，只是当时默认时关闭的。在JDK 1.6后默认为开启状态。自旋锁本质上与阻塞并不相同，先不考虑其对多处理器的要求，如果锁占用的时间非常的短，那么自旋锁的性能会非常的好，相反，其会带来更多的性能开销(因为在线程自旋时，始终会占用CPU的时间片，如果锁占用的时间太长，那么自旋的线程会白白消耗掉CPU资源)。因此自旋等待的时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获取到锁，就应该使用传统的方式去挂起线程了，在JDK定义中，自旋锁默认的自旋次数为10次，用户可以使用参数-XX:PreBlockSpin来更改。\n可是现在又出现了一个问题：如果线程锁在线程自旋刚结束就释放掉了锁，那么是不是有点得不偿失。所以这时候我们需要更加聪明的锁来实现更加灵活的自旋。来提高并发的性能。(这里则需要自适应自旋锁！)\n在JDK 1.6中引入了自适应自旋锁。这就意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋 时间及锁的拥有者的状态来决定的。如果在同一个锁对象上，自旋等待刚刚成功获取过锁，并且持有锁的线程正在运行中，那么JVM会认为该锁自旋获取到锁的可能性很大，会自动增加等待时间。比如增加到100此循环。相反，如果对于某个锁，自旋很少成功获取锁。那再以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，JVM对程序的锁的状态预测会越来越准确，JVM也会越来越聪明。\n锁消除锁消除是指虚拟机即时编译器再运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持。意思就是：JVM会判断再一段程序中的同步明显不会逃逸出去从而被其他线程访问到，那JVM就把它们当作栈上数据对待，认为这些数据是线程独有的，不需要加同步。此时就会进行锁消除。\n当然在实际开发中，我们很清楚的知道哪些是线程独有的，不需要加同步锁，但是在Java API中有很多方法都是加了同步的，那么此时JVM会判断这段代码是否需要加锁。如果数据并不会逃逸，则会进行锁消除。\n锁粗化原则上，我们都知道在加同步锁时，尽可能的将同步块的作用范围限制到尽量小的范围(只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小。在存在锁同步竞争中，也可以使得等待锁的线程尽早的拿到锁)。\n大部分上述情况是完美正确的，但是如果存在连串的一系列操作都对同一个对象反复加锁和解锁，甚至加锁操作时出现在循环体中的，那即使没有线程竞争，频繁的进行互斥同步操作也会导致不必要的性能操作。\n1234567public static String test04(String s1, String s2, String s3) &#123;    StringBuffer sb = new StringBuffer();    sb.append(s1);    sb.append(s2);    sb.append(s3);    return sb.toString();&#125;\n\n在上述的连续append()操作中就属于这类情况。JVM会检测到这样一连串的操作都是对同一个对象加锁，那么JVM会将加锁同步的范围扩展(粗化)到整个一系列操作的 外部，使整个一连串的append()操作只需要加锁一次就可以了。\n轻量级锁在JDK 1.6之后引入的轻量级锁，需要注意的是轻量级锁并不是替代重量级锁的，而是对在大多数情况下同步块并不会有竞争出现提出的一种优化。它可以减少重量级锁对线程的阻塞带来的线程开销。从而提高并发性能。\n如果要理解轻量级锁，那么必须先要了解HotSpot虚拟机中对象头的内存布局。上面介绍Java对象头也详细介绍过。在对象头中(Object Header)存在两部分。第一部分用于存储对象自身的运行时数据，HashCode、GC Age、锁标记位、是否为偏向锁。等。一般为32位或者64位(视操作系统位数定)。官方称之为Mark Word，它是实现轻量级锁和偏向锁的关键。 另外一部分存储的是指向方法区对象类型数据的指针(Klass Point)，如果对象是数组的话，还会有一个额外的部分用于存储数据的长度。\n在线程执行同步块之前，JVM会先在当前线程的栈帧中创建一个名为锁记录(Lock Record)的空间，用于存储锁对象目前的Mark Word的拷贝(JVM会将对象头中的Mark Word拷贝到锁记录中，官方称为Displaced Mark Ward)这个时候线程堆栈与对象头的状态如图：\n\n如上图所示：如果当前对象没有被锁定，那么锁标志位为01状态，JVM在执行当前线程时，首先会在当前线程栈帧中创建锁记录Lock Record的空间用于存储锁对象目前的Mark Word的拷贝。\n然后，虚拟机使用CAS操作将标记字段Mark Word拷贝到锁记录中，并且将Mark Word更新为指向Lock Record的指针。如果更新成功了，那么这个线程就拥用了该对象的锁，并且对象Mark Word的锁标志位更新为(Mark Word中最后的2bit)00，即表示此对象处于轻量级锁定状态，如图：\n\n如果这个更新操作失败，JVM会检查当前的Mark Word中是否存在指向当前线程的栈帧的指针，如果有，说明该锁已经被获取，可以直接调用。如果没有，则说明该锁被其他线程抢占了，如果有两条以上的线程竞争同一个锁，那轻量级锁就不再有效，直接膨胀为重量级锁，没有获得锁的线程会被阻塞。此时，锁的标志位为10.Mark Word中存储的指向重量级锁的指针。\n轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头中，如果成功，则表示没有发生竞争关系。如果失败，表示当前锁存在竞争关系。锁就会膨胀成重量级锁。两个线程同时争夺锁，导致锁膨胀的流程图如下：\n\n偏向锁引入背景：在大多实际环境下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获取，那么在同一个线程反复获取所释放锁中，其中并还没有锁的竞争，那么这样看上去，多次的获取锁和释放锁带来了很多不必要的性能开销和上下文切换。\n为了解决这一问题，HotSpot的作者在Java SE 1.6 中对Synchronized进行了优化，引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁。只需要简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果成功，表示线程已经获取到了锁。\n\n偏向锁使用了一种等待竞争出现才会释放锁的机制。所以当其他线程尝试获取偏向锁时，持有偏向锁的线程才会释放锁。但是偏向锁的撤销需要等到全局安全点(就是当前线程没有正在执行的字节码)。它会首先暂停拥有偏向锁的线程，让你后检查持有偏向锁的线程是否活着。如果线程不处于活动状态，直接将对象头设置为无锁状态。如果线程活着，JVM会遍历栈帧中的锁记录，栈帧中的锁记录和对象头要么偏向于其他线程，要么恢复到无锁状态或者标记对象不适合作为偏向锁。\n\n锁的优缺点对比\n\n","slug":"并发/Sychronized详解","date":"2024-12-03T15:23:37.000Z","categories_index":"八股","tags_index":"java,并发框架","author_index":"Ivan"},{"id":"4dfa428c08a3d894cc1c145fbc03603c","title":"Volatile详解","content":"volatile的作用详解防重排序从一个经典的双检索单例模式开始：\n1234567891011121314151617public class Singleton &#123;    public static volatile Singleton singleton;    /**     * 构造函数私有，禁止外部实例化     */    private Singleton() &#123;&#125;;    public static Singleton getInstance() &#123;        if (singleton == null) &#123;            synchronized (singleton.class) &#123;                if (singleton == null) &#123;                    singleton = new Singleton();                &#125;            &#125;        &#125;        return singleton;    &#125;&#125;\n\n现在我们分析一下为什么要在变量singleton之间加上volatile关键字。要理解这个问题，先要了解对象的构造过程，实例化一个对象其实可以分为三个步骤：\n\n分配内存空间。\n初始化对象。\n将内存空间的地址赋值给对应的引用。\n\n但是由于操作系统可以对指令进行重排序，所以上面的过程也可能会变成如下过程：\n\n分配内存空间。\n将内存空间的地址赋值给对应的引用。\n初始化对象\n\n如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。因此，为了防止这个过程的重排序，我们需要将变量设置为volatile类型的变量。\n实现可见性可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到。引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。\n123456789101112131415161718192021222324public class TestVolatile &#123;    private static boolean stop = false;    public static void main(String[] args) &#123;        // Thread-A        new Thread(&quot;Thread A&quot;) &#123;            @Override            public void run() &#123;                while (!stop) &#123;                &#125;                System.out.println(Thread.currentThread() + &quot; stopped&quot;);            &#125;        &#125;.start();        // Thread-main        try &#123;            TimeUnit.SECONDS.sleep(1);            System.out.println(Thread.currentThread() + &quot; after 1 seconds&quot;);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        stop = true;    &#125;&#125;\n\n可以看到 Thread-main 休眠1秒之后，设置 stop &#x3D; ture，但是Thread A根本没停下来，这就是可见性问题。如果通过在stop变量前面加上volatile关键字则会真正stop。\n这里有必要做一下详细的解释：\nCPU的多级缓存机制是大小限制的，上下文切换的时候，会将线程相关状态保存在TCB中，TCB在内存中。下次再次切换会该线程的时候，会从TCB中恢复线程的上下文信息。即，从上面的程序来说，“stop的值被保存在TCB中”，一直读取的都是老值。\n保证原子性：单次读&#x2F;写volatile不能保证完全的原子性，只能保证单次的读&#x2F;写操作具有原子性。\n我们先来看两个经典的问题：\n1. i++为什么不能保证原子性？对于原子性，需要强调一点，也是大家容易误解的一点：对volatile变量的单次读&#x2F;写操作可以保证原子性的，如long和double类型变量，但是并不能保证i++这种操作的原子性，因为本质上i++是读、写两次操作。\ni++其实是一个复合操作，包括三步骤：\n\n读取i的值。\n对i加1。\n将i的值写回内存。\n\nvolatile是无法保证这三个操作是具有原子性的，我们可以通过AtomicInteger或者Synchronized来保证+1操作的原子性。\n2. 共享的long和double变量为什么要用volatile？因为long和double两种数据类型的操作可分为高32位和低32位两部分，因此普通的long或double类型读&#x2F;写可能不是原子的。因此，鼓励大家将共享的long和double变量设置为volatile类型，这样能保证任何情况下对long和double的单次读&#x2F;写操作都具有原子性。\n（目前各种平台下的商用虚拟机都选择把 64 位数据的读写操作作为原子操作来对待，因此我们在编写代码时一般不把long 和 double 变量专门声明为 volatile多数情况下也是不会错的）\nvolatile 的实现原理volatile 可见性实现volatile 变量的内存可见性是基于内存屏障(Memory Barrier)实现:\n内存屏障，又称内存栅栏，是一个 CPU 指令。\n在程序运行时，为了提高执行性能，编译器和处理器会对指令进行重排序，JMM 为了保证在不同的编译器和 CPU 上有相同的结果，通过插入特定类型的内存屏障来禁止+ 特定类型的编译器重排序和处理器重排序，插入一条内存屏障会告诉编译器和 CPU：不管什么指令都不能和这条 Memory Barrier 指令重排序。\n为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存(L1，L2 或其他)后再进行操作，但操作完不知道何时会写到内存。\n如果对声明了 volatile 的变量进行写操作，JVM 就会向处理器发送一条 lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。\n为了保证各个处理器的缓存是一致的，实现了缓存一致性协议(MESI)，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。\n所有多核处理器下还会完成：当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。\nvolatile 变量通过这样的机制就使得每个线程都能获得该变量的最新值。\nvolatile 有序性实现1. happens-beforehappens-before 规则中有一条是 volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。\n（简单说，如果写在读的前面的话，那么一定读到的就是最新值）\n2. 写操作禁止重排序为了性能优化，JMM 在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序。JMM 提供了内存屏障阻止这种重排序。\nJava 编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。\n\n","slug":"并发/Volatile详解","date":"2024-12-03T15:19:43.000Z","categories_index":"八股","tags_index":"java,并发框架","author_index":"Ivan"},{"id":"6f65c61888737e8d4204dac5a8495701","title":"锁的概念","content":"导图\n乐观锁 VS 悲观锁乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。\n先说概念。对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。\n而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。\n乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。\n\n根据从上面的概念描述我们可以发现：\n\n悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。\n乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。\n\n自旋锁 VS 适应性自旋锁阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。\n在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。\n而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。\n\n自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。\n自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。\n无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁这四种锁是指锁的状态，专门针对synchronized的。\n（后续的文章会详细讲解）\n总结而言： 偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。\n公平锁 VS 非公平锁公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。\n非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。\n可重入锁 VS 非可重入锁可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。\n1234567891011121314151617class Test &#123;    public synchronized void func01(int arg)&#123;        System.out.println(arg);        func02(arg + 1);    &#125;    public synchronized void func02(int arg)&#123;        System.out.println(arg);    &#125;    public static void main(String[] args) &#123;        Test test = new Test();        ExecutorService executorService = Executors.newCachedThreadPool();        executorService.execute(() -&gt; test.func01(1));        executorService.execute(() -&gt; test.func01(3));        executorService.shutdown();    &#125;&#125;\n\n如果 synchronized 不是可重入锁的话，那么很明显上述代码会造成死锁。\n可重入锁的实现原理大致是这样的：内部维护了一个计数器，获取到锁的时候，判断一下计数器的值。如果计数器的值是0的话，那么执行+1操作；如果不是0的话，判断当前线程是否是获取到锁的线程，如果是的话，就执行+1操作。释放锁就是每执行完一个同步代码块后，将计数器的值-1，计数器的值为0时，释放锁。\n独享锁(排他锁) VS 共享锁独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。\n共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。\n（本文主要是介绍一下锁的概念上的东西，具体的实现请看后续章节）\n\n","slug":"并发/锁的概念","date":"2024-12-03T15:13:49.000Z","categories_index":"八股","tags_index":"java,并发框架","author_index":"Ivan"},{"id":"6245dd4deb5ec4d8e16e80935a8a30db","title":"线程基础","content":"线程状态的转换新建（New）创建后未启动。\n可运行（Runable）可能正在运行，也可能等待CPU时间片。\n阻塞（Blocking）等待获取一个排它锁，如果其他线程释放了锁，就会结束该状态。\n无限期等待（Waiting）等待其他线程显式的唤醒，否则不会被分配时间片。\n限期等待（Timed Waiting）无需等待其他线程显式地唤醒，在一定时间之后被系统自动唤醒。\n死亡（Terminated）可以是线程结束任务之后自己结束，或产生异常而结束。\n线程使用方式有三种使用线程的方法:\n\n实现 Runnable 接口；\n实现 Callable 接口；\n继承 Thread 类。\n\n实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。\n1.实现 Runnable 接口123456789101112131415class MyRunable implements Runnable &#123;    @Override    public void run() &#123;        System.out.println(&quot;hello world!&quot;);    &#125;    public static void main(String[] args) throws InterruptedException &#123;        MyRunable myRunable = new MyRunable();        Thread thread = new Thread(myRunable);        thread.start();        thread.join();    &#125;    &#125;\n\n2. 实现 Callable 接口123456789101112131415class MyCallable implements Callable&lt;String&gt; &#123;    @Override    public String call() throws Exception &#123;        return &quot;Hello World!&quot;;    &#125;    public static void main(String[] args) throws InterruptedException, ExecutionException &#123;        MyCallable myCallable = new MyCallable();        FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(myCallable);        Thread thread = new Thread(futureTask);        thread.start();        System.out.println(futureTask.get());    &#125;&#125;\n\n3. 继承Thread类1234567891011121314class MyThread extends Thread &#123;    @Override    public void run() &#123;        System.out.println(&quot;Hello World!&quot;);    &#125;    public static void main(String[] args) throws InterruptedException &#123;        MyThread myThread = new MyThread();        myThread.start();        myThread.join();    &#125;    &#125;\n\n实现接口 VS 继承 Thread 类实现接口会更好一些，因为:\n\nJava 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；\n类可能只要求可执行就行，继承整个 Thread 类开销过大。\n\n基础线程机制ExecutorExecutor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。\n主要有三种 Executor:\n\nCachedThreadPool: 一个任务创建一个线程；\nFixedThreadPool: 所有任务只能使用固定大小的线程；\nSingleThreadExecutor: 相当于大小为 1 的 FixedThreadPool。\n\n123456789101112public class Solution &#123;    public static void main(String[] args) &#123;        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();        for(int i=0;i&lt;5;i++)&#123;            final int I = i;            newCachedThreadPool.execute(() -&gt; &#123;                System.out.println(&quot;hello world! &quot;+I);            &#125;);        &#125;        newCachedThreadPool.shutdown();    &#125;&#125;\n\nDaemon守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。\n当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。\nmain() 属于非守护线程。\n使用 setDaemon() 方法将一个线程设置为守护线程。\n12345678public class Solution &#123;    public static void main(String[] args) &#123;        Thread thread = new Thread(() -&gt; &#123;            System.out.println(&quot;hello world!&quot;);        &#125;);        thread.setDaemon(true);    &#125;&#125;\n\nsleep()Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。\nsleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。\n1234public static void main(String[] args) throws InterruptedException &#123;    Thread.sleep(3000);    System.out.println(&quot;hello world!&quot;);&#125;\n\nyield()对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。\n12345678910111213141516public static void main(String[] args) throws InterruptedException &#123;    Thread thread_01 = new Thread(() -&gt; &#123;        System.out.println(1);        Thread.yield();        System.out.println(3);    &#125;);    Thread thread_02 = new Thread(() -&gt; &#123;        System.out.println(2);        Thread.yield();        System.out.println(4);    &#125;);    thread_01.start();    thread_02.start();    thread_01.join();    thread_02.join();&#125;\n\n线程中断一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。\nInterruptedException通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I&#x2F;O 阻塞和 synchronized 锁阻塞。\n1234567891011121314public static void main(String[] args) throws InterruptedException &#123;    Thread thread = new Thread(() -&gt; &#123;        try &#123;            Thread.sleep(3000);            System.out.println(&quot;hello&quot;);        &#125; catch (InterruptedException e) &#123;            System.out.println(&quot;我被干掉了&quot;);        &#125;    &#125;);    thread.start();    Thread.sleep(1000);    thread.interrupt();    thread.join();&#125;\n\ninterrupted()如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。\n但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。\n123456789101112131415161718class MyThread extends Thread &#123;    @Override    public void run() &#123;        while (!interrupted()) &#123;            System.out.println(&quot;没有被打断&quot;);        &#125;        System.out.println(&quot;完蛋了！&quot;);    &#125;        public static void main(String[] args) throws InterruptedException &#123;        MyThread myThread = new MyThread();        myThread.start();        Thread.sleep(1000);        myThread.interrupt();        myThread.join();    &#125;&#125;\n\nExecutor 的中断操作调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。\n123456789101112public static void main(String[] args) throws InterruptedException &#123;    ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();    newCachedThreadPool.execute(() -&gt; &#123;        try &#123;            Thread.sleep(3000);            System.out.println(&quot;hello world&quot;);        &#125; catch (InterruptedException e) &#123;            System.out.println(&quot;被中断喽&quot;);        &#125;    &#125;);    newCachedThreadPool.shutdownNow();&#125;\n\n如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。\n1234567891011public static void main(String[] args) throws InterruptedException, ExecutionException &#123;    ExecutorService executorService = Executors.newCachedThreadPool();    Future&lt;Object&gt; submit = executorService.submit(() -&gt; &#123;        for(int i=0;i&lt;100000000;i++)&#123;            System.out.println(i);        &#125;        return null;    &#125;);    submit.cancel(true);    System.out.println(&quot;hello&quot;);&#125;\n\n线程互斥同步Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。\nsynchronized1. 同步一个代码块1234567891011121314151617181920class Test &#123;    public void func() &#123;        synchronized (this) &#123;            for (int i = 0; i &lt; 10; i++) &#123;                System.out.println(i);            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        Test test = new Test();        ExecutorService executorService = Executors.newCachedThreadPool();        executorService.execute(() -&gt; &#123;            test.func();        &#125;);        executorService.execute(() -&gt; &#123;            test.func();        &#125;);        executorService.shutdown();    &#125;&#125;\n\n它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步：\n123456789101112131415161718192021class Test &#123;    public void func() &#123;        synchronized (this) &#123;            for (int i = 0; i &lt; 10; i++) &#123;                System.out.println(i);            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        Test test = new Test();        Test test2 = new Test();        ExecutorService executorService = Executors.newCachedThreadPool();        executorService.execute(() -&gt; &#123;            test.func();        &#125;);        executorService.execute(() -&gt; &#123;            test2.func();        &#125;);        executorService.shutdown();    &#125;&#125;\n\n2. 同步一个方法1234567891011121314151617181920class Test &#123;    public synchronized void func() &#123;        for (int i = 0; i &lt; 10; i++) &#123;            System.out.println(i);        &#125;    &#125;    public static void main(String[] args) &#123;        Test test = new Test();        Test test2 = new Test();        ExecutorService executorService = Executors.newCachedThreadPool();        executorService.execute(() -&gt; &#123;            test.func();        &#125;);        executorService.execute(() -&gt; &#123;            test2.func();        &#125;);        executorService.shutdown();    &#125;&#125;\n\n它和同步代码块一样，作用于同一个对象。\n3. 同步一个类12345678910111213141516171819202122class Test &#123;    public void func() &#123;        synchronized (Test.class) &#123;            for (int i = 0; i &lt; 10; i++) &#123;                System.out.println(i);            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        Test test = new Test();        Test test2 = new Test();        ExecutorService executorService = Executors.newCachedThreadPool();        executorService.execute(() -&gt; &#123;            test.func();        &#125;);        executorService.execute(() -&gt; &#123;            test2.func();        &#125;);        executorService.shutdown();    &#125;&#125;\n\n作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。\n4. 同步一个静态方法123456789101112131415161718class Test &#123;    public static synchronized void func() &#123;        for (int i = 0; i &lt; 10; i++) &#123;            System.out.println(i);        &#125;    &#125;    public static void main(String[] args) &#123;        ExecutorService executorService = Executors.newCachedThreadPool();        executorService.execute(() -&gt; &#123;            Test.func();        &#125;);        executorService.execute(() -&gt; &#123;            Test.func();        &#125;);        executorService.shutdown();    &#125;&#125;\n\n作用于整个类。\nReentrantLockReentrantLock 是 java.util.concurrent(J.U.C)包中的锁。\n12345678910111213141516171819202122232425class Test &#123;    private Lock lock;    &#123;        lock = new ReentrantLock();    &#125;    public void func() &#123;        lock.lock();        try &#123;            for(int i=0;i&lt;10;i++)&#123;                System.out.println(i);            &#125;        &#125; finally &#123;            lock.unlock();        &#125;    &#125;    public static void main(String[] args) &#123;        Test test = new Test();        ExecutorService executorService = Executors.newCachedThreadPool();        executorService.execute(() -&gt; test.func());        executorService.execute(() -&gt; test.func());        executorService.shutdown();    &#125;&#125;\n\n比较1. 锁的实现synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。\n2. 性能新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。\n3. 等待可中断当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。\nReentrantLock 可中断，而 synchronized 不行。\n4. 公平锁公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。\nsynchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。\n5. 锁绑定多个条件一个 ReentrantLock 可以同时绑定多个 Condition 对象。\n使用选择除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。\n线程之间的协作当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。\njoin()在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。\n（这里就不掩饰了，经常用的）\nwait() notify() notifyAll()调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。\n它们都属于 Object 的一部分，而不属于 Thread。\n只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateExeception。\n使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。\n12345678910111213141516171819202122232425262728class Test &#123;    public synchronized void before() &#123;        try &#123;            Thread.sleep(1500);        &#125; catch (InterruptedException e) &#123;            System.out.println(&quot;被打断lou&quot;);        &#125;        System.out.println(&quot;before&quot;);        notifyAll();    &#125;    public synchronized void after() &#123;        try &#123;            wait();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(&quot;after&quot;);    &#125;    public static void main(String[] args) &#123;        Test test = new Test();        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();        newCachedThreadPool.execute(() -&gt; test.after());        newCachedThreadPool.execute(() -&gt; test.before());        newCachedThreadPool.shutdown();    &#125;&#125;\n\n（以上代码有死锁的风险，如果是after函数先执行，那没有问题；如果是before先执行，就证明了after没有拿到锁，等before释放锁之后，after拿到锁，然后进入休眠状态，然后也没有人唤醒它）\nwait() 和 sleep() 的区别\nwait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法\nwait() 会释放锁，sleep() 不会\n\nawait() signal() signalAll()java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。\n123456789101112131415161718192021222324252627282930313233343536373839404142class Test &#123;    private Lock lock;    private Condition condition;    &#123;        lock = new ReentrantLock();        condition = lock.newCondition();    &#125;    public void before() &#123;        lock.lock();        try &#123;            Thread.sleep(1500);            System.out.println(&quot;before&quot;);        &#125; catch (InterruptedException e) &#123;            System.out.println(&quot;被打断lou&quot;);        &#125;        finally&#123;            condition.signalAll();            lock.unlock();        &#125;    &#125;    public void after() &#123;        lock.lock();        try &#123;            condition.await();            System.out.println(&quot;after&quot;);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        finally&#123;            lock.unlock();        &#125;    &#125;    public static void main(String[] args) &#123;        Test test = new Test();        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();        newCachedThreadPool.execute(() -&gt; test.after());        newCachedThreadPool.execute(() -&gt; test.before());        newCachedThreadPool.shutdown();    &#125;&#125;\n\n（和上文一下，也是会有死锁的风险，虽然我没有测出来，但是理论上来说，是这样的）\n\n","slug":"并发/线程基础","date":"2024-12-03T14:40:50.000Z","categories_index":"八股","tags_index":"java,并发框架","author_index":"Ivan"},{"id":"f5276a6470bcf00967ce9121d16c19cd","title":"并发基础","content":"为什么需要多线程？早期的单CPU时代，CPU制作厂商沉迷于提高单个核心的计算能力。但是随着时间的推移，提高单核心的计算能力越来越困难了。于是乎，堆核心成为了快速提高CPU计算能力的另一种途径。这样一来，多个任务就可以并行的跑在CPU的不同核心上。\n一个程序只是一个单线程的应用的话，无法利用现代多核心CPU的优势。所以，学习并发编程可以提高我们程序的运行效率。\n线程安全示例多线程编程虽然可以提高我们程序的运行效率，但是同样也面临着线程安全或者说并发安全问题：\n12345678910111213141516171819202122232425262728public class ThreadUnsafeExample &#123;    private int cnt = 0;    public void add() &#123;        cnt++;    &#125;    public int get() &#123;        return cnt;    &#125;    public static void main(String[] args) throws InterruptedException &#123;        final int threadSize = 1000;        ThreadUnsafeExample example = new ThreadUnsafeExample();        final CountDownLatch countDownLatch = new CountDownLatch(threadSize);        ExecutorService executorService = Executors.newCachedThreadPool();        for (int i = 0; i &lt; threadSize; i++) &#123;            executorService.execute(() -&gt; &#123;                example.add();                countDownLatch.countDown();            &#125;);        &#125;        countDownLatch.await();        executorService.shutdown();        System.out.println(example.get());    &#125;&#125;\n\n运行的结果总是小于1000。\n并发问题发生的三要素1. 可见性：CPU缓存引起的\nCPU直接与自己的L1级缓存进行交互，L1级缓存的数据来自L2，L2中的数据来自L3，L3中的数据来自内存。\n假设线程A和线程B并发的执行这段代码的话，线程A在CPU1上执行，线程B在CPU2上执行，会有以下这种情况：\n线程A将i的值从内存载入CPU1对应的缓存中，此时i的值为0；\n线程B将i的值从内存载入CPU2对应的缓存中，此时i的值为0；\n线程A执行了自增操作，CPU1缓存中的i的值为1；\n线程B执行了自增操作，CPU2缓存中的i的值为1；\n线程A将CPU1缓存i的值写入内存，内存中i的值是1；\n线程B将CPU2缓存i的值写入内存，内存中i的值是1。\n其中一次操作的值将另一次操作的值给覆盖了。\n本质问题就是一个线程在CPU缓存中修改了共享的值，另一个线程并不知道。\n2. 原子性：分时复用引起的对于【i++】操作来说，它对应三条指令：\n\n将变量i从内存中读到寄存器\n将寄存器中i的值+1\n写回内存（由于缓存机制，也可能是缓存，而不是内存）\n\n我们都知道，CPU运作机制就是执行一条又一条的指令。无论是Linux、windows还是Max OS，它们都属于分时操作系统。CPU并发的运行着N多个程序。CPU有一个时钟硬件设备，定期向CPU发送时钟中断信号，CPU收到信号后，操作系统介入，调度下一个程序运行。\n所以，就算是在只有一个CPU的机器上，运行多线程的程序，由于分时复用机制，一个操作如果由多条指令集合构成，那么也会造成并发安全问题。\n3. 有序性：重排序引起1234int i = 0;              boolean flag = false;i = 1;                //语句1  flag = true;          //语句2\n\n从我们开发的角度来看，语句1应该在语句2之前执行的，那事实真的是这样嘛？\n在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：\n\n编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。\n指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。\n内存系统的重排序。由于处理器使用缓存和读 &#x2F; 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。\n\n从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：\n\n上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。\nJava是怎么解决并发问题的？JMM（Java内存模型）。\n理解的第一个维度：核心知识点\nJMM本质上可以理解为，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括：\n\nvolatile、synchronized 和 final 三个关键字\nHappens-Before 规则\n\n理解的第二个维度：可见性，有序性，原子性\n\n原子性\n\n在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。\n请分析以下哪些操作是原子性操作：\n1234x = 10;        //语句1: 直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中y = x;         //语句2: 包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。x++;           //语句3： x++包括3个操作：读取x的值，进行加1操作，写入新的值。x = x + 1;     //语句4： 同语句3\n\n只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。\nJava内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。\n\n可见性\n\nJava提供了volatile关键字来保证可见性。\n当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。\n而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。\n另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。\n\n有序性\n\n在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。当然JMM是通过Happens-Before 规则来保证有序性的。\nHappens-Before 规则上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。\n1. 单一线程原则在一个线程内，在程序前面的操作先行发生于后面的操作。\n2. 管程锁定规则一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。\n3. volatile变量规则对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。\n4. 线程启动规则Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。\n5. 线程加入规则Thread 对象的结束先行发生于 join() 方法返回。\n6. 线程中断规则对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。\n7. 对象终结规则一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始。\n8. 传递性如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。\n线程安全一个类在可以被多个线程安全调用时就是线程安全的。\n线程安全不是一个非真即假的命题，可以将共享数据按照安全程度的强弱顺序分成以下五类: 不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。\n1. 不可变不可变(Immutable)的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。\n多线程环境下，应当尽量使对象成为不可变，来满足线程安全。\n不可变的类型:\n\nfinal 关键字修饰的基本数据类型\nString\n枚举类型\nNumber 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。\n\n2. 相对线程安全相对线程安全需要保证对这个对象单独的操作是线程安全的，在调用的时候不需要做额外的保障措施。但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。\n在 Java 语言中，大部分的线程安全类都属于这种类型，例如 Vector、HashTable、Collections 的 synchronizedCollection() 方法包装的集合等。\n3. 线程兼容线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。Java API 中大部分的类都是属于线程兼容的，如与前面的 Vector 和 HashTable 相对应的集合类 ArrayList 和 HashMap 等。\n4. 线程对立线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于 Java 语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。\n线程安全的实现方法1. 互斥同步synchronized 和 ReentrantLock。\n2. 非阻塞同步互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。\n互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁(这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁)、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。\n（一）CAS随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略: 先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施(不断地重试，直到成功为止)。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。\n乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是: 比较并交换(Compare-and-Swap，CAS)。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。\n（二）ABA如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。\nJ.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。\n3. 无同步方案要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。\n（一）栈封闭多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。\n（二）线程本地存储（Thread Local Storage）如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。\n符合这种特点的应用并不少见，大部分使用消费队列的架构模式(如“生产者-消费者”模式)都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”(Thread-per-Request)的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。\n可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。\nThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。\n在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。\n（三）可重入代码这种代码也叫做纯代码(Pure Code)，可以在代码执行的任何时刻中断它，转而去执行另外一段代码(包括递归调用它本身)，而在控制权返回后，原来的程序不会出现任何错误。\n可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。\n\n","slug":"并发/并发基础","date":"2024-12-03T14:35:07.000Z","categories_index":"八股","tags_index":"java,并发基础,并发框架","author_index":"Ivan"},{"id":"293c17b4d2a4292133cc4d1ffd7f8725","title":"计算机网络","content":"OSI模型、TCP&#x2F;IP模型、五层模型 ？\n刚开始学习的小伙伴一定会被这些搞懵逼的，傻傻分不清哦。\n这个所谓的七层模型，实际上那帮搞学术的弄出来的，但是很可惜，并没有流行开了，主要原因就是搭建这样的体系架构网络很复杂。（了解一下就行了）\nTCP&#x2F;IP网络模型是目前最流行的网络协议模型。在我们的实际生活中被广泛的使用。\n最后这个五层协议，主要是为了教学需要而设计的，了解一下即可，但是我还是会简单介绍的。\nTCP&#x2F;IP模型每一层的作用？\n应用层\n这是我们大部分开发最为熟悉的一层，应用层对于我们来说，是相对可控的，因为传输层及以下是操作系统的网络协议栈接管，用户态的我怎么敢触碰内核态的你。\n你所熟知的各种协议，比如 HTTP、HTTPS、DNS等，都属于应用层协议。\n\n传输层\n这一层的协议就少了，就两个：TCP和UDP\n之后的文章会做详细的讲解，这里简单说一下两个协议的特点。\nTCP提供面向连接的、可靠的传输服务；UDP提供无连接、尽最大努力交付的传输服务。\n\n网络层\nIP协议起了至关重要的作用，想一下，现在的网络体系，离得开IP嘛？\n\n网络接口层\n对于上层的协议来说，这一层就是数据的发送层，实际上，并不是，后面会说。\n\n\n数据发送的大致流程？\n应用层将需要发送的数据交给传输层，传输层拿到后加上TCP头部，向下交给网络层，网络层又加上IP头部，交给网络接口层，加上帧头和帧尾，然后发出去。\n（上层协议委托的数据对于下层协议来说是透明的，比如说对于网络层来说，它是不知道有TCP头部和应用数据之分的，只会认为是一个整体）\n网络接口层简介物理层没有什么好说的，这里主要说一下数据链路层。\n数据链路层的协议很多，但是他们都面临着三个问题：封装成帧、透明传输和差错检测\n\n封装成帧\n数据链路层会将网络层交付的数据添加首部和尾部，这就封装成了一个帧，首部和尾部就标识了该帧的开始与结束。\n帧长 &#x3D; 首部长度 + 数据段长度 + 尾部长度。\nMTU（最大传输单元） —— 数据部分长度限制，看图：\n\n帧定界符：就是表示一个帧的开始与结束的标志。=&gt; 有个场景，如果发送端发送的时候，突然“掉线”了，那么接收端就永远不会收到帧结束符。等到下一个帧的帧开始符到达时，接收端就知道上一个帧不完整了，就会把它丢弃。\n\n\n透明传输\n这个问题与数据链路层的机制有关系。数据链路层奉行一种“来者不拒”的理念，“只要给我的，我都要”，对于帧的隔离，识别比特流中的定界符就好了。也就是说，数据链路层并不知道你传的内容是些什么玩意儿，它只负责去“截断”（找到帧开始符合帧结束符）。所以，什么样的比特组合都能通过该层。对于这些比特流而言，数据链路层就好像不存在一样。\n但是这样会引发一个什么样的问题呢？对于文本数据还好说，里面的内容都是键盘上录入进去的，帧开始符和帧结束符找两个用户录入不进去的字符就好了。可是，如果是一些音视频或者其他的比特流，很难保证里面其中一个字节的比特组合不会与帧开始符和帧结束符不同（毕竟对于数据链路层来说，它唯一能做的就是扫描字节，找到帧定界符）。\n如果数据段中出现了“帧开始”符，那么前面的数据就会被丢弃；如果数据段中出现了“帧结束符”，那么后面的数据就会被丢弃。\n为了解决该问题，发送端在数据链路层封装成帧的时候，如果数据内容里面出现了帧定界符，那么就在对应的字节前面添加一个转义字符，如果转义字符也重复了，那么就再添加一个转移字符。&#x3D;&gt; 该过程称作字节填充或者字节填充。\n\n\n差错检测\n比特差错 &#x3D;&gt; 世界上没有完美无暇的东西，总会出问题的。数据在传输的过程中，可能会出现0变成1，或者1变成0的情况。\n泼出去的水无法改变，那就只能在收到的时候，利用各种手段去检测数据是否完整了。\n在数据链路层，广泛采用循环冗余检验CRC检错技术 &#x3D;&gt; 其实就是数据段后添加一个冗余码（帧检验序列FCS） &#x3D;&gt; 发送端根据一定的算法生成，接收端根据一定的算法检测（别问，问就是了解就行了，难道我还要把算法的逻辑说出来嘛，呜呜呜）。\n值得一提的是，FCS的生成和CRC的运用，都是在硬件层面进行的，非常之快。\n数据链路层只能以一种无限接近1的概率向上抛出帧，保障帧无差错。\n但是依然会出现这三个问题：帧丢失、帧失序、帧重复 &#x3D;&gt; 不能提供可靠的传输服务\n\n\n关于MAC地址相信大家都听过一个词，叫做“MAC地址”，到底是一个什么东西呢？ 它就是一个硬件地址，网卡（或者说网络适配器）厂商在生产的时候，写死在硬件里面的，全球唯一的。 网络适配器有过滤功能。每收到一个MAC帧，先用硬件检测一下MAC帧中的硬件地址，看一下是不是发往本站的。是，则收下；不是，则丢弃。 （所以，MAC地址也叫做硬件地址）\n\n","slug":"计网/计算机网络","date":"2024-12-03T14:23:01.000Z","categories_index":"八股","tags_index":"计算机网络","author_index":"Ivan"},{"id":"282ca770e6df8001dbda062738b2a12a","title":"java面向对象","content":"Java给我的感觉就是一个有一个的类，毕竟类是其代码的基本组织单元。\n对象是类实例化的结果，所以对象有时也被称为实例，从类到对象的过程称为实例化。\n面向对象的三大特点：封装、继承、多态\n封装学术上的东西就不讲了，从开发的视角阐述这个概念。\n通常我们都会将字段的可访问性设置为private，然后通过Getter和Setter方法对外提供查看和设置字段值的接口。\n（我习惯于称作字段，貌似大家都喜欢叫属性）\n上代码：\n12345678910111213141516171819202122public class Person &#123;    private String name;    private int age;        public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;&#125;\n\n这是一个Person类，对人这个实体的抽象。类中有两个字段：name和age，代表人的姓名和年龄。从代码层面上看，Person类外面的任何方法都不能直接访问这两个字段，只能通过类中提供的方法进行访问和修改。\n这就是封装！！！\n至于说有什么有点，AI来吧：\n面向对象编程（OOP）中的封装是一个核心概念，它提供了以下优点：\n\n数据隐藏：封装允许对象隐藏其内部状态和复杂性，只暴露一个清晰的接口给外部世界。这降低了代码的复杂性，并提高了代码的可理解性。\n\n实现细节的保护：通过隐藏内部实现，封装防止了外部代码直接访问对象的内部数据，从而防止了可能的错误或不当的修改。\n\n接口与实现的分离：封装使得对象的内部实现可以独立于其接口进行修改，只要接口保持不变，外部代码就不需要修改。\n\n提高代码的可维护性：由于对象的内部实现被隐藏，修改这些实现不会影响依赖于该对象的代码，这使得维护和更新变得更加容易。\n\n增强代码的安全性：封装可以防止外部代码访问或修改对象的私有成员，这有助于防止潜在的安全风险。\n\n促进重用：封装提供了一个清晰的接口，使得对象可以在不同的程序和环境中重用，而不需要了解其内部工作机制。\n\n减少耦合：封装减少了类与类之间的直接依赖，从而降低了系统中各部分之间的耦合度。\n\n提高代码的可测试性：封装使得单元测试可以针对特定的对象进行，而不需要考虑整个系统的复杂性。\n\n支持多态：封装与多态一起工作，允许基于接口而非实现编程，这使得使用基类指针或引用调用派生类的方法成为可能。\n\n封装继承：在支持继承的语言中，封装允许子类继承父类的属性和方法，同时可以扩展或修改这些属性和方法，而不需要更改外部代码。\n\n促进模块化设计：封装鼓励将系统分解成模块或类，每个模块或类都有自己的职责，这有助于构建更大规模的系统。\n\n提高代码的组织性：封装要求将相关的数据和操作这些数据的方法组合在一起，这有助于提高代码的组织性和结构化。\n\n\n总的来说，封装是面向对象设计的一个关键原则，它有助于创建更健壮、更灵活和更易于维护的软件。\n随便扫一眼就行了。。。\n继承这个没有什么好说的，子类可以继承父类非private的字段和方法。\n在实际开发中，我们往往使用父类变量去引用子类对象，除非想调用子类对象的扩展的方法。\n1234567891011121314151617class Student extends Person &#123;    public Student(String name, int age) &#123;        super(name, age);    &#125;    public void sayHello()&#123;        System.out.println(&quot;Hello Java&quot;);    &#125;&#125;class Test &#123;    public static void main(String[] args) &#123;        Person person = new Student(&quot;kaiven&quot;, 20);        System.out.println(person.getName() + person.getAge());    &#125;&#125;\n\n由于Student继承了Person，所以Person类型的变量可以引用Student类型的对象。\n当然，考虑以下语句，能够正常运行：\n如果你尝试了，会发现不行。其实是可以的，因为引用的是Student对象嘛。但是，通不过编译器，因为Person类中没有sayHello这个方法。\n如果我们想调用属于这个子类对象的特有方法，只能通过类型强转去通过编译器的检查：\n1234567class Test &#123;    public static void main(String[] args) &#123;        Person person = new Student(&quot;kaiven&quot;, 20);        Student student = (Student) person;        student.sayHello();    &#125;&#125;\n\n多态不要去抓着这个字眼不放了，你越想就越容易钻牛角尖。\nJava中的多态，分为编译时多态和运行时多态。\n编译时多态指的是方法的重载：\n1234567891011121314class Student extends Person &#123;        public Student(String name, int age) &#123;        super(name, age);    &#125;    public void sayHello()&#123;        System.out.println(&quot;Hello Java&quot;);    &#125;    public void sayHello(String content)&#123;        System.out.println(content);    &#125;&#125;\n\n运行时多态指的是程序中定义的对象引用的具体类型在运行期间才确定。\n运行时多态的三个条件：继承、覆盖（重写）、向上转型\n123456789101112131415161718192021222324252627282930313233class Student extends Person &#123;    public Student(String name, int age) &#123;        super(name, age);    &#125;    @Override    public String getName() &#123;        return &quot;我就不告诉你我的名次&quot;;    &#125;    &#125;class Teacher extends Person&#123;    public Teacher(String name, int age) &#123;        super(name, age);    &#125;        @Override    public String getName() &#123;        return &quot;我可以告诉你我的名字，但是是假的&quot;;    &#125;&#125;class Test &#123;    public static void main(String[] args) &#123;        Person person01 = new Student(&quot;kaiven&quot;, 20);        Person person02 = new Teacher(&quot;jack&quot;, 22);        System.out.println(person01.getName());        System.out.println(person02.getName());    &#125;&#125;\n\nJVM知道应该调用哪个方法的，不用担心。\n\n","slug":"java基础/javamxdx","date":"2024-12-03T13:21:54.000Z","categories_index":"八股","tags_index":"java","author_index":"Ivan"},{"id":"5d0fb8fa16015e90389a3f31d7e8667c","title":"java导学","content":"恭喜你，成功入坑Java开发，以后将走上后端开发的道路。\nJava是一门什么样的编程语言呢？\n（AI的回答）\nJava 是一种广泛使用的编程语言，它由Sun Microsystems（现在是Oracle Corporation的一部分）在1995年发布。Java 被设计为具有跨平台兼容性、安全性、网络中心化和健壮性等特点，这使得它成为了构建企业级应用、Android 应用、网站后台服务和其他类型软件的热门选择。\n以下是Java的一些关键特性：\n\n跨平台兼容性：Java的口号“一次编写，到处运行”（Write Once, Run Anywhere，简称WORA）强调了其跨平台的能力。这意味着在一台机器上编写的Java程序可以在其他装有Java虚拟机（JVM）的机器上运行，而无需任何修改。\n\n面向对象：Java是一种面向对象的语言，它支持类、对象、封装、继承和多态等概念。\n\n内存管理：Java有自动垃圾回收机制，这意味着程序员不需要（也不能）手动管理内存。这减少了内存泄漏和其他内存管理错误的可能性。\n\n健壮性：Java的设计目标之一是创建一个健壮的语言，这意味着它旨在消除某些类别的错误，例如数组越界、野指针等。\n\n安全性：Java提供了一个安全的环境，其中包括一个沙箱执行环境和一个强大的安全管理体系。\n\n多线程：Java内置了对多线程编程的支持，这使得开发多线程应用程序变得相对容易。\n\n网络编程：Java有强大的网络编程支持，这使得它非常适合创建网络应用程序和服务。\n\n开源：Java有一个活跃的开源社区，提供了大量的库和框架，如Spring、Hibernate等，这些工具可以帮助开发者快速构建高质量的应用程序。\n\n\nJava在企业级应用开发中非常流行，也被广泛应用于Android移动应用开发。此外，Java还被用于桌面应用程序、游戏开发、科学计算和教育等领域。随着技术的发展，Java也在不断更新和改进，以适应新的编程范式和市场需求。\n快速的浏览一下就好了，对于一个小白来说，这些都是废话。学就完事儿了，现在，管这么多的概念干嘛。\n学的东西是不是很多嘞？\n的确是这样的，技术这种东西是学不完的。我之所以入坑Java就是因为觉得Java框架的统一性，就只用学一个Spring框架。可是深入学习后，才知道是我肤浅了。\n（之前是写前端的，然后就是觉得前端的生态太乱了，真的是百花齐放，然后转到Java后端，发现，其实也差不多）\n但是无论技术多么的复杂多样，掌握好基本的开发要求，不断的扩展知识和技术，这才是正解。\n如果你和我一样，学一个东西非要去搞清楚底层的运行原理或者源码实现，那么，恭喜你，你会陷入一个内耗循环。\n不是说这样不好，但是技术这个东西真的太多啦。比如说一个消息中间件，就有ActiveMQ、RabbitMQ、Kafka、RocketMQ。。。\n你去学嘛，你去看源码嘛，哈哈。\n对于一门技术，我们的态度应该是：\n\n搞明白基本的概念和特性，明白大致的应用场景\n学会技术的基本使用以及了解一些高级特性的适用场景\n对于基本原理，围绕面试八股展开，出现频率高的，重点学习\n源码嘛，看时间喽（如果有人给你出视频去讲源码了，那就不要浪费时间自己看）\n\n不要总是想着要把技术搞得多么的牛逼，要让面试官觉得你牛逼，那才是真的牛逼。\n（面试，也是一门技术活）\n不过，现在，不用考虑这么多，干就完事儿！\n\n","slug":"java导学","date":"2024-12-03T13:13:19.000Z","categories_index":"八股","tags_index":"java,java基础","author_index":"Ivan"},{"id":"eb843316efe7fc0d2e0c7904a0ae2582","title":"mysql进阶","content":"MySQL的系统架构1、数据库和数据库实例在与MySQL相关的学习和研究中，我们需要搞清楚一些概念：\n\n数据库：按照一定的数据结构来组织、存储和管理数据的仓库，通常由数据库管理系统进行管理。\n数据库管理软件（RDBMS）：就是我们说的数据库管理软件，我们常说的MySQL指的就是它。\n数据库实例：其实就是正在运行的数据库管理程序，一个数据库管理程序我们称作一个数据库实例。\n\n2、MySQL架构\n（现在的话，有个印象就行了）\n（1）MySQL向外提供的交互接口Connectors组件，是MySQL向外提供的交互组件，如java,.net,php等语言可以通过该组件来操作SQL语句，实现\n与SQL的交互。通过客户端&#x2F;服务器通信协议与MySQL建立连接。MySQL 客户端与服务端的通信方式是 “ 半双工\n”。对于每一个 MySQL 的连接，时刻都有一个线程状态来标识这个连接正在做什么。\n（2）管理服务组件和工具组件提供MySQL的各项服务组件和管理工具，如备份(Backup)，恢复(Recovery)，安全管理(Security)等功能。\n（3）连接池组件负责监听客户端向MySQL Server端的各种请求，接收请求，转发请求到目标模块。每个成功连接MySQL Server的客户请求都会被创建或分配一个线程，该线程负责客户端与MySQL Server端的通信，接收客户端发送的命令，传递服务端的结果信息等。\n（4）SQL接口组件接收用户SQL命令，如DML,DDL和存储过程等，并将最终结果返回给用户。\n（5）查询分析器组件首先分析SQL命令语法的合法性，并进行抽象语法树解析，如果sql有语法错误，会抛出异常信息。\n（6）优化器组件对SQL命令按照标准流程进行优化分析，mysql会按照它认为的最优方式进行优化，选用成本最小的执行计划。\n（7）缓存组件缓存和缓冲组件，这里边的内容我们后边会详细的讲解。\n（8）MySQL存储引擎MySQL属于关系型数据库，而关系型数据库的存储是以表的形式进行的，对于表的创建，数据的存储，检索，更新等都是由MySQL存储引擎完成的。\nMySQL存储引擎在MySQL中扮演着重要角色。研究过SQL Server和Oracle的读者可能很清楚，这两种数据库的存\n储引擎只有一个，而MySQL的存储引擎种类比较多，如MyIsam存储引擎，InnoDB存储引擎和Memory存储引\n擎。\n因为mysql本身就是开源的，他允许第三方基于MySQL骨架，开发适合自己业务需求的存储引擎。从MySQL存储引擎种类上来说，可以分为官方存储引擎和第三方存储引擎，比较常用的存储引擎包括InnoDB存储引擎，MyIsam 存储引擎和Momery存储引擎。\n3、SQL语句的执行流程\n（图应该都可以看得懂的吧）\n小问题：MySQL8为什么取消了查询缓存？\n锁争用问题：在高并发环境中，查询缓存会引起锁争用问题。每次对查询缓存的读写操作都需要获取锁，这在高并发下会导致锁的争用，进而引发性能瓶颈。\n缓存无效化问题：查询缓存的无效化机制导致缓存命中率较低。当一个表的数据发生变化时（如INSERT、UPDATE、DELETE操作），与该表相关的所有查询缓存都会被无效化。对于写操作频繁的系统，这意味着查询缓存的有效性非常短暂，导致缓存命中率很低，反而增加了缓存维护的开销而没有带来明显的性能提升。\n内存开销：查询缓存的管理需要额外的内存资源，而且如果查询语句的字符大小写、空格或者注释的不同，查询缓存都会认为是不同的查询（因为他们的hash值会不同），这可能会导致内存资源的过度消耗。\n\nMySQL的目录结构windows中的目录结构在mysql启动的时候，会从【安装目录】加载软件数据，在运行过程中，会从【数据目录】中读取数据。这两个目\n录我们不要放在一起，避免重新安装软件导致数据丢失：\n\n\nbin目录：用于放置一些可执行的工具文件，如mysql.exe、mysqld.exe、mysqlshow.exe等。\ninclude目录：用于放置一些头文件，如：mysql.h、mysql_ername.h等。（MySQL是C语言写的，这个都知道的吧）\nlib目录：用于放置一系列库文件。\ndata目录：用于放置一些日志文件以及数据库。\nmy.ini文件：MySQL的配置文件，MySQL实例初始化时会加载该文件中的内容\n\n\ndata目录中，每个文件夹对应一个数据库，数据库中的表就是一个又一个的文件。\nLinux中的文件目录这个和windows下的文件目录是差不多的，如果是默认的安装方式的话，文件是分散在不同地方的。\n（百度或者问AI）\n字符集和排序规则mysql支持大量的字符集，但是我们通常使用的是utf8，【show collation】命令可以查看mysql支持的所有的排序规则和字符集，如下所示部分：\n1show collation like &#x27;%utf8%&#x27;;\n\n\n一种字符集会对应很多的规则：\n\nutf8-polish-ci，表示utf-8的字符集的波兰语的比较规则，ci代表忽略大小写。\n\nutf8-general-ci，就是通用的忽略大小写的utf8字符集比较规则。\n\nutf8mb4_0900_ai_ci中的0900指的是Unicode 9.0的规范，后边的后缀代表不区分重音也不区分大小写，他是utf8mb4字符集一个新的通用排序归则。\n\n\n\nutf8和utf8mb4的区别：\n\nutf8mb3(utf-8)：使用1~3个字节表示字符，utf8默认就是utf8mb3。\n\nutf8mb4：使用1~4个字节表示字符，他是utf8的超集，甚至可以存储很多【emoji表情?????】，\n\nmysql8.0已经默认字符集设置为utf8mb4。\n\n\n【字符集】和【比较规则】可以作用在全局、数据库、表、甚至是列级别。（想了解的自行百度怎么设置，大家最熟悉的莫过于在创建库和表的时候指定字符集和比较规则吧）\nMySQL修改配置的方法1、修改全局变量很显然，这些东西你百度都能得到的，这里就不去复制粘贴了。全局修改的变量对每一个会话都起作用。\n2、当前会话的变量这个修改的作用域只对某一个会话起作用。\n3、修改配置文件先看一个示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225[client]port = 3306socket = /tmp/mysql.sock[mysqld]port = 3306basedir = /project/mysql/mysql-8.0.18datadir = /project/mysql/datapid-file = /project/mysql/mysql-8.0.18/mysqld.pidsocket = /tmp/mysql.socktmpdir = /project/mysql/tmpuser = mysql#关闭MySQL X plugin（33060）mysqlx=0###日志配置------innodb_log_file_size = 1Glog_error = /project/mysql/mysql-8.0.18/log/error.logslow_query_log = 1long_query_time = 5slow_query_log_file = /project/mysql/mysql-8.0.18/log/slow.log#记录没有索引导致的慢查询###连接配置------#最大连接数max_connections = 3000#最大错误连接数max_connect_errors = 10#连接闲置超时时间interactive_timeout = 1800wait_timeout = 1800#连接响应超时时间connect-timeout = 60###默认配置（插件、字符------default_authentication_plugin = mysql_native_passwordcharacter-set-server = utf8sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLESinnodb_log_file_size = 1024M#关闭InnoDB严格模式，防止报错 Row size too large (&gt; 8126)innodb_strict_mode=0default-storage-engine=INNODBbind-address = 0.0.0.0#域名解析，设置为1之后就不能直接127.0.0.1连接数据库，需要root@127.0.0.1#skip_name_resolve = 1#忽略大小写，此项很重要（MySQL8之后的版本必须在初始化就设定此参数，初始化之后配置更改不生效）lower_case_table_names = 1###主备相关------server-id = 25log-bin = backup.log#二进制日志格式,三种模式：statement语句&gt;模式,row行模式，mixed混合模式binlog_format = mixedmax_binlog_size = 1Gexpire_logs_days = 7#事务提交前产生的日志缓存binlog_cache_size = 16M#Auto_increment_increment和auto_increment_offset用于主－主服务器（master-to-master）复制，避免主键冲突#为了避免两台服务器同时做更新时自增长字段的值之间发生冲突。一般在主主同步配置时，需要将两台服务器的auto_increment_increment增长量都配置为2（根据从库节点数量配置），而要把auto_increment_offset分别配置为1（主库）和2（从库）#递增值auto_increment_increment = 2#初始值auto_increment_offset = 1#表示需要记录二进制日志的数据库binlog_do_db=csspbinlog_do_db=mysql#从库配置replicate_do_db=cssp#表示不需要记录二进制日志的数据库binlog_ignore_db=information_schema#忽略表replicate-wild-ignore-table=pva_db.pva_login_%replicate-wild-ignore-table=pva_db.pva_login_log#忽略错误代码（从库配置）slave-skip-errors = 1032,1062,126,1114,1146,1048,1396#自动清空不再需要中继日志（从库配置）relay-log-purge = 1###系统资源相关------#接收连接请求队列back_log = 600#最大打开文件数（前提mysql用户需要调整最大打开文件数）open_files_limit = 10240#所有线程打开表数量table_open_cache = 512#处理请求包最大大小max_allowed_packet = 32M#临时表最大大小tmp_table_size = 512M#独立内存表所允许最大容量max_heap_table_size = 512M#用于索引块的缓冲区大小key_buffer_size = 64M#查询排序的缓冲区大小sort_buffer_size = 8M#读操作的缓冲区大小read_buffer_size = 8M#联表查询缓冲区大小join_buffer_size = 8M#批量数据插入缓存bulk_insert_buffer_size = 120M#保存索引以及原始数据的缓冲池（原则上最大为系统内存的 80%）innodb_buffer_pool_size = 2G#脏页比例，脏页占innodb_buffer_pool_size的比例时，触发刷脏页到磁盘（25~50）innodb_max_dirty_pages_pct = 30#事务提交 flushinnodb_flush_log_at_trx_commit = 1#1，（默认值）每一次提交刷新日志到磁盘#2，先写入缓存，由系统设置每秒刷新日志到磁盘（可能丢失1~2秒的数据）###多线程优化------#可重新被利用保存在缓存中的线程数量thread_cache_size = 300###其他配置------#占用内存过高调整以下参数配置#table_definition_cache = 400#open_files_limit = 2048#table_open_cache = 256#跳过密码表检查#skip-grant-tables\n\n修改了配置文件需要重启MySQL服务实例重新加载。\n内置数据库\nmysql：这个库很重要，他是mysql的核心数据库，负责存储数据库的用户、权限设置、关键字等mysql自己需要使用，控制和管理的信息。\n\ninformation_schema：这个数据库维护了数据库其他表的一些描述性信息，也称为元数据。比如，当前有哪\n\n\n些表，哪些视图，哪些触发器，哪些列等。\n\nperformation_schema：这个数据库用来存储mysql服务器运行过程中的一些状态信息，是做性能监控的。\n\n比如最近执行了什么sql语句，内存使用情况等\n\nsys：结合information_schema和performation_schema的数据，能更方便的了解mysql服务器的性能信\n\n息。\n\n2024.11.05\nwriteBy kaiven\n","slug":"mysql进阶","date":"2024-12-03T12:56:15.000Z","categories_index":"八股","tags_index":"mysql","author_index":"Ivan"},{"id":"76e26cf6d70a50daf8e75fb7d566964d","title":"面试官到底喜欢什么样的人？","content":"面试官到底喜欢什么样的人？在统一批次的面试中，可能就有好几百号人，无可否认的是，我们都喜欢优秀的人，都想和优秀的人共事，那怎么表现出我们的优秀呢？\n面试官喜欢爱学习、爱动脑、有技术广度和深度并且有实际经验的人。\n面试时间一般30分钟左右，我们必须通过自己的话术，去展现【爱学习、爱动脑、技术广度和深度以及实际经验】给他&#x2F;她看。\n建立正确的面试心态在这种大环境下，面试时间会被拉的很长，一面、二面、三面……面试的环节越多，那么你挂掉的概率也就越大，但没办法，就是这么卷。。。\n我们不需要唬住所有的面试官，因为在面试的过程中，面试官是用他最熟悉的东西去问题，有可能他熟悉的地方你并不是特别的熟悉，所以可能就会出现答得不好或者答不上来的情况，这很正常。。。\n我们做的事情，就是拿下我们能拿下的面试官。其实大部分面试官都是一边工作一边去面试的，所以八股的知识也就一般。比如说大厂的面试官，可能就会对原理性的东西进行深层次的拷打，如果你还只能回答出一些表面性的东西或者说大家都会说的一些东西，那么就不能体现出你的优势，面试挂掉的概率极大。当然，这些面试官也不是我们的菜。\n这小节最重要的一点就是：你对面试准备有多充分，就决定了你能找到什么样的工作！\n（不会说你随便糊弄了一下就能拿到一份很好的offer，而别人准备了大半年却颗粒无收，匹配机制嘛，找到符合自己目前口味的面试官，才是重点）\n如何把面试官拉倒坑里？上文也叙述过，其实大部分面试官的水平也一般，所以他其实也不知道自己该问些什么东西，如果你也没有对他进行相关的引导的话，他不就只能随便问了嘛。\n如何引导面试官？原理其实也比较简单：\n\n自我介绍阶段，突出描述自己擅长的部分\n回答问题的时候，为下一个问题做铺垫\n\n对于自我介绍，下文会进行详细的叙述。\n我们来说一下第二点，往往面试官问的问题都是层层递进的，会从你对某个问题的回答中捕风捉影，想好下一个要问你的问题。那是不是可以提前预判呢？把面试官引导上你准备好的问题链中去。\n还要一个比较重要的点就是拖延时间，或者说扩展描述，做到问一答三，因为你能回答出来的东西，那肯定是你提前准备好的，你给他暴露的信息越多，他问的点也就越多。但是，短短的半小时，他不可能什么都去问你，一定是从你的问答中挑他感兴趣的点，继续追问。你给他的选项，一定是你准备过的，每个点都这样的去扩展描述，一方面体现出你是一个【爱学习、爱动脑、有技术广度和深度并且有实际经验的人】，另一方面这样也将面试时间的主导权交到了自己的手上，你一直再说，面试官一直在听，问个两三个问题后，他可能就不会在问其他的了。\n（面试也要占用面试官的时间，谁不想休息啊，而且人家也有自己的事情要去做）\n面试的本质是什么？问题：面试是介绍你自己还是你的项目？\n答案：一定是介绍你自己。本质上来说，大多数的项目都是CRUD，没有什么特别的亮点。那和面试官对话的时候，就不要关注项目本身了，而是要去关注某个功能的实现，简单描述一下项目中的功能是怎么去实现的，然后重点叙述一下该方式存在什么样的不足，你会怎么去解决这个问题？\n场景：\n假设你现在的项目就是一个纯粹的后端管理系统，登录方式采用的是JavaWeb的Cookie + Session。\n针对该功能的叙述：\n由于我这个项目其实是一个学习项目，算不上真正意义上的生产级别的项目，所以登录功能只是采用了JavaWeb的 Cookie + Session 这样一种简单的形式。但是呢，这样做存在一些问题。比如说在分布式的环境中，多个JVM实例无法共享 Session ，就会出现明明用户已经登录了，但是后续的请求打在了其他机器上，导致用户会出现重复登录的情况，用户体验感不好。针对这个问题，需要我们去实现session的共享嘛，常见的实现方式就是将 Session 对象序列化放入 Redis 中进行共享，然后每一次的登录请求都去查询Redis。但是呢，这种方式也会出现一定的问题，。。。。。\n（你需要根据实际的场景去提前写好这些话术，你这一套话术下来，是不是达到了拖延时间的效果？你准备的这些话术中的内容的扩展问题你也回去准备的，是不是将面试官引入坑里面了？这一堆东西下来，是不是体现了你是一个【爱学习、爱动脑、有技术广度和深度并且有实际经验的人】？）\n公司招你肯定不是简单的让你做你熟悉的业务，而是想给你什么业务你都能够应对。\n你是一个厨师，业务需求就是食材，只会做几道菜的不叫做厨师。\n项目的亮点角度：架构、业务拆分、技术选型、大数据量处理\n如何写好简历避免已读不回？简历到底看什么？（校招）\n学历（至少全日制本科）\n专业排名（非科班成绩优异也可以，至少证明学习能力很强 &#x3D;&gt; 黑魔法）\n荣誉奖项（黑魔法，如果是大厂的话，斟酌一下，很有可能会让你提供证明材料）\n实习经历（大厂很加分，也可以黑魔法，但是不建议）\n\n学历这个东西确实没有办法，现在的大环境就是这样的，如果你是专科的同学，那么请先专升本，否则你可能会感慨世界的炎凉。（专升本你就写你本科的学历就好了，装傻）\n专业排名真的是最好造假的了，前20%？可以不？谁会去管呢？\n荣誉奖项也是，基本上不会查的，而且你也不会写什么特别高级的奖项，比如说 ACM金牌。。。（当然，如果是大厂的话，背景调查可能比较严格哦，请斟酌）\n实习经历也可以造假的，对，没错，只要你能唬住面试官。（大厂同样需要斟酌）\n如果是找实习的同学，那么肯定是没有实习经历这么一说的（除非你有过一段），那么重点在你的项目经历上。\n虽然说面试是介绍我们自己，但是前提是简历得入得了面试官的法眼，否则面试的资格都没有。\n一个项目的基本元素：\n项目名称（次要，但是不能太土）\n个人职责（在项目中负责什么，应届生次要）\n项目的线上地址（重要，增加项目的真实度）\n项目简介（重要，让面试官能够了解你这个项目的业务类型）\n项目的亮点（重要）\n\n对于项目简介，一定要言简意赅，主要是要让面试官知道你这个项目的大概业务有哪些。你做的那些项目基本上都能找到相似且开源的（大部分同学的项目也是根据这些开源的项目改的），所以没必要去过多的介绍。所以，这里你的项目名称最好是见名知意，比如说xx在线教育平台，面试官甚至都不用去读你的项目简介，就知道你这个项目的业务有哪些。\n对于项目的亮点，这个东西，得从实际的项目出发，体现出你的思考，还是那句话，可能项目真的没有什么亮点，就是一个很普通的CURD。但是，你可以通过引入一些其他的技术，去解决了什么问题，优化了什么东西。（无论是公司里面的大项目还是你的小项目，都会有bug和不足，不然为什么要持续的更新迭代，总会有问题的。）而且，你的亮点话术，要做到有针对性，而不是这些语句迁移到其他的项目上都能使用。\n(什么样的场景，通过什么方式，解决了什么问题或者优化了什么东西)\n如何做好自我介绍？（面试中最重要的环节）好的自我介绍有什么用？\n体现出你自己的价值和逻辑思维能力，快速让面试官对你感兴趣\n引导面试官对你进行提问\n\n什么是一份好的自我介绍？\n语言的流利程度，表达能力流畅的人，面试成功率会高很多。因为语言表达流利的话，证明了你的思维逻辑是流畅的，沟通能力是OK的。\n把自己相关的优势介绍清楚。\n能够讲清楚自己在项目中的职责，成果，并且有量化的数据支撑（人对数字是比较敏感的）。\n拉平和面试官之间的信息差，让面试官能够快速带入我们的项目中，能清楚他想要问的问题。\n\n很有必要去手写一份800字左右的自我介绍，在面试之前不断的打磨，这样才能在面试的时候流利的阐述。\n八股文怎么去准备怎么去回答？八股文这个东西是必须背的，你很难保证面试官不会去问，特别是对于应届生而言。\n八股文大概考什么？市面上的八股文这么多，动不动就几十万字的，没必要啊。这东西是有重点的：\n\njava基础：集合类、JVM、锁、多线程（这里会有实操，比如写代码实现三个线程交替打印“abc”）。\nJUC、AQS、线程池。线程池的核心参数，拒绝策略，队列有哪些。\nSpring、SpringMVC、SpringBoot：老演员了，问的也就那些东西（这里可以结合设计模式去讲，Spring中运用了大量的设计模式）。\nMySQL：。。。\nRedis：数据结构，一些机制。\n\n这里给鱼皮（B站搜索：程序员鱼皮）的面试鸭刷题网站打一个广告：https://www.mianshiya.com/\n这是一个专门为程序员提供的在线刷题平台，涵盖从IT各大学科的面试经典八股文，支持网页端和小程序端，目前（2024.10.20）永久会员只需要 129 元。\n（不要求每一道八股文你都能回答得很好，但是你必须有一两道八股文讲得非常出彩，结合自己的理解和实际的业务场景）\n总结总的来说，面试的宗旨就是：通过和面试官的沟通，去展示你的优秀，你是一个爱学习、爱动脑、有技术广度和深度并且有实际经验的人。\n","slug":"面试","date":"2024-12-03T12:35:49.000Z","categories_index":"","tags_index":"面试","author_index":"Ivan"},{"id":"c19a7ddcfd0a318acc34ae24f5ee7e8b","title":"Java基础面试题","content":"# Java基础面试题# 概念# 说一下Java的特点主要有以下的特点：\n\n平台无关性：Java的“编写一次，运行无处不在”哲学是其最大的特点之一。Java编译器将源代码编译成字节码（bytecode），该字节码可以在任何安装了Java虚拟机（JVM）的系统上运行。\n面向对象：Java是一门严格的面向对象编程语言，几乎一切都是对象。面向对象编程（OOP）特性使得代码更易于维护和重用，包括类（class）、对象（object）、继承（inheritance）、多态（polymorphism）、抽象（abstraction）和封装（encapsulation）。\n内存管理：Java有自己的垃圾回收机制，自动管理内存和回收不再使用的对象。这样，开发者不需要手动管理内存，从而减少内存泄漏和其他内存相关的问题。\n\n# Java为什么是跨平台的？Java 能支持跨平台，主要依赖于 JVM 关系比较大。\nJVM也是一个软件，不同的平台有不同的版本。我们编写的Java源码，编译后会生成一种 .class 文件，称为字节码文件。Java虚拟机就是负责将字节码文件翻译成特定平台下的机器码然后运行。也就是说，只要在不同平台上安装对应的JVM，就可以运行字节码文件，运行我们编写的Java程序。\n而这个过程中，我们编写的Java程序没有做任何改变，仅仅是通过JVM这一”中间层“，就能在不同平台上运行，真正实现了”一次编译，到处运行“的目的。\nJVM是一个”桥梁“，是一个”中间件“，是实现跨平台的关键，Java代码首先被编译成字节码文件，再由JVM将字节码文件翻译成机器语言，从而达到运行Java程序的目的。\n编译的结果不是生成机器码，而是生成字节码，字节码不能直接运行，必须通过JVM翻译成机器码才能运行。不同平台下编译生成的字节码是一样的，但是由JVM翻译成的机器码却不一样。\n所以，运行Java程序必须有JVM的支持，因为编译的结果不是机器码，必须要经过JVM的再次翻译才能执行。即使你将Java程序打包成可执行文件（例如 .exe），仍然需要JVM的支持。\n跨平台的是Java程序，不是JVM。JVM是用C&#x2F;C++开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的JVM。\n\n# JVM、JDK、JRE三者关系？\n它们之间的关系如下：\n\nJVM是Java虚拟机，是Java程序运行的环境。它负责将Java字节码（由Java编译器生成）解释或编译成机器码，并执行程序。JVM提供了内存管理、垃圾回收、安全性等功能，使得Java程序具备跨平台性。\nJDK是Java开发工具包，是开发Java程序所需的工具集合。它包含了JVM、编译器（javac）、调试器（jdb）等开发工具，以及一系列的类库（如Java标准库和开发工具库）。JDK提供了开发、编译、调试和运行Java程序所需的全部工具和环境。\nJRE是Java运行时环境，是Java程序运行所需的最小环境。它包含了JVM和一组Java类库，用于支持Java程序的执行。JRE不包含开发工具，只提供Java程序运行所需的运行环境。\n\n# 为什么Java解释和编译都有？首先在Java经过编译之后生成字节码文件，接下来进入JVM中，就有两个步骤编译和解释。 如下图：\n\n编译性：\n\nJava源代码首先被编译成字节码，JIT 会把编译过的机器码保存起来,以备下次使用。\n\n解释性：\n\nJVM中一个方法调用计数器，当累计计数大于一定值的时候，就使用JIT进行编译生成机器码文件。否则就是用解释器进行解释执行，然后字节码也是经过解释器进行解释运行的。\n\n所以Java既是编译型也是解释性语言，默认采用的是解释器和编译器混合的模式。\n# jvm是什么JVM是 java 虚拟机，主要工作是解释自己的指令集（即字节码）并映射到本地的CPU指令集和OS的系统调用。\nJVM屏蔽了与操作系统平台相关的信息，使得Java程序只需要生成在Java虚拟机上运行的目标代码（字节码），就可在多种平台上不加修改的运行，这也是Java能够“一次编译，到处运行的”原因。\n# 编译型语言和解释型语言的区别？编译型语言和解释型语言的区别在于：\n\n编译型语言：在程序执行之前，整个源代码会被编译成机器码或者字节码，生成可执行文件。执行时直接运行编译后的代码，速度快，但跨平台性较差。\n解释型语言：在程序执行时，逐行解释执行源代码，不生成独立的可执行文件。通常由解释器动态解释并执行代码，跨平台性好，但执行速度相对较慢。\n典型的编译型语言如C、C++，典型的解释型语言如Python、JavaScript。\n\n# Python和Java区别是什么？\nJava是一种已编译的编程语言，Java编译器将源代码编译为字节码，而字节码则由Java虚拟机执行\npython是一种解释语言，翻译时会在执行程序的同时进行翻译。\n\n# 数据类型# 八种基本的数据类型Java支持数据类型分为两类： 基本数据类型和引用数据类型。\n基本数据类型共有8种，可以分为三类：\n\n数值型：整数类型（byte、short、int、long）和浮点类型（float、double）\n字符型：char\n布尔型：boolean\n\n\n8种基本数据类型的默认值、位数、取值范围，如下表所示：\n\nFloat和Double的最小值和最大值都是以科学记数法的形式输出的，结尾的“E+数字”表示E之前的数字要乘以10的多少倍。比如3.14E3就是3.14×1000&#x3D;3140，3.14E-3就是3.14&#x2F;1000&#x3D;0.00314。\n注意一下几点：\n\njava八种基本数据类型的字节数:1字节(byte、boolean)、 2字节(short、char)、4字节(int、float)、8字节(long、double)\n浮点数的默认类型为double（如果需要声明一个常量为float型，则必须要在末尾加上f或F）\n整数的默认类型为int（声明Long型在末尾加上l或者L）\n八种基本数据类型的包装类：除了char的是Character、int类型的是Integer，其他都是首字母大写\nchar类型是无符号的，不能为负，所以是0开始的\n\n# long和int可以互转吗 ？可以的，Java中的long和int可以相互转换。由于long类型的范围比int类型大，因此将int转换为long是安全的，而将long转换为int可能会导致数据丢失或溢出。\n将int转换为long可以通过直接赋值或强制类型转换来实现。例如：\n12int intValue = 10;long longValue = intValue; // 自动转换，安全的\n\n将long转换为int需要使用强制类型转换，但需要注意潜在的数据丢失或溢出问题。\n\n例如：\n12long longValue = 100L;int intValue = (int) longValue; // 强制类型转换，可能会有数据丢失或溢出\n\n在将long转换为int时，如果longValue的值超出了int类型的范围，转换结果将是截断后的低位部分。因此，在进行转换之前，建议先检查longValue的值是否在int类型的范围内，以避免数据丢失或溢出的问题。\n# 数据类型转换方式你知道哪些？\n自动类型转换（隐式转换）：当目标类型的范围大于源类型时，Java会自动将源类型转换为目标类型，不需要显式的类型转换。例如，将int转换为long、将float转换为double等。\n强制类型转换（显式转换）：当目标类型的范围小于源类型时，需要使用强制类型转换将源类型转换为目标类型。这可能导致数据丢失或溢出。例如，将long转换为int、将double转换为int等。语法为：目标类型 变量名 &#x3D; (目标类型) 源类型。\n字符串转换：Java提供了将字符串表示的数据转换为其他类型数据的方法。例如，将字符串转换为整型int，可以使用Integer.parseInt()方法；将字符串转换为浮点型double，可以使用Double.parseDouble()方法等。\n数值之间的转换：Java提供了一些数值类型之间的转换方法，如将整型转换为字符型、将字符型转换为整型等。这些转换方式可以通过类型的包装类来实现，例如Character类、Integer类等提供了相应的转换方法。\n\n# 类型互转会出现什么问题吗？\n数据丢失：当将一个范围较大的数据类型转换为一个范围较小的数据类型时，可能会发生数据丢失。例如，将一个long类型的值转换为int类型时，如果long值超出了int类型的范围，转换结果将是截断后的低位部分，高位部分的数据将丢失。\n数据溢出：与数据丢失相反，当将一个范围较小的数据类型转换为一个范围较大的数据类型时，可能会发生数据溢出。例如，将一个int类型的值转换为long类型时，转换结果会填充额外的高位空间，但原始数据仍然保持不变。\n精度损失：在进行浮点数类型的转换时，可能会发生精度损失。由于浮点数的表示方式不同，将一个单精度浮点数(float)转换为双精度浮点数(double)时，精度可能会损失。\n类型不匹配导致的错误：在进行类型转换时，需要确保源类型和目标类型是兼容的。如果两者不兼容，会导致编译错误或运行时错误。\n\n# 为什么用bigDecimal 不用double ？double会出现精度丢失的问题，double执行的是二进制浮点运算，二进制有些情况下不能准确的表示一个小数，就像十进制不能准确的表示1&#x2F;3(1&#x2F;3&#x3D;0.3333…)，也就是说二进制表示小数的时候只能够表示能够用1&#x2F;(2^n)的和的任意组合，但是0.1不能够精确表示，因为它不能够表示成为1&#x2F;(2^n)的和的形式。\n比如：\n12345678910System.out.println(0.05 + 0.01);System.out.println(1.0 - 0.42);System.out.println(4.015 * 100);System.out.println(123.3 / 100);输出：0.0600000000000000050.5800000000000001401.499999999999941.2329999999999999\n\n可以看到在Java中进行浮点数运算的时候，会出现丢失精度的问题。那么我们如果在进行商品价格计算的时候，就会出现问题。很有可能造成我们手中有0.06元，却无法购买一个0.05元和一个0.01元的商品。因为如上所示，他们两个的总和为0.060000000000000005。这无疑是一个很严重的问题，尤其是当电商网站的并发量上去的时候，出现的问题将是巨大的。可能会导致无法下单，或者对账出现问题。\n而 Decimal 是精确计算 , 所以一般牵扯到金钱的计算 , 都使用 Decimal。\n123456789101112131415161718import java.math.BigDecimal;public class BigDecimalExample &#123;    public static void main(String[] args) &#123;        BigDecimal num1 = new BigDecimal(&quot;0.1&quot;);        BigDecimal num2 = new BigDecimal(&quot;0.2&quot;);        BigDecimal sum = num1.add(num2);        BigDecimal product = num1.multiply(num2);        System.out.println(&quot;Sum: &quot; + sum);        System.out.println(&quot;Product: &quot; + product);    &#125;&#125;//输出Sum: 0.3Product: 0.02\n\n在上述代码中，我们创建了两个BigDecimal对象num1和num2，分别表示0.1和0.2这两个十进制数。然后，我们使用add()方法计算它们的和，并使用multiply()方法计算它们的乘积。最后，我们通过System.out.println()打印结果。\n这样的使用BigDecimal可以确保精确的十进制数值计算，避免了使用double可能出现的舍入误差。需要注意的是，在创建BigDecimal对象时，应该使用字符串作为参数，而不是直接使用浮点数值，以避免浮点数精度丢失。\n# 装箱和拆箱是什么？装箱（Boxing）和拆箱（Unboxing）是将基本数据类型和对应的包装类之间进行转换的过程。\n12Integer i = 10;  //装箱int n = i;   //拆箱\n\n自动装箱主要发生在两种情况，一种是赋值时，另一种是在方法调用的时候。\n\n\n\n\n\n\n\n\n\n赋值时\n这是最常见的一种情况，在Java 1.5以前我们需要手动地进行转换才行，而现在所有的转换都是由编译器来完成。\n1234567//before autoboxingInteger iObject = Integer.valueOf(3);Int iPrimitive = iObject.intValue()//after java5Integer iObject = 3; //autobxing - primitive to wrapper conversionint iPrimitive = iObject; //unboxing - object to primitive conversion\n\n\n\n\n\n\n\n\n\n\n方法调用时\n当我们在方法调用时，我们可以传入原始数据值或者对象，同样编译器会帮我们进行转换。\n12345678public static Integer show(Integer iParam)&#123;   System.out.println(&quot;autoboxing example - method invocation i: &quot; + iParam);   return iParam;&#125;//autoboxing and unboxing in method invocationshow(3); //autoboxingint result = show(3); //unboxing because return type of method is Integer\n\nshow方法接受Integer对象作为参数，当调用show(3)时，会将int值转换成对应的Integer对象，这就是所谓的自动装箱，show方法返回Integer对象，而int result = show(3);中result为int类型，所以这时候发生自动拆箱操作，将show方法的返回的Integer对象转换成int值。\n\n\n\n\n\n\n\n\n\n自动装箱的弊端\n自动装箱有一个问题，那就是在一个循环中进行自动装箱操作的情况，如下面的例子就会创建多余的对象，影响程序的性能。\n1Integer sum = 0; for(int i=1000; i&lt;5000; i++)&#123;   sum+=i; &#125; \n\n上面的代码sum+=i可以看成sum = sum + i，但是+这个操作符不适用于Integer对象，首先sum进行自动拆箱操作，进行数值相加操作，最后发生自动装箱操作转换成Integer对象。其内部变化如下\n1int result = sum.intValue() + i; Integer sum = new Integer(result); \n\n由于我们这里声明的sum为Integer类型，在上面的循环中会创建将近4000个无用的Integer对象，在这样庞大的循环中，会降低程序的性能并且加重了垃圾回收的工作量。因此在我们编程时，需要注意到这一点，正确地声明变量类型，避免因为自动装箱引起的性能问题。\n# Java为什么要有Integer？Integer对应是int类型的包装类，就是把int类型包装成Object对象，对象封装有很多好处，可以把属性也就是数据跟处理这些数据的方法结合在一起，比如Integer就有parseInt()等方法来专门处理int型相关的数据。\n另一个非常重要的原因就是在Java中绝大部分方法或类都是用来处理类类型对象的，如ArrayList集合类就只能以类作为他的存储对象，而这时如果想把一个int型的数据存入list是不可能的，必须把它包装成类，也就是Integer才能被List所接受。所以Integer的存在是很必要的。\n\n\n\n\n\n\n\n\n\n泛型中的应用\n在Java中，泛型只能使用引用类型，而不能使用基本类型。因此，如果要在泛型中使用int类型，必须使用Integer包装类。例如，假设我们有一个列表，我们想要将其元素排序，并将排序结果存储在一个新的列表中。如果我们使用基本数据类型int，无法直接使用Collections.sort()方法。但是，如果我们使用Integer包装类，我们就可以轻松地使用Collections.sort()方法。\n123456List&lt;Integer&gt; list = new ArrayList&lt;&gt;();list.add(3);list.add(1);list.add(2);Collections.sort(list);System.out.println(list);\n\n\n\n\n\n\n\n\n\n\n转换中的应用\n在Java中，基本类型和引用类型不能直接进行转换，必须使用包装类来实现。例如，将一个int类型的值转换为String类型，必须首先将其转换为Integer类型，然后再转换为String类型。\n1234int i = 10;Integer integer = new Integer(i);String str = integer.toString();System.out.println(str);\n\n\n\n\n\n\n\n\n\n\n集合中的应用\nJava集合中只能存储对象，而不能存储基本数据类型。因此，如果要将int类型的数据存储在集合中，必须使用Integer包装类。例如，假设我们有一个列表，我们想要计算列表中所有元素的和。如果我们使用基本数据类型int，我们需要使用一个循环来遍历列表，并将每个元素相加。但是，如果我们使用Integer包装类，我们可以直接使用stream()方法来计算所有元素的和。\n123456List&lt;Integer&gt; list = new ArrayList&lt;&gt;();list.add(3);list.add(1);list.add(2);int sum = list.stream().mapToInt(Integer::intValue).sum();System.out.println(sum);\n\n# Integer相比int有什么优点？int是Java中的原始数据类型，而Integer是int的包装类。\nInteger和 int 的区别：\n\n基本类型和引用类型：首先，int是一种基本数据类型，而Integer是一种引用类型。基本数据类型是Java中最基本的数据类型，它们是预定义的，不需要实例化就可以使用。而引用类型则需要通过实例化对象来使用。这意味着，使用int来存储一个整数时，不需要任何额外的内存分配，而使用Integer时，必须为对象分配内存。在性能方面，基本数据类型的操作通常比相应的引用类型快。\n自动装箱和拆箱：其次，Integer作为int的包装类，它可以实现自动装箱和拆箱。自动装箱是指将基本类型转化为相应的包装类类型，而自动拆箱则是将包装类类型转化为相应的基本类型。这使得Java程序员更加方便地进行数据类型转换。例如，当我们需要将int类型的值赋给Integer变量时，Java可以自动地将int类型转换为Integer类型。同样地，当我们需要将Integer类型的值赋给int变量时，Java可以自动地将Integer类型转换为int类型。\n空指针异常：另外，int变量可以直接赋值为0，而Integer变量必须通过实例化对象来赋值。如果对一个未经初始化的Integer变量进行操作，就会出现空指针异常。这是因为它被赋予了null值，而null值是无法进行自动拆箱的。\n\n# 那为什么还要保留int类型？包装类是引用类型，对象的引用和对象本身是分开存储的，而对于基本类型数据，变量对应的内存块直接存储数据本身。\n因此，基本类型数据在读写效率方面，要比包装类高效。除此之外，在64位JVM上，在开启引用压缩的情况下，一个Integer对象占用16个字节的内存空间，而一个int类型数据只占用4字节的内存空间，前者对空间的占用是后者的4倍。\n也就是说，不管是读写效率，还是存储效率，基本类型都比包装类高效。\n# 说一下 integer的缓存Java的Integer类内部实现了一个静态缓存池，用于存储特定范围内的整数值对应的Integer对象。\n默认情况下，这个范围是-128至127。当通过Integer.valueOf(int)方法创建一个在这个范围内的整数对象时，并不会每次都生成新的对象实例，而是复用缓存中的现有对象，会直接从内存中取出，不需要新建一个对象。\n# 面向对象# 怎么理解面向对象？简单说说封装继承多态面向对象是一种编程范式，它将现实世界中的事物抽象为对象，对象具有属性（称为字段或属性）和行为（称为方法）。面向对象编程的设计思想是以对象为中心，通过对象之间的交互来完成程序的功能，具有灵活性和可扩展性，通过封装和继承可以更好地应对需求变化。\nJava面向对象的三大特性包括：封装、继承、多态：\n\n封装：封装是指将对象的属性（数据）和行为（方法）结合在一起，对外隐藏对象的内部细节，仅通过对象提供的接口与外界交互。封装的目的是增强安全性和简化编程，使得对象更加独立。\n继承：继承是一种可以使得子类自动共享父类数据结构和方法的机制。它是代码复用的重要手段，通过继承可以建立类与类之间的层次关系，使得结构更加清晰。\n多态：多态是指允许不同类的对象对同一消息作出响应。即同一个接口，使用不同的实例而执行不同操作。多态性可以分为编译时多态（重载）和运行时多态（重写）。它使得程序具有良好的灵活性和扩展性。\n\n# 多态体现在哪几个方面？多态在面向对象编程中可以体现在以下几个方面：\n\n方法重载：\n方法重载是指同一类中可以有多个同名方法，它们具有不同的参数列表（参数类型、数量或顺序不同）。虽然方法名相同，但根据传入的参数不同，编译器会在编译时确定调用哪个方法。\n示例：对于一个 add 方法，可以定义为 add(int a, int b) 和 add(double a, double b)。\n\n\n方法重写：\n方法重写是指子类能够提供对父类中同名方法的具体实现。在运行时，JVM会根据对象的实际类型确定调用哪个版本的方法。这是实现多态的主要方式。\n示例：在一个动物类中，定义一个 sound 方法，子类 Dog 可以重写该方法以实现 bark，而 Cat 可以实现 meow。\n\n\n接口与实现：\n多态也体现在接口的使用上，多个类可以实现同一个接口，并且用接口类型的引用来调用这些类的方法。这使得程序在面对不同具体实现时保持一贯的调用方式。\n示例：多个类（如 Dog, Cat）都实现了一个 Animal 接口，当用 Animal 类型的引用来调用 makeSound 方法时，会触发对应的实现。\n\n\n向上转型和向下转型：\n在Java中，可以使用父类类型的引用指向子类对象，这是向上转型。通过这种方式，可以在运行时期采用不同的子类实现。\n向下转型是将父类引用转回其子类类型，但在执行前需要确认引用实际指向的对象类型以避免 ClassCastException。\n\n\n\n# 多态解决了什么问题？多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类。\n多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 if-else 语句等等\n# 面向对象的设计原则你知道有哪些吗面向对象编程中的六大原则：\n\n单一职责原则（SRP）：一个类应该只有一个引起它变化的原因，即一个类应该只负责一项职责。例子：考虑一个员工类，它应该只负责管理员工信息，而不应负责其他无关工作。\n开放封闭原则（OCP）：软件实体应该对扩展开放，对修改封闭。例子：通过制定接口来实现这一原则，比如定义一个图形类，然后让不同类型的图形继承这个类，而不需要修改图形类本身。\n里氏替换原则（LSP）：子类对象应该能够替换掉所有父类对象。例子：一个正方形是一个矩形，但如果修改一个矩形的高度和宽度时，正方形的行为应该如何改变就是一个违反里氏替换原则的例子。\n接口隔离原则（ISP）：客户端不应该依赖那些它不需要的接口，即接口应该小而专。例子：通过接口抽象层来实现底层和高层模块之间的解耦，比如使用依赖注入。\n依赖倒置原则（DIP）：高层模块不应该依赖低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。例子：如果一个公司类包含部门类，应该考虑使用合成&#x2F;聚合关系，而不是将公司类继承自部门类。\n**最少知识原则 (Law of Demeter)**：一个对象应当对其他对象有最少的了解，只与其直接的朋友交互。\n\n# 重载与重写有什么区别？\n重载（Overloading）指的是在同一个类中，可以有多个同名方法，它们具有不同的参数列表（参数类型、参数个数或参数顺序不同），编译器根据调用时的参数类型来决定调用哪个方法。\n重写（Overriding）指的是子类可以重新定义父类中的方法，方法名、参数列表和返回类型必须与父类中的方法一致，通过@override注解来明确表示这是对父类方法的重写。\n\n重载是指在同一个类中定义多个同名方法，而重写是指子类重新定义父类中的方法。\n# 抽象类和普通类区别？\n实例化：普通类可以直接实例化对象，而抽象类不能被实例化，只能被继承。\n方法实现：普通类中的方法可以有具体的实现，而抽象类中的方法可以有实现也可以没有实现。\n继承：一个类可以继承一个普通类，而且可以继承多个接口；而一个类只能继承一个抽象类，但可以同时实现多个接口。\n实现限制：普通类可以被其他类继承和使用，而抽象类一般用于作为基类，被其他类继承和扩展使用。\n\n# Java抽象类和接口的区别是什么？两者的特点：\n\n抽象类用于描述类的共同特性和行为，可以有成员变量、构造方法和具体方法。适用于有明显继承关系的场景。\n接口用于定义行为规范，可以多实现，只能有常量和抽象方法（Java 8 以后可以有默认方法和静态方法）。适用于定义类的能力或功能。\n\n两者的区别：\n\n实现方式：实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。\n方法方式：接口只有定义，不能有方法的实现，java 1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。\n访问修饰符：接口成员变量默认为public static final，必须赋初值，不能被修改；其所有的成员方法都是public、abstract的。抽象类中成员变量默认default，可在子类中被重新定义，也可被重新赋值；抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不带花括号。\n变量：抽象类可以包含实例变量和静态变量，而接口只能包含常量（即静态常量）。\n\n# 抽象类能加final修饰吗？不能，Java中的抽象类是用来被继承的，而final修饰符用于禁止类被继承或方法被重写，因此，抽象类和final修饰符是互斥的，不能同时使用。\n# 接口里面可以定义哪些方法？\n抽象方法\n\n抽象方法是接口的核心部分，所有实现接口的类都必须实现这些方法。抽象方法默认是 public 和 abstract，这些修饰符可以省略。\n123public interface Animal &#123;    void makeSound();&#125;\n\n\n默认方法\n\n默认方法是在 Java 8 中引入的，允许接口提供具体实现。实现类可以选择重写默认方法。\n1234567public interface Animal &#123;    void makeSound();        default void sleep() &#123;        System.out.println(&quot;Sleeping...&quot;);    &#125;&#125;\n\n\n静态方法\n\n静态方法也是在 Java 8 中引入的，它们属于接口本身，可以通过接口名直接调用，而不需要实现类的对象。\n1234567public interface Animal &#123;    void makeSound();        static void staticMethod() &#123;        System.out.println(&quot;Static method in interface&quot;);    &#125;&#125;\n\n\n私有方法\n\n私有方法是在 Java 9 中引入的，用于在接口中为默认方法或其他私有方法提供辅助功能。这些方法不能被实现类访问，只能在接口内部使用。\n123456789101112public interface Animal &#123;    void makeSound();        default void sleep() &#123;        System.out.println(&quot;Sleeping...&quot;);        logSleep();    &#125;        private void logSleep() &#123;        System.out.println(&quot;Logging sleep&quot;);    &#125;&#125;\n\n123public interface Animal &#123;    void makeSound();&#125;\n\n# 抽象类可以被实例化吗？在Java中，抽象类本身不能被实例化。\n这意味着不能使用new关键字直接创建一个抽象类的对象。抽象类的存在主要是为了被继承，它通常包含一个或多个抽象方法（由abstract关键字修饰且无方法体的方法），这些方法需要在子类中被实现。\n抽象类可以有构造器，这些构造器在子类实例化时会被调用，以便进行必要的初始化工作。然而，这个过程并不是直接实例化抽象类，而是创建了子类的实例，间接地使用了抽象类的构造器。\n例如：\n123456789101112131415161718192021public abstract class AbstractClass &#123;    public AbstractClass() &#123;        // 构造器代码    &#125;        public abstract void abstractMethod();&#125;public class ConcreteClass extends AbstractClass &#123;    public ConcreteClass() &#123;        super(); // 调用抽象类的构造器    &#125;        @Override    public void abstractMethod() &#123;        // 实现抽象方法    &#125;&#125;// 下面的代码可以运行ConcreteClass obj = new ConcreteClass();\n\n在这个例子中，ConcreteClass继承了AbstractClass并实现了抽象方法abstractMethod()。当我们创建ConcreteClass的实例时，AbstractClass的构造器被调用，但这并不意味着AbstractClass被实例化；实际上，我们创建的是ConcreteClass的一个对象。\n简而言之，抽象类不能直接实例化，但通过继承抽象类并实现所有抽象方法的子类是可以被实例化的。\n# 接口可以包含构造函数吗？在接口中，不可以有构造方法,在接口里写入构造方法时，编译器提示：Interfaces cannot have constructors，因为接口不会有自己的实例的，所以不需要有构造函数。\n为什么呢？构造函数就是初始化class的属性或者方法，在new的一瞬间自动调用，那么问题来了Java的接口，都不能new 那么要构造函数干嘛呢？根本就没法调用\n# 解释Java中的静态变量和静态方法在Java中，静态变量和静态方法是与类本身关联的，而不是与类的实例（对象）关联。它们在内存中只存在一份，可以被类的所有实例共享。\n\n\n\n\n\n\n\n\n\n静态变量\n静态变量（也称为类变量）是在类中使用static关键字声明的变量。它们属于类而不是任何具体的对象。主要的特点：\n\n共享性：所有该类的实例共享同一个静态变量。如果一个实例修改了静态变量的值，其他实例也会看到这个更改。\n初始化：静态变量在类被加载时初始化，只会对其进行一次分配内存。\n访问方式：静态变量可以直接通过类名访问，也可以通过实例访问，但推荐使用类名。\n\n示例：\n12345678910111213141516public class MyClass &#123;    static int staticVar = 0; // 静态变量    public MyClass() &#123;        staticVar++; // 每创建一个对象，静态变量自增    &#125;        public static void printStaticVar() &#123;        System.out.println(&quot;Static Var: &quot; + staticVar);    &#125;&#125;// 使用示例MyClass obj1 = new MyClass();MyClass obj2 = new MyClass();MyClass.printStaticVar(); // 输出 Static Var: 2\n\n\n\n\n\n\n\n\n\n\n静态方法\n静态方法是在类中使用static关键字声明的方法。类似于静态变量，静态方法也属于类，而不是任何具体的对象。主要的特点：\n\n无实例依赖：静态方法可以在没有创建类实例的情况下调用。对于静态方法来说，不能直接访问非静态的成员变量或方法，因为静态方法没有上下文的实例。\n访问静态成员：静态方法可以直接调用其他静态变量和静态方法，但不能直接访问非静态成员。\n多态性：静态方法不支持重写（Override），但可以被隐藏（Hide）。\n\n12345678910111213141516public class MyClass &#123;    static int count = 0;    // 静态方法    public static void incrementCount() &#123;        count++;    &#125;    public static void displayCount() &#123;        System.out.println(&quot;Count: &quot; + count);    &#125;&#125;// 使用示例MyClass.incrementCount(); // 调用静态方法MyClass.displayCount();   // 输出 Count: 1\n\n\n\n\n\n\n\n\n\n\n使用场景\n\n静态变量：常用于需要在所有对象间共享的数据，如计数器、常量等。\n静态方法：常用于助手方法（utility methods）、获取类级别的信息或者是没有依赖于实例的数据处理。\n\n# 非静态内部类和静态内部类的区别？区别包括：\n\n非静态内部类依赖于外部类的实例，而静态内部类不依赖于外部类的实例。\n非静态内部类可以访问外部类的实例变量和方法，而静态内部类只能访问外部类的静态成员。\n非静态内部类不能定义静态成员，而静态内部类可以定义静态成员。\n非静态内部类在外部类实例化后才能实例化，而静态内部类可以独立实例化。\n非静态内部类可以访问外部类的私有成员，而静态内部类不能直接访问外部类的私有成员，需要通过实例化外部类来访问。\n\n# 非静态内部类可以直接访问外部方法，编译器是怎么做到的？非静态内部类可以直接访问外部方法是因为编译器在生成字节码时会为非静态内部类维护一个指向外部类实例的引用。\n这个引用使得非静态内部类能够访问外部类的实例变量和方法。编译器会在生成非静态内部类的构造方法时，将外部类实例作为参数传入，并在内部类的实例化过程中建立外部类实例与内部类实例之间的联系，从而实现直接访问外部方法的功能。\n# 有一个父类和子类，都有静态的成员变量、静态构造方法和静态方法，在我new一个子类对象的时候，加载顺序是怎么样的？当你实例化一个子类对象时，静态成员变量、静态构造方法和静态方法的加载顺序遵循以下步骤：\n\n在创建子类对象之前，首先会加载父类的静态成员变量和静态代码块（构造方法无法被 static 修饰，因此这里是静态代码块）。这个加载是在类首次被加载时进行的，且只会发生一次。\n接下来，加载子类的静态成员变量和静态代码块。这一过程也只发生一次，即当首次使用子类的相关代码时。\n之后，执行实例化子类对象的过程。这时会呼叫父类构造方法，然后是子类的构造方法。\n\n具体加载顺序可以简要总结为：\n\n父类静态成员变量、静态代码块（如果有）\n子类静态成员变量、静态代码块（如果有）\n父类构造方法（实例化对象时）\n子类构造方法（实例化对象时）\n\n示例代码\n123456789101112131415161718192021222324252627class Parent &#123;    static &#123;        System.out.println(&quot;Parent static block&quot;);    &#125;    static int parentStaticVar = 10;    Parent() &#123;        System.out.println(&quot;Parent constructor&quot;);    &#125;&#125;class Child extends Parent &#123;    static &#123;        System.out.println(&quot;Child static block&quot;);    &#125;    static int childStaticVar = 20;    Child() &#123;        System.out.println(&quot;Child constructor&quot;);    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        Child c = new Child();    &#125;&#125;\n\n输出结果\n1234Parent static blockChild static blockParent constructorChild constructor\n\n从输出可以看出，在创建 Child 类型对象时，首先执行父类的静态块，然后是子类的静态块，最后才是父类和子类的构造函数。这清晰地展示了加载的顺序。\n# 深拷贝和浅拷贝# 深拷贝和浅拷贝的区别？\n\n浅拷贝是指只复制对象本身和其内部的值类型字段，但不会复制对象内部的引用类型字段。换句话说，浅拷贝只是创建一个新的对象，然后将原对象的字段值复制到新对象中，但如果原对象内部有引用类型的字段，只是将引用复制到新对象中，两个对象指向的是同一个引用对象。\n深拷贝是指在复制对象的同时，将对象内部的所有引用类型字段的内容也复制一份，而不是共享引用。换句话说，深拷贝会递归复制对象内部所有引用类型的字段，生成一个全新的对象以及其内部的所有对象。\n\n# 实现深拷贝的三种方法是什么？在 Java 中，实现对象深拷贝的方法有以下几种主要方式：\n\n\n\n\n\n\n\n\n\n实现 Cloneable 接口并重写 clone() 方法\n这种方法要求对象及其所有引用类型字段都实现 Cloneable 接口，并且重写 clone() 方法。在 clone() 方法中，通过递归克隆引用类型字段来实现深拷贝。\n1234567891011121314151617181920class MyClass implements Cloneable &#123;    private String field1;    private NestedClass nestedObject;    @Override    protected Object clone() throws CloneNotSupportedException &#123;        MyClass cloned = (MyClass) super.clone();        cloned.nestedObject = (NestedClass) nestedObject.clone(); // 深拷贝内部的引用对象        return cloned;    &#125;&#125;class NestedClass implements Cloneable &#123;    private int nestedField;    @Override    protected Object clone() throws CloneNotSupportedException &#123;        return super.clone();    &#125;&#125;\n\n\n\n\n\n\n\n\n\n\n使用序列化和反序列化\n通过将对象序列化为字节流，再从字节流反序列化为对象来实现深拷贝。要求对象及其所有引用类型字段都实现 Serializable 接口。\n123456789101112131415161718192021222324252627import java.io.*;class MyClass implements Serializable &#123;    private String field1;    private NestedClass nestedObject;    public MyClass deepCopy() &#123;        try &#123;            ByteArrayOutputStream bos = new ByteArrayOutputStream();            ObjectOutputStream oos = new ObjectOutputStream(bos);            oos.writeObject(this);            oos.flush();            oos.close();            ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());            ObjectInputStream ois = new ObjectInputStream(bis);            return (MyClass) ois.readObject();        &#125; catch (IOException | ClassNotFoundException e) &#123;            e.printStackTrace();            return null;        &#125;    &#125;&#125;class NestedClass implements Serializable &#123;    private int nestedField;&#125;\n\n\n\n\n\n\n\n\n\n\n手动递归复制\n针对特定对象结构，手动递归复制对象及其引用类型字段。适用于对象结构复杂度不高的情况。\n123456789101112131415161718192021class MyClass &#123;    private String field1;    private NestedClass nestedObject;    public MyClass deepCopy() &#123;        MyClass copy = new MyClass();        copy.setField1(this.field1);        copy.setNestedObject(this.nestedObject.deepCopy());        return copy;    &#125;&#125;class NestedClass &#123;    private int nestedField;    public NestedClass deepCopy() &#123;        NestedClass copy = new NestedClass();        copy.setNestedField(this.nestedField);        return copy;    &#125;&#125;\n\n# 泛型# 什么是泛型？泛型是 Java 编程语言中的一个重要特性，它允许类、接口和方法在定义时使用一个或多个类型参数，这些类型参数在使用时可以被指定为具体的类型。\n泛型的主要目的是在编译时提供更强的类型检查，并且在编译后能够保留类型信息，避免了在运行时出现类型转换异常。\n\n\n\n\n\n\n\n\n\n为什么需要泛型？\n\n适用于多种数据类型执行相同的代码\n\n1234567891011121314private static int add(int a, int b) &#123;    System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a + b));    return a + b;&#125;private static float add(float a, float b) &#123;    System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a + b));    return a + b;&#125;private static double add(double a, double b) &#123;    System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a + b));    return a + b;&#125;\n\n如果没有泛型，要实现不同类型的加法，每种类型都需要重载一个add方法；通过泛型，我们可以复用为一个方法：\n1234private static &lt;T extends Number&gt; double add(T a, T b) &#123;    System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a.doubleValue() + b.doubleValue()));    return a.doubleValue() + b.doubleValue();&#125;\n\n\n泛型中的类型在使用时指定，不需要强制类型转换（类型安全，编译器会检查类型）\n\n看下这个例子：\n1234List list = new ArrayList();list.add(&quot;xxString&quot;);list.add(100d);list.add(new Person());\n\n我们在使用上述list中，list中的元素都是Object类型（无法约束其中的类型），所以在取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现java.lang.ClassCastException异常。\n引入泛型，它将提供类型的约束，提供编译前的检查：\n123List&lt;String&gt; list = new ArrayList&lt;String&gt;();// list中只能放String, 不能放其它类型的元素\n\n# 对象# java创建对象有哪些方式？在Java中，创建对象的方式有多种，常见的包括：\n使用new关键字：通过new关键字直接调用类的构造方法来创建对象。\n1MyClass obj = new MyClass();\n\n使用Class类的newInstance()方法：通过反射机制，可以使用Class类的newInstance()方法创建对象。\n1MyClass obj = (MyClass) Class.forName(&quot;com.example.MyClass&quot;).newInstance();\n\n使用Constructor类的newInstance()方法：同样是通过反射机制，可以使用Constructor类的newInstance()方法创建对象。\n12Constructor&lt;MyClass&gt; constructor = MyClass.class.getConstructor();MyClass obj = constructor.newInstance();\n\n使用clone()方法：如果类实现了Cloneable接口，可以使用clone()方法复制对象。\n12MyClass obj1 = new MyClass();MyClass obj2 = (MyClass) obj1.clone();\n\n使用反序列化：通过将对象序列化到文件或流中，然后再进行反序列化来创建对象。\n123456789// SerializedObject.javaObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;object.ser&quot;));out.writeObject(obj);out.close();// DeserializedObject.javaObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;object.ser&quot;));MyClass obj = (MyClass) in.readObject();in.close();\n\n# Java创建对象除了new还有别的什么方式?\n通过反射创建对象：通过 Java 的反射机制可以在运行时动态地创建对象。可以使用 Class 类的 newInstance() 方法或者通过 Constructor 类来创建对象。\n\n123456789101112public class MyClass &#123;    public MyClass() &#123;        // Constructor    &#125;&#125;public class Main &#123;    public static void main(String[] args) throws Exception &#123;        Class&lt;?&gt; clazz = MyClass.class;        MyClass obj = (MyClass) clazz.newInstance();    &#125;&#125;\n\n\n通过反序列化创建对象：通过将对象序列化（保存到文件或网络传输）然后再反序列化（从文件或网络传输中读取对象）的方式来创建对象，对象能被序列化和反序列化的前提是类实现Serializable接口。\n\n1234567891011121314151617181920import java.io.*;public class MyClass implements Serializable &#123;    // Class definition&#125;public class Main &#123;    public static void main(String[] args) throws Exception &#123;        // Serialize object        MyClass obj = new MyClass();        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;object.ser&quot;));        out.writeObject(obj);        out.close();                // Deserialize object        ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;object.ser&quot;));        MyClass newObj = (MyClass) in.readObject();        in.close();    &#125;&#125;\n\n\n通过clone创建对象：所有 Java 对象都继承自 Object 类，Object 类中有一个 clone() 方法，可以用来创建对象的副本，要使用 clone 方法，我们必须先实现 Cloneable 接口并实现其定义的 clone 方法。\n\n12345678910111213public class MyClass implements Cloneable &#123;    @Override    public Object clone() throws CloneNotSupportedException &#123;        return super.clone();    &#125;&#125;public class Main &#123;    public static void main(String[] args) throws CloneNotSupportedException &#123;        MyClass obj1 = new MyClass();        MyClass obj2 = (MyClass) obj1.clone();    &#125;&#125;\n\n# New出的对象什么时候回收？通过过关键字new创建的对象，由Java的垃圾回收器（Garbage Collector）负责回收。垃圾回收器的工作是在程序运行过程中自动进行的，它会周期性地检测不再被引用的对象，并将其回收释放内存。\n具体来说，Java对象的回收时机是由垃圾回收器根据一些算法来决定的，主要有以下几种情况：\n\n引用计数法：某个对象的引用计数为0时，表示该对象不再被引用，可以被回收。\n可达性分析算法：从根对象（如方法区中的类静态属性、方法中的局部变量等）出发，通过对象之间的引用链进行遍历，如果存在一条引用链到达某个对象，则说明该对象是可达的，反之不可达，不可达的对象将被回收。\n终结器（Finalizer）：如果对象重写了finalize()方法，垃圾回收器会在回收该对象之前调用finalize()方法，对象可以在finalize()方法中进行一些清理操作。然而，终结器机制的使用不被推荐，因为它的执行时间是不确定的，可能会导致不可预测的性能问题。\n\n# 反射# 什么是反射？Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。\n反射具有以下特性：\n\n运行时类信息访问：反射机制允许程序在运行时获取类的完整结构信息，包括类名、包名、父类、实现的接口、构造函数、方法和字段等。\n动态对象创建：可以使用反射API动态地创建对象实例，即使在编译时不知道具体的类名。这是通过Class类的newInstance()方法或Constructor对象的newInstance()方法实现的。\n动态方法调用：可以在运行时动态地调用对象的方法，包括私有方法。这通过Method类的invoke()方法实现，允许你传入对象实例和参数值来执行方法。\n访问和修改字段值：反射还允许程序在运行时访问和修改对象的字段值，即使是私有的。这是通过Field类的get()和set()方法完成的。\n\n\n# 反射在你平时写代码或者框架中的应用场景有哪些?\n\n\n\n\n\n\n\n\n加载数据库驱动\n我们的项目底层数据库有时是用mysql，有时用oracle，需要动态地根据实际情况加载驱动类，这个时候反射就有用了，假设 com.mikechen.java.myqlConnection，com.mikechen.java.oracleConnection这两个类我们要用。\n这时候我们在使用 JDBC 连接数据库时使用 Class.forName()通过反射加载数据库的驱动程序，如果是mysql则传入mysql的驱动类，而如果是oracle则传入的参数就变成另一个了。\n12//  DriverManager.registerDriver(new com.mysql.cj.jdbc.Driver());Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);\n\n\n\n\n\n\n\n\n\n\n配置文件加载\nSpring 框架的 IOC（动态加载管理 Bean），Spring通过配置文件配置各种各样的bean，你需要用到哪些bean就配哪些，spring容器就会根据你的需求去动态加载，你的程序就能健壮地运行。\nSpring通过XML配置模式装载Bean的过程：\n\n将程序中所有XML或properties配置文件加载入内存\nJava类里面解析xml或者properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息\n使用反射机制，根据这个字符串获得某个类的Class实例\n动态配置实例的属性\n\n配置文件\n12className=com.example.reflectdemo.TestInvokemethodName=printlnState\n\n实体类\n12345public class TestInvoke &#123;    private void printlnState()&#123;        System.out.println(&quot;I am fine&quot;);    &#125;&#125;\n\n解析配置文件内容\n12345678// 解析xml或properties里面的内容，得到对应实体类的字节码字符串以及属性信息public static String getName(String key) throws IOException &#123;    Properties properties = new Properties();    FileInputStream in = new FileInputStream(&quot;D:\\IdeaProjects\\AllDemos\\language-specification\\src\\main\\resources\\application.properties&quot;);    properties.load(in);    in.close();    return properties.getProperty(key);&#125;\n\n利用反射获取实体类的Class实例，创建实体类的实例对象，调用方法\n1234567891011121314public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException, IOException, ClassNotFoundException, InstantiationException &#123;    // 使用反射机制，根据这个字符串获得Class对象    Class&lt;?&gt; c = Class.forName(getName(&quot;className&quot;));    System.out.println(c.getSimpleName());    // 获取方法    Method method = c.getDeclaredMethod(getName(&quot;methodName&quot;));    // 绕过安全检查    method.setAccessible(true);    // 创建实例对象    TestInvoke testInvoke = (TestInvoke)c.newInstance();    // 调用方法    method.invoke(testInvoke);&#125;\n\n运行结果：\n\n# 注解# 能讲一讲Java注解的原理吗？注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。\n我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。通过代理对象调用自定义注解的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。\n# Java注解的作用域呢？注解的作用域（Scope）指的是注解可以应用在哪些程序元素上，例如类、方法、字段等。Java注解的作用域可以分为三种：\n\n类级别作用域：用于描述类的注解，通常放置在类定义的上面，可以用来指定类的一些属性，如类的访问级别、继承关系、注释等。\n方法级别作用域：用于描述方法的注解，通常放置在方法定义的上面，可以用来指定方法的一些属性，如方法的访问级别、返回值类型、异常类型、注释等。\n字段级别作用域：用于描述字段的注解，通常放置在字段定义的上面，可以用来指定字段的一些属性，如字段的访问级别、默认值、注释等。\n\n除了这三种作用域，Java还提供了其他一些注解作用域，例如构造函数作用域和局部变量作用域。这些注解作用域可以用来对构造函数和局部变量进行描述和注释。\n# 异常# 介绍一下Java异常Java异常类层次结构图：Java的异常体系主要基于两大类：Throwable类及其子类。Throwable有两个重要的子类：Error和Exception，它们分别代表了不同类型的异常情况。\n\nError（错误）：表示运行时环境的错误。错误是程序无法处理的严重问题，如系统崩溃、虚拟机错误、动态链接失败等。通常，程序不应该尝试捕获这类错误。例如，OutOfMemoryError、StackOverflowError等。\n\nException（异常）：表示程序本身可以处理的异常条件。异常分为两大类：\n\n非运行时异常：这类异常在编译时期就必须被捕获或者声明抛出。它们通常是外部错误，如文件不存在（FileNotFoundException）、类未找到（ClassNotFoundException）等。非运行时异常强制程序员处理这些可能出现的问题，增强了程序的健壮性。\n\n运行时异常：这类异常包括运行时异常（RuntimeException）和错误（Error）。运行时异常由程序错误导致，如空指针访问（NullPointerException）、数组越界（ArrayIndexOutOfBoundsException）等。运行时异常是不需要在编译时强制捕获或声明的。\n\n\n\n\n# Java异常处理有哪些？异常处理是通过使用try-catch语句块来捕获和处理异常。以下是Java中常用的异常处理方式：\n\ntry-catch语句块：用于捕获并处理可能抛出的异常。try块中包含可能抛出异常的代码，catch块用于捕获并处理特定类型的异常。可以有多个catch块来处理不同类型的异常。\n\n1234567891011try &#123;    // 可能抛出异常的代码&#125; catch (ExceptionType1 e1) &#123;    // 处理异常类型1的逻辑&#125; catch (ExceptionType2 e2) &#123;    // 处理异常类型2的逻辑&#125; catch (ExceptionType3 e3) &#123;    // 处理异常类型3的逻辑&#125; finally &#123;    // 可选的finally块，用于定义无论是否发生异常都会执行的代码&#125;\n\n\nthrow语句：用于手动抛出异常。可以根据需要在代码中使用throw语句主动抛出特定类型的异常。\n\n1throw new ExceptionType(&quot;Exception message&quot;);\n\n\nthrows关键字：用于在方法声明中声明可能抛出的异常类型。如果一个方法可能抛出异常，但不想在方法内部进行处理，可以使用throws关键字将异常传递给调用者来处理。\n\n123public void methodName() throws ExceptionType &#123;    // 方法体&#125;\n\n\nfinally块：用于定义无论是否发生异常都会执行的代码块。通常用于释放资源，确保资源的正确关闭。\n\n1234567try &#123;    // 可能抛出异常的代码&#125; catch (ExceptionType e) &#123;    // 处理异常的逻辑&#125; finally &#123;    // 无论是否发生异常，都会执行的代码&#125;\n\n# 抛出异常为什么不用throws？如果异常是未检查异常或者在方法内部被捕获和处理了，那么就不需要使用throws。\n\nUnchecked Exceptions：未检查异常（unchecked exceptions）是继承自RuntimeException类或Error类的异常，编译器不强制要求进行异常处理。因此，对于这些异常，不需要在方法签名中使用throws来声明。示例包括NullPointerException、ArrayIndexOutOfBoundsException等。\n捕获和处理异常：另一种常见情况是，在方法内部捕获了可能抛出的异常，并在方法内部处理它们，而不是通过throws子句将它们传递到调用者。这种情况下，方法可以处理异常而无需在方法签名中使用throws。\n\n# try catch中的语句运行情况try块中的代码将按顺序执行，如果抛出异常，将在catch块中进行匹配和处理，然后程序将继续执行catch块之后的代码。如果没有匹配的catch块，异常将被传递给上一层调用的方法。\n# try{return “a”} fianlly{return “b”}这条语句返回啥finally块中的return语句会覆盖try块中的return返回，因此，该语句将返回”b”。\n# object# &#x3D;&#x3D; 与 equals 有什么区别？对于字符串变量来说，使用”&#x3D;&#x3D;”和”equals”比较字符串时，其比较方法不同。”&#x3D;&#x3D;”比较两个变量本身的值，即两个对象在内存中的首地址，”equals”比较字符串包含内容是否相同。\n对于非字符串变量来说，如果没有对equals()进行重写的话，”&#x3D;&#x3D;” 和 “equals”方法的作用是相同的，都是用来比较对象在堆内存中的首地址，即用来比较两个引用变量是否指向同一个对象。\n\n=&#x3D;：比较的是两个字符串内存地址（堆内存）的数值是否相等，属于数值比较；\nequals()：比较的是两个字符串的内容，属于内容比较。\n\n# StringBuffer和StringBuild区别是什么？区别：\n\nString 是 Java 中基础且重要的类，被声明为 final class，是不可变字符串。因为它的不可变性，所以拼接字符串时候会产生很多无用的中间对象，如果频繁的进行这样的操作对性能有所影响。\nStringBuffer 就是为了解决大量拼接字符串时产生很多中间对象问题而提供的一个类。它提供了 append 和 add 方法，可以将字符串添加到已有序列的末尾或指定位置，它的本质是一个线程安全的可修改的字符序列。在很多情况下我们的字符串拼接操作不需要线程安全，所以 StringBuilder 登场了。\nStringBuilder 是 JDK1.5 发布的，它和 StringBuffer 本质上没什么区别，就是去掉了保证线程安全的那部分，减少了开销。\n\n线程安全：\n\nStringBuffer：线程安全\nStringBuilder：线程不安全\n\n速度：\n\n一般情况下，速度从快到慢为 StringBuilder &gt; StringBuffer &gt; String，当然这是相对的，不是绝对的。\n\n使用场景：\n\n操作少量的数据使用 String。\n单线程操作大量数据使用 StringBuilder。\n多线程操作大量数据使用 StringBuffer。\n\n\n# Java 1.8 新特性# Java中stream的API介绍一下Java 8引入了Stream API，它提供了一种高效且易于使用的数据处理方式，特别适合集合对象的操作，如过滤、映射、排序等。Stream API不仅可以提高代码的可读性和简洁性，还能利用多核处理器的优势进行并行处理。让我们通过两个具体的例子来感受下Java Stream API带来的便利，对比在Stream API引入之前的传统做法。\n\n\n\n\n\n\n\n\n\n案例1：过滤并收集满足条件的元素\n问题场景：从一个列表中筛选出所有长度大于3的字符串，并收集到一个新的列表中。\n没有Stream API的做法：\n12345678List&lt;String&gt; originalList = Arrays.asList(&quot;apple&quot;, &quot;fig&quot;, &quot;banana&quot;, &quot;kiwi&quot;);List&lt;String&gt; filteredList = new ArrayList&lt;&gt;();for (String item : originalList) &#123;    if (item.length() &gt; 3) &#123;        filteredList.add(item);    &#125;&#125;\n\n这段代码需要显式地创建一个新的ArrayList，并通过循环遍历原列表，手动检查每个元素是否满足条件，然后添加到新列表中。\n使用Stream API的做法：\n1234List&lt;String&gt; originalList = Arrays.asList(&quot;apple&quot;, &quot;fig&quot;, &quot;banana&quot;, &quot;kiwi&quot;);List&lt;String&gt; filteredList = originalList.stream()                                        .filter(s -&gt; s.length() &gt; 3)                                        .collect(Collectors.toList());\n\n这里，我们直接在原始列表上调用.stream()方法创建了一个流，使用.filter()中间操作筛选出长度大于3的字符串，最后使用.collect(Collectors.toList())终端操作将结果收集到一个新的列表中。代码更加简洁明了，逻辑一目了然。\n\n\n\n\n\n\n\n\n\n案例2：计算列表中所有数字的总和\n问题场景：计算一个数字列表中所有元素的总和。\n没有Stream API的做法：\n12345List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);int sum = 0;for (Integer number : numbers) &#123;    sum += number;&#125;\n\n这个传统的for-each循环遍历列表中的每一个元素，累加它们的值来计算总和。\n使用Stream API的做法：\n1234List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);int sum = numbers.stream()                 .mapToInt(Integer::intValue)                 .sum();\n\n通过Stream API，我们可以先使用.mapToInt()将Integer流转换为IntStream（这是为了高效处理基本类型），然后直接调用.sum()方法来计算总和，极大地简化了代码。\n# Stream流的并行API是什么？是 ParallelStream。\n并行流（ParallelStream）就是将源数据分为多个子流对象进行多线程操作，然后将处理的结果再汇总为一个流对象，底层是使用通用的 fork&#x2F;join 池来实现，即将一个任务拆分成多个“小任务”并行计算，再把多个“小任务”的结果合并成总的计算结果\nStream串行流与并行流的主要区别：\n\n对CPU密集型的任务来说，并行流使用ForkJoinPool线程池，为每个CPU分配一个任务，这是非常有效率的，但是如果任务不是CPU密集的，而是I&#x2F;O密集的，并且任务数相对线程数比较大，那么直接用ParallelStream并不是很好的选择。\n# completableFuture怎么用的？CompletableFuture是由Java 8引入的，在Java8之前我们一般通过Future实现异步。\n\nFuture用于表示异步计算的结果，只能通过阻塞或者轮询的方式获取结果，而且不支持设置回调方法，Java 8之前若要设置回调一般会使用guava的ListenableFuture，回调的引入又会导致臭名昭著的回调地狱（下面的例子会通过ListenableFuture的使用来具体进行展示）。\nCompletableFuture对Future进行了扩展，可以通过设置回调的方式处理计算结果，同时也支持组合操作，支持进一步的编排，同时一定程度解决了回调地狱的问题。\n\n下面将举例来说明，我们通过ListenableFuture、CompletableFuture来实现异步的差异。假设有三个操作step1、step2、step3存在依赖关系，其中step3的执行依赖step1和step2的结果。\nFuture(ListenableFuture)的实现（回调地狱）如下：\n1234567891011121314151617181920212223242526272829303132333435ExecutorService executor = Executors.newFixedThreadPool(5);ListeningExecutorService guavaExecutor = MoreExecutors.listeningDecorator(executor);ListenableFuture&lt;String&gt; future1 = guavaExecutor.submit(() -&gt; &#123;    //step 1    System.out.println(&quot;执行step 1&quot;);    return &quot;step1 result&quot;;&#125;);ListenableFuture&lt;String&gt; future2 = guavaExecutor.submit(() -&gt; &#123;    //step 2    System.out.println(&quot;执行step 2&quot;);    return &quot;step2 result&quot;;&#125;);ListenableFuture&lt;List&lt;String&gt;&gt; future1And2 = Futures.allAsList(future1, future2);Futures.addCallback(future1And2, new FutureCallback&lt;List&lt;String&gt;&gt;() &#123;    @Override    public void onSuccess(List&lt;String&gt; result) &#123;        System.out.println(result);        ListenableFuture&lt;String&gt; future3 = guavaExecutor.submit(() -&gt; &#123;            System.out.println(&quot;执行step 3&quot;);            return &quot;step3 result&quot;;        &#125;);        Futures.addCallback(future3, new FutureCallback&lt;String&gt;() &#123;            @Override            public void onSuccess(String result) &#123;                System.out.println(result);            &#125;                    @Override            public void onFailure(Throwable t) &#123;            &#125;        &#125;, guavaExecutor);    &#125;    @Override    public void onFailure(Throwable t) &#123;    &#125;&#125;, guavaExecutor);\n\nCompletableFuture的实现如下：\n1234567891011121314ExecutorService executor = Executors.newFixedThreadPool(5);CompletableFuture&lt;String&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; &#123;    System.out.println(&quot;执行step 1&quot;);    return &quot;step1 result&quot;;&#125;, executor);CompletableFuture&lt;String&gt; cf2 = CompletableFuture.supplyAsync(() -&gt; &#123;    System.out.println(&quot;执行step 2&quot;);    return &quot;step2 result&quot;;&#125;);cf1.thenCombine(cf2, (result1, result2) -&gt; &#123;    System.out.println(result1 + &quot; , &quot; + result2);    System.out.println(&quot;执行step 3&quot;);    return &quot;step3 result&quot;;&#125;).thenAccept(result3 -&gt; System.out.println(result3));\n\n显然，CompletableFuture的实现更为简洁，可读性更好。\n CompletableFuture实现了两个接口（如上图所示)：Future、CompletionStage。\n\nFuture表示异步计算的结果，CompletionStage用于表示异步执行过程中的一个步骤（Stage），这个步骤可能是由另外一个CompletionStage触发的，随着当前步骤的完成，也可能会触发其他一系列CompletionStage的执行。\n从而我们可以根据实际业务对这些步骤进行多样化的编排组合，CompletionStage接口正是定义了这样的能力，我们可以通过其提供的thenAppy、thenCompose等函数式编程方法来组合编排这些步骤。\n\n# 序列化# 怎么把一个对象从一个jvm转移到另一个jvm?\n使用序列化和反序列化：将对象序列化为字节流，并将其发送到另一个 JVM，然后在另一个 JVM 中反序列化字节流恢复对象。这可以通过 Java 的 ObjectOutputStream 和 ObjectInputStream 来实现。\n使用消息传递机制：利用消息传递机制，比如使用消息队列（如 RabbitMQ、Kafka）或者通过网络套接字进行通信，将对象从一个 JVM 发送到另一个。这需要自定义协议来序列化对象并在另一个 JVM 中反序列化。\n使用远程方法调用（RPC）：可以使用远程方法调用框架，如 gRPC，来实现对象在不同 JVM 之间的传输。远程方法调用可以让你在分布式系统中调用远程 JVM 上的对象的方法。\n使用共享数据库或缓存：将对象存储在共享数据库（如 MySQL、PostgreSQL）或共享缓存（如 Redis）中，让不同的 JVM 可以访问这些共享数据。这种方法适用于需要共享数据但不需要直接传输对象的场景。\n\n# 序列化和反序列化让你自己实现你会怎么做?Java 默认的序列化虽然实现方便，但却存在安全漏洞、不跨语言以及性能差等缺陷。\n\n无法跨语言： Java 序列化目前只适用基于 Java 语言实现的框架，其它语言大部分都没有使用 Java 的序列化框架，也没有实现 Java 序列化这套协议。因此，如果是两个基于不同语言编写的应用程序相互通信，则无法实现两个应用服务之间传输对象的序列化与反序列化。\n容易被攻击：Java 序列化是不安全的，我们知道对象是通过在 ObjectInputStream 上调用 readObject() 方法进行反序列化的，这个方法其实是一个神奇的构造器，它可以将类路径上几乎所有实现了 Serializable 接口的对象都实例化。这也就意味着，在反序列化字节流的过程中，该方法可以执行任意类型的代码，这是非常危险的。\n序列化后的流太大：序列化后的二进制流大小能体现序列化的性能。序列化后的二进制数组越大，占用的存储空间就越多，存储硬件的成本就越高。如果我们是进行网络传输，则占用的带宽就更多，这时就会影响到系统的吞吐量。\n\n我会考虑用主流序列化框架，比如FastJson、Protobuf来替代Java 序列化。\n如果追求性能的话，Protobuf 序列化框架会比较合适，Protobuf 的这种数据存储格式，不仅压缩存储数据的效果好， 在编码和解码的性能方面也很高效。Protobuf 的编码和解码过程结合.proto 文件格式，加上 Protocol Buffer 独特的编码格式，只需要简单的数据运算以及位移等操作就可以完成编码与解码。可以说 Protobuf 的整体性能非常优秀。\n# 将对象转为二进制字节流具体怎么实现?其实，像序列化和反序列化，无论这些可逆操作是什么机制，都会有对应的处理和解析协议，例如加密和解密，TCP的粘包和拆包，序列化机制是通过序列化协议来进行处理的，和 class 文件类似，它其实是定义了序列化后的字节流格式，然后对此格式进行操作，生成符合格式的字节流或者将字节流解析成对象。\n在Java中通过序列化对象流来完成序列化和反序列化：\n\nObjectOutputStream：通过writeObject(）方法做序列化操作。\nObjectInputStrean：通过readObject()方法做反序列化操作。\n\n只有实现了Serializable或Externalizable接口的类的对象才能被序列化，否则抛出异常！\n实现对象序列化：\n\n让类实现Serializable接口：\n\n12345import java.io.Serializable;public class MyClass implements Serializable &#123;    // class code&#125;\n\n\n创建输出流并写入对象：\n\n12345678910111213import java.io.FileOutputStream;import java.io.ObjectOutputStream;MyClass obj = new MyClass();try &#123;    FileOutputStream fileOut = new FileOutputStream(&quot;object.ser&quot;);    ObjectOutputStream out = new ObjectOutputStream(fileOut);    out.writeObject(obj);    out.close();    fileOut.close();&#125; catch (IOException e) &#123;    e.printStackTrace();&#125;\n\n实现对象反序列化：\n\n创建输入流并读取对象：\n\n12345678910111213import java.io.FileInputStream;import java.io.ObjectInputStream;MyClass newObj = null;try &#123;    FileInputStream fileIn = new FileInputStream(&quot;object.ser&quot;);    ObjectInputStream in = new ObjectInputStream(fileIn);    newObj = (MyClass) in.readObject();    in.close();    fileIn.close();&#125; catch (IOException | ClassNotFoundException e) &#123;    e.printStackTrace();&#125;\n\n通过以上步骤，对象obj会被序列化并写入到文件”object.ser”中，然后通过反序列化操作，从文件中读取字节流并恢复为对象newObj。这种方式可以方便地将对象转换为字节流用于持久化存储、网络传输等操作。需要注意的是，要确保类实现了Serializable接口，并且所有成员变量都是Serializable的才能被正确序列化。\n# 设计模式# volatile和sychronized如何实现单例模式123456789101112131415161718public class SingleTon &#123;    // volatile 关键字修饰变量 防止指令重排序    private static volatile SingleTon instance = null;    private SingleTon()&#123;&#125;         public static  SingleTon getInstance()&#123;        if(instance == null)&#123;            //同步代码块 只有在第一次获取对象的时候会执行到 ，第二次及以后访问时 instance变量均非null故不会往下执行了 直接返回啦            synchronized(SingleTon.class)&#123;                if(instance == null)&#123;                    instance = new SingleTon();                &#125;            &#125;        &#125;        return instance;    &#125;&#125;\n\n正确的双重检查锁定模式需要需要使用 volatile。volatile主要包含两个功能。\n\n保证可见性。使用 volatile 定义的变量，将会保证对所有线程的可见性。\n禁止指令重排序优化。\n\n由于 volatile 禁止对象创建时指令之间重排序，所以其他线程不会访问到一个未初始化的对象，从而保证安全性。\n# 代理模式和适配器模式有什么区别？\n目的不同：代理模式主要关注控制对对象的访问，而适配器模式则用于接口转换，使不兼容的类能够一起工作。\n结构不同：代理模式一般包含抽象主题、真实主题和代理三个角色，适配器模式包含目标接口、适配器和被适配者三个角色。\n应用场景不同：代理模式常用于添加额外功能或控制对对象的访问，适配器模式常用于让不兼容的接口协同工作。\n\n# I&#x2F;O# Java怎么实现网络IO高并发编程？可以用 Java NIO ，是一种同步非阻塞的I&#x2F;O模型，也是I&#x2F;O多路复用的基础。\n传统的BIO里面socket.read()，如果TCP RecvBuffer里没有数据，函数会一直阻塞，直到收到数据，返回读到的数据， 如果使用BIO要想要并发处理多个客户端的i&#x2F;o，那么会使用多线程模式，一个线程专门处理一个客户端 io，这种模式随着客户端越来越多，所需要创建的线程也越来越多，会急剧消耗系统的性能。\n\nNIO 是基于I&#x2F;O多路复用实现的，它可以只用一个线程处理多个客户端I&#x2F;O，如果你需要同时管理成千上万的连接，但是每个连接只发送少量数据，例如一个聊天服务器，用NIO实现会更好一些。\n\n# BIO、NIO、AIO区别是什么？\nBIO（blocking IO）：就是传统的 java.io 包，它是基于流模型实现的，交互的方式是同步、阻塞方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。优点是代码比较简单、直观；缺点是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。\nNIO（non-blocking IO） ：Java 1.4 引入的 java.nio 包，提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层高性能的数据操作方式。\nAIO（Asynchronous IO） ：是 Java 1.7 之后引入的包，是 NIO 的升级版本，提供了异步非堵塞的 IO 操作方式，所以人们叫它 AIO（Asynchronous IO），异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。\n\n# NIO是怎么实现的？NIO是一种同步非阻塞的IO模型，所以也可以叫NON-BLOCKINGIO。同步是指线程不断轮询IO事件是否就绪，非阻塞是指线程在等待IO的时候，可以同时做其他任务。\n同步的核心就Selector（I&#x2F;O多路复用），Selector代替了线程本身轮询IO事件，避免了阻塞同时减少了不必要的线程消耗；非阻塞的核心就是通道和缓冲区，当IO事件就绪时，可以通过写到缓冲区，保证IO的成功，而无需线程阻塞式地等待。\nNIO由一个专门的线程处理所有IO事件，并负责分发。事件驱动机制，事件到来的时候触发操作，不需要阻塞的监视事件。线程之间通过wait,notify通信，减少线程切换。\nNIO主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector。传统IO基于字节流和字符流进行操作，而NIO基于Channel和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。\nSelector(选择区)用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。\n\n# 你知道有哪个框架用到NIO了吗？Netty。\nNetty 的 I&#x2F;O 模型是基于非阻塞 I&#x2F;O 实现的，底层依赖的是 NIO 框架的多路复用器 Selector。采用 epoll 模式后，只需要一个线程负责 Selector 的轮询。当有数据处于就绪状态后，需要一个事件分发器（Event Dispather），它负责将读写事件分发给对应的读写事件处理器（Event Handler）。事件分发器有两种设计模式：Reactor 和 Proactor，Reactor 采用同步 I&#x2F;O， Proactor 采用异步 I&#x2F;O。\n\nReactor 实现相对简单，适合处理耗时短的场景，对于耗时长的 I&#x2F;O 操作容易造成阻塞。Proactor 性能更高，但是实现逻辑非常复杂，适合图片或视频流分析服务器，目前主流的事件驱动模型还是依赖 select 或 epoll 来实现。\n# 其他# 有一个学生类，想按照分数排序，再按学号排序，应该怎么做？可以使用Comparable接口来实现按照分数排序，再按照学号排序。首先在学生类中实现Comparable接口，并重写compareTo方法，然后在compareTo方法中实现按照分数排序和按照学号排序的逻辑。\n123456789101112131415public class Student implements Comparable&lt;Student&gt; &#123;    private int id;    private int score;    // 构造方法和其他属性、方法省略    @Override    public int compareTo(Student other) &#123;        if (this.score != other.score) &#123;            return Integer.compare(other.score, this.score); // 按照分数降序排序        &#125; else &#123;            return Integer.compare(this.id, other.id); // 如果分数相同，则按照学号升序排序        &#125;    &#125;&#125;\n\n然后在需要对学生列表进行排序的地方，使用Collections.sort()方法对学生列表进行排序即可：\n123List&lt;Student&gt; students = new ArrayList&lt;&gt;();// 添加学生对象到列表中Collections.sort(students);\n\n# Native方法解释一下在Java中，native方法是一种特殊类型的方法，它允许Java代码调用外部的本地代码，即用C、C++或其他语言编写的代码。native关键字是Java语言中的一种声明，用于标记一个方法的实现将在外部定义。\n在Java类中，native方法看起来与其他方法相似，只是其方法体由native关键字代替，没有实际的实现代码。例如：\n123public class NativeExample &#123;    public native void nativeMethod();&#125;\n\n要实现native方法，你需要完成以下步骤：\n\n生成JNI头文件：使用javah工具从你的Java类生成C&#x2F;C++的头文件，这个头文件包含了所有native方法的原型。\n编写本地代码：使用C&#x2F;C++编写本地方法的实现，并确保方法签名与生成的头文件中的原型匹配。\n编译本地代码：将C&#x2F;C++代码编译成动态链接库（DLL，在Windows上），共享库（SO，在Linux上）\n加载本地库：在Java程序中，使用System.loadLibrary()方法来加载你编译好的本地库，这样JVM就能找到并调用native方法的实现了。\n\n\n","slug":"java基础/八股","date":"2024-11-13T04:14:48.000Z","categories_index":"八股","tags_index":"java,java基础,精选","author_index":"Ivan"},{"id":"bc567916c4dc0d8169bd26d18e348d36","title":"test","content":"欢迎使用 Markdown 笔记这是首次使用 Markdown 笔记 自动生成的内容，包含 Markdown 语法和应用介绍\n表格 &amp; 文本样式\n\n\n样式\n语法\n示例\n\n\n\n加粗\n前后 ** 或  __\n加粗1 加粗2\n\n\n斜体\n前后 * 或  _\n斜体1 斜体2\n\n\n删除线\n前后 ~~\n删除线\n\n\n内联代码\n前后 &#96;\ncode\n\n\n下划线\n前 &lt;u&gt;  后 &lt;/u&gt;\n下划线\n\n\n高亮\n前后 ==\n&#x3D;&#x3D;高亮文本&#x3D;&#x3D;\n\n\n引用\n\n\n\n\n\n\n\n\nuTools 新一代效率工具平台\n链接鼠标右击 或 Ctrl 键 + 点击 系统默认浏览器打开链接\nuTools 官网  猿料社区\n图片拖放图片文件、粘贴截图可直接将图片源数据存储到笔记中\n\n图片可拖动为文件到任意窗口使用\n无序列表\n项目\n项目 1\n项目 A\n项目 B\n\n\n项目 2\n\n\n\n有序列表\n项目 1\n项目 A\n项目 B\n\n\n项目 2\n\n任务列表\n A 计划\n A1 计划\n A2 计划\n\n\n B 计划\n\n代码块代码块支持 168 种编程语言\n12345678910111213141516// javascript 冒泡排序function bubbleSort(array) &#123;  let swapped = true;  do &#123;    swapped = false;    for (let j = 0; j &lt; array.length; j++) &#123;      if (array[j] &gt; array[j + 1]) &#123;        let temp = array[j];        array[j] = array[j + 1];        array[j + 1] = temp;        swapped = true;      &#125;    &#125;  &#125; while (swapped);  return array;&#125;\n\nKaTeX 数学公式内联公式质能方程 $E&#x3D;mc^2$\n公式块$$\\displaystyle \\left( \\sum_{k&#x3D;1}^n a_k b_k \\right)^2 \\leq \\left( \\sum_{k&#x3D;1}^n a_k^2 \\right) \\left( \\sum_{k&#x3D;1}^n b_k^2 \\right)$$\n应用介绍特性\n极佳的 Markdown 编辑体验，实时预览、存储\n与传统富文本编辑方式结合，支持通用快捷键\n导出 MD、html、PDF、图片\n可快速搜索全部笔记(内容和标题)\n笔记名称可设置为 uTools 关键字，外部快速打开笔记\n\n使用技巧\n侧边栏文件夹或笔记，拖拽调整位置，鼠标右击 显示操作菜单\n当焦点未在编辑器，键盘上下方向键、 Tab 键切换笔记\n当焦点未在编辑器，Enter 进入编辑\nCommand/Ctrl+F 焦点切换到搜索\n编辑器中列表编辑时，按 Tab 变子项，Shift + Tab 恢复\n\n","slug":"test","date":"2024-11-09T02:38:44.000Z","categories_index":"","tags_index":"test","author_index":"Ivan"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post1$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server1$ hexo server\n\nMore info: Server\nGenerate static files1$ hexo generate\n\nMore info: Generating\nDeploy to remote sites1$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2024-11-07T16:24:53.067Z","categories_index":"","tags_index":"","author_index":"Ivan"}]