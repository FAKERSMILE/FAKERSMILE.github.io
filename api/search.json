[{"id":"282ca770e6df8001dbda062738b2a12a","title":"java面向对象","content":"Java给我的感觉就是一个有一个的类，毕竟类是其代码的基本组织单元。\n对象是类实例化的结果，所以对象有时也被称为实例，从类到对象的过程称为实例化。\n面向对象的三大特点：封装、继承、多态\n封装学术上的东西就不讲了，从开发的视角阐述这个概念。\n通常我们都会将字段的可访问性设置为private，然后通过Getter和Setter方法对外提供查看和设置字段值的接口。\n（我习惯于称作字段，貌似大家都喜欢叫属性）\n上代码：\n12345678910111213141516171819202122public class Person &#123;    private String name;    private int age;        public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;&#125;\n\n这是一个Person类，对人这个实体的抽象。类中有两个字段：name和age，代表人的姓名和年龄。从代码层面上看，Person类外面的任何方法都不能直接访问这两个字段，只能通过类中提供的方法进行访问和修改。\n这就是封装！！！\n至于说有什么有点，AI来吧：\n面向对象编程（OOP）中的封装是一个核心概念，它提供了以下优点：\n\n数据隐藏：封装允许对象隐藏其内部状态和复杂性，只暴露一个清晰的接口给外部世界。这降低了代码的复杂性，并提高了代码的可理解性。\n\n实现细节的保护：通过隐藏内部实现，封装防止了外部代码直接访问对象的内部数据，从而防止了可能的错误或不当的修改。\n\n接口与实现的分离：封装使得对象的内部实现可以独立于其接口进行修改，只要接口保持不变，外部代码就不需要修改。\n\n提高代码的可维护性：由于对象的内部实现被隐藏，修改这些实现不会影响依赖于该对象的代码，这使得维护和更新变得更加容易。\n\n增强代码的安全性：封装可以防止外部代码访问或修改对象的私有成员，这有助于防止潜在的安全风险。\n\n促进重用：封装提供了一个清晰的接口，使得对象可以在不同的程序和环境中重用，而不需要了解其内部工作机制。\n\n减少耦合：封装减少了类与类之间的直接依赖，从而降低了系统中各部分之间的耦合度。\n\n提高代码的可测试性：封装使得单元测试可以针对特定的对象进行，而不需要考虑整个系统的复杂性。\n\n支持多态：封装与多态一起工作，允许基于接口而非实现编程，这使得使用基类指针或引用调用派生类的方法成为可能。\n\n封装继承：在支持继承的语言中，封装允许子类继承父类的属性和方法，同时可以扩展或修改这些属性和方法，而不需要更改外部代码。\n\n促进模块化设计：封装鼓励将系统分解成模块或类，每个模块或类都有自己的职责，这有助于构建更大规模的系统。\n\n提高代码的组织性：封装要求将相关的数据和操作这些数据的方法组合在一起，这有助于提高代码的组织性和结构化。\n\n\n总的来说，封装是面向对象设计的一个关键原则，它有助于创建更健壮、更灵活和更易于维护的软件。\n随便扫一眼就行了。。。\n继承这个没有什么好说的，子类可以继承父类非private的字段和方法。\n在实际开发中，我们往往使用父类变量去引用子类对象，除非想调用子类对象的扩展的方法。\n1234567891011121314151617class Student extends Person &#123;    public Student(String name, int age) &#123;        super(name, age);    &#125;    public void sayHello()&#123;        System.out.println(&quot;Hello Java&quot;);    &#125;&#125;class Test &#123;    public static void main(String[] args) &#123;        Person person = new Student(&quot;kaiven&quot;, 20);        System.out.println(person.getName() + person.getAge());    &#125;&#125;\n\n由于Student继承了Person，所以Person类型的变量可以引用Student类型的对象。\n当然，考虑以下语句，能够正常运行：\n如果你尝试了，会发现不行。其实是可以的，因为引用的是Student对象嘛。但是，通不过编译器，因为Person类中没有sayHello这个方法。\n如果我们想调用属于这个子类对象的特有方法，只能通过类型强转去通过编译器的检查：\n1234567class Test &#123;    public static void main(String[] args) &#123;        Person person = new Student(&quot;kaiven&quot;, 20);        Student student = (Student) person;        student.sayHello();    &#125;&#125;\n\n多态不要去抓着这个字眼不放了，你越想就越容易钻牛角尖。\nJava中的多态，分为编译时多态和运行时多态。\n编译时多态指的是方法的重载：\n1234567891011121314class Student extends Person &#123;        public Student(String name, int age) &#123;        super(name, age);    &#125;    public void sayHello()&#123;        System.out.println(&quot;Hello Java&quot;);    &#125;    public void sayHello(String content)&#123;        System.out.println(content);    &#125;&#125;\n\n运行时多态指的是程序中定义的对象引用的具体类型在运行期间才确定。\n运行时多态的三个条件：继承、覆盖（重写）、向上转型\n123456789101112131415161718192021222324252627282930313233class Student extends Person &#123;    public Student(String name, int age) &#123;        super(name, age);    &#125;    @Override    public String getName() &#123;        return &quot;我就不告诉你我的名次&quot;;    &#125;    &#125;class Teacher extends Person&#123;    public Teacher(String name, int age) &#123;        super(name, age);    &#125;        @Override    public String getName() &#123;        return &quot;我可以告诉你我的名字，但是是假的&quot;;    &#125;&#125;class Test &#123;    public static void main(String[] args) &#123;        Person person01 = new Student(&quot;kaiven&quot;, 20);        Person person02 = new Teacher(&quot;jack&quot;, 22);        System.out.println(person01.getName());        System.out.println(person02.getName());    &#125;&#125;\n\nJVM知道应该调用哪个方法的，不用担心。\n\n2024.10.19\nwriteBy kaiven\n","slug":"java基础/javamxdx","date":"2024-12-03T13:21:54.000Z","categories_index":"八股","tags_index":"java","author_index":"Ivan"},{"id":"5d0fb8fa16015e90389a3f31d7e8667c","title":"java导学","content":"恭喜你，成功入坑Java开发，以后将走上后端开发的道路。\nJava是一门什么样的编程语言呢？\n（AI的回答）\nJava 是一种广泛使用的编程语言，它由Sun Microsystems（现在是Oracle Corporation的一部分）在1995年发布。Java 被设计为具有跨平台兼容性、安全性、网络中心化和健壮性等特点，这使得它成为了构建企业级应用、Android 应用、网站后台服务和其他类型软件的热门选择。\n以下是Java的一些关键特性：\n\n跨平台兼容性：Java的口号“一次编写，到处运行”（Write Once, Run Anywhere，简称WORA）强调了其跨平台的能力。这意味着在一台机器上编写的Java程序可以在其他装有Java虚拟机（JVM）的机器上运行，而无需任何修改。\n\n面向对象：Java是一种面向对象的语言，它支持类、对象、封装、继承和多态等概念。\n\n内存管理：Java有自动垃圾回收机制，这意味着程序员不需要（也不能）手动管理内存。这减少了内存泄漏和其他内存管理错误的可能性。\n\n健壮性：Java的设计目标之一是创建一个健壮的语言，这意味着它旨在消除某些类别的错误，例如数组越界、野指针等。\n\n安全性：Java提供了一个安全的环境，其中包括一个沙箱执行环境和一个强大的安全管理体系。\n\n多线程：Java内置了对多线程编程的支持，这使得开发多线程应用程序变得相对容易。\n\n网络编程：Java有强大的网络编程支持，这使得它非常适合创建网络应用程序和服务。\n\n开源：Java有一个活跃的开源社区，提供了大量的库和框架，如Spring、Hibernate等，这些工具可以帮助开发者快速构建高质量的应用程序。\n\n\nJava在企业级应用开发中非常流行，也被广泛应用于Android移动应用开发。此外，Java还被用于桌面应用程序、游戏开发、科学计算和教育等领域。随着技术的发展，Java也在不断更新和改进，以适应新的编程范式和市场需求。\n快速的浏览一下就好了，对于一个小白来说，这些都是废话。学就完事儿了，现在，管这么多的概念干嘛。\n学的东西是不是很多嘞？\n的确是这样的，技术这种东西是学不完的。我之所以入坑Java就是因为觉得Java框架的统一性，就只用学一个Spring框架。可是深入学习后，才知道是我肤浅了。\n（之前是写前端的，然后就是觉得前端的生态太乱了，真的是百花齐放，然后转到Java后端，发现，其实也差不多）\n但是无论技术多么的复杂多样，掌握好基本的开发要求，不断的扩展知识和技术，这才是正解。\n如果你和我一样，学一个东西非要去搞清楚底层的运行原理或者源码实现，那么，恭喜你，你会陷入一个内耗循环。\n不是说这样不好，但是技术这个东西真的太多啦。比如说一个消息中间件，就有ActiveMQ、RabbitMQ、Kafka、RocketMQ。。。\n你去学嘛，你去看源码嘛，哈哈。\n对于一门技术，我们的态度应该是：\n\n搞明白基本的概念和特性，明白大致的应用场景\n学会技术的基本使用以及了解一些高级特性的适用场景\n对于基本原理，围绕面试八股展开，出现频率高的，重点学习\n源码嘛，看时间喽（如果有人给你出视频去讲源码了，那就不要浪费时间自己看）\n\n不要总是想着要把技术搞得多么的牛逼，要让面试官觉得你牛逼，那才是真的牛逼。\n（面试，也是一门技术活）\n不过，现在，不用考虑这么多，干就完事儿！\n\n2024.10.19\n","slug":"java导学","date":"2024-12-03T13:13:19.000Z","categories_index":"","tags_index":"java","author_index":"Ivan"},{"id":"eb843316efe7fc0d2e0c7904a0ae2582","title":"mysql进阶","content":"MySQL的系统架构1、数据库和数据库实例在与MySQL相关的学习和研究中，我们需要搞清楚一些概念：\n\n数据库：按照一定的数据结构来组织、存储和管理数据的仓库，通常由数据库管理系统进行管理。\n数据库管理软件（RDBMS）：就是我们说的数据库管理软件，我们常说的MySQL指的就是它。\n数据库实例：其实就是正在运行的数据库管理程序，一个数据库管理程序我们称作一个数据库实例。\n\n2、MySQL架构\n（现在的话，有个印象就行了）\n（1）MySQL向外提供的交互接口Connectors组件，是MySQL向外提供的交互组件，如java,.net,php等语言可以通过该组件来操作SQL语句，实现\n与SQL的交互。通过客户端&#x2F;服务器通信协议与MySQL建立连接。MySQL 客户端与服务端的通信方式是 “ 半双工\n”。对于每一个 MySQL 的连接，时刻都有一个线程状态来标识这个连接正在做什么。\n（2）管理服务组件和工具组件提供MySQL的各项服务组件和管理工具，如备份(Backup)，恢复(Recovery)，安全管理(Security)等功能。\n（3）连接池组件负责监听客户端向MySQL Server端的各种请求，接收请求，转发请求到目标模块。每个成功连接MySQL Server的客户请求都会被创建或分配一个线程，该线程负责客户端与MySQL Server端的通信，接收客户端发送的命令，传递服务端的结果信息等。\n（4）SQL接口组件接收用户SQL命令，如DML,DDL和存储过程等，并将最终结果返回给用户。\n（5）查询分析器组件首先分析SQL命令语法的合法性，并进行抽象语法树解析，如果sql有语法错误，会抛出异常信息。\n（6）优化器组件对SQL命令按照标准流程进行优化分析，mysql会按照它认为的最优方式进行优化，选用成本最小的执行计划。\n（7）缓存组件缓存和缓冲组件，这里边的内容我们后边会详细的讲解。\n（8）MySQL存储引擎MySQL属于关系型数据库，而关系型数据库的存储是以表的形式进行的，对于表的创建，数据的存储，检索，更新等都是由MySQL存储引擎完成的。\nMySQL存储引擎在MySQL中扮演着重要角色。研究过SQL Server和Oracle的读者可能很清楚，这两种数据库的存\n储引擎只有一个，而MySQL的存储引擎种类比较多，如MyIsam存储引擎，InnoDB存储引擎和Memory存储引\n擎。\n因为mysql本身就是开源的，他允许第三方基于MySQL骨架，开发适合自己业务需求的存储引擎。从MySQL存储引擎种类上来说，可以分为官方存储引擎和第三方存储引擎，比较常用的存储引擎包括InnoDB存储引擎，MyIsam 存储引擎和Momery存储引擎。\n3、SQL语句的执行流程\n（图应该都可以看得懂的吧）\n小问题：MySQL8为什么取消了查询缓存？\n锁争用问题：在高并发环境中，查询缓存会引起锁争用问题。每次对查询缓存的读写操作都需要获取锁，这在高并发下会导致锁的争用，进而引发性能瓶颈。\n缓存无效化问题：查询缓存的无效化机制导致缓存命中率较低。当一个表的数据发生变化时（如INSERT、UPDATE、DELETE操作），与该表相关的所有查询缓存都会被无效化。对于写操作频繁的系统，这意味着查询缓存的有效性非常短暂，导致缓存命中率很低，反而增加了缓存维护的开销而没有带来明显的性能提升。\n内存开销：查询缓存的管理需要额外的内存资源，而且如果查询语句的字符大小写、空格或者注释的不同，查询缓存都会认为是不同的查询（因为他们的hash值会不同），这可能会导致内存资源的过度消耗。\n\nMySQL的目录结构windows中的目录结构在mysql启动的时候，会从【安装目录】加载软件数据，在运行过程中，会从【数据目录】中读取数据。这两个目\n录我们不要放在一起，避免重新安装软件导致数据丢失：\n\n\nbin目录：用于放置一些可执行的工具文件，如mysql.exe、mysqld.exe、mysqlshow.exe等。\ninclude目录：用于放置一些头文件，如：mysql.h、mysql_ername.h等。（MySQL是C语言写的，这个都知道的吧）\nlib目录：用于放置一系列库文件。\ndata目录：用于放置一些日志文件以及数据库。\nmy.ini文件：MySQL的配置文件，MySQL实例初始化时会加载该文件中的内容\n\n\ndata目录中，每个文件夹对应一个数据库，数据库中的表就是一个又一个的文件。\nLinux中的文件目录这个和windows下的文件目录是差不多的，如果是默认的安装方式的话，文件是分散在不同地方的。\n（百度或者问AI）\n字符集和排序规则mysql支持大量的字符集，但是我们通常使用的是utf8，【show collation】命令可以查看mysql支持的所有的排序规则和字符集，如下所示部分：\n1show collation like &#x27;%utf8%&#x27;;\n\n\n一种字符集会对应很多的规则：\n\nutf8-polish-ci，表示utf-8的字符集的波兰语的比较规则，ci代表忽略大小写。\n\nutf8-general-ci，就是通用的忽略大小写的utf8字符集比较规则。\n\nutf8mb4_0900_ai_ci中的0900指的是Unicode 9.0的规范，后边的后缀代表不区分重音也不区分大小写，他是utf8mb4字符集一个新的通用排序归则。\n\n\n\nutf8和utf8mb4的区别：\n\nutf8mb3(utf-8)：使用1~3个字节表示字符，utf8默认就是utf8mb3。\n\nutf8mb4：使用1~4个字节表示字符，他是utf8的超集，甚至可以存储很多【emoji表情?????】，\n\nmysql8.0已经默认字符集设置为utf8mb4。\n\n\n【字符集】和【比较规则】可以作用在全局、数据库、表、甚至是列级别。（想了解的自行百度怎么设置，大家最熟悉的莫过于在创建库和表的时候指定字符集和比较规则吧）\nMySQL修改配置的方法1、修改全局变量很显然，这些东西你百度都能得到的，这里就不去复制粘贴了。全局修改的变量对每一个会话都起作用。\n2、当前会话的变量这个修改的作用域只对某一个会话起作用。\n3、修改配置文件先看一个示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225[client]port = 3306socket = /tmp/mysql.sock[mysqld]port = 3306basedir = /project/mysql/mysql-8.0.18datadir = /project/mysql/datapid-file = /project/mysql/mysql-8.0.18/mysqld.pidsocket = /tmp/mysql.socktmpdir = /project/mysql/tmpuser = mysql#关闭MySQL X plugin（33060）mysqlx=0###日志配置------innodb_log_file_size = 1Glog_error = /project/mysql/mysql-8.0.18/log/error.logslow_query_log = 1long_query_time = 5slow_query_log_file = /project/mysql/mysql-8.0.18/log/slow.log#记录没有索引导致的慢查询###连接配置------#最大连接数max_connections = 3000#最大错误连接数max_connect_errors = 10#连接闲置超时时间interactive_timeout = 1800wait_timeout = 1800#连接响应超时时间connect-timeout = 60###默认配置（插件、字符------default_authentication_plugin = mysql_native_passwordcharacter-set-server = utf8sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLESinnodb_log_file_size = 1024M#关闭InnoDB严格模式，防止报错 Row size too large (&gt; 8126)innodb_strict_mode=0default-storage-engine=INNODBbind-address = 0.0.0.0#域名解析，设置为1之后就不能直接127.0.0.1连接数据库，需要root@127.0.0.1#skip_name_resolve = 1#忽略大小写，此项很重要（MySQL8之后的版本必须在初始化就设定此参数，初始化之后配置更改不生效）lower_case_table_names = 1###主备相关------server-id = 25log-bin = backup.log#二进制日志格式,三种模式：statement语句&gt;模式,row行模式，mixed混合模式binlog_format = mixedmax_binlog_size = 1Gexpire_logs_days = 7#事务提交前产生的日志缓存binlog_cache_size = 16M#Auto_increment_increment和auto_increment_offset用于主－主服务器（master-to-master）复制，避免主键冲突#为了避免两台服务器同时做更新时自增长字段的值之间发生冲突。一般在主主同步配置时，需要将两台服务器的auto_increment_increment增长量都配置为2（根据从库节点数量配置），而要把auto_increment_offset分别配置为1（主库）和2（从库）#递增值auto_increment_increment = 2#初始值auto_increment_offset = 1#表示需要记录二进制日志的数据库binlog_do_db=csspbinlog_do_db=mysql#从库配置replicate_do_db=cssp#表示不需要记录二进制日志的数据库binlog_ignore_db=information_schema#忽略表replicate-wild-ignore-table=pva_db.pva_login_%replicate-wild-ignore-table=pva_db.pva_login_log#忽略错误代码（从库配置）slave-skip-errors = 1032,1062,126,1114,1146,1048,1396#自动清空不再需要中继日志（从库配置）relay-log-purge = 1###系统资源相关------#接收连接请求队列back_log = 600#最大打开文件数（前提mysql用户需要调整最大打开文件数）open_files_limit = 10240#所有线程打开表数量table_open_cache = 512#处理请求包最大大小max_allowed_packet = 32M#临时表最大大小tmp_table_size = 512M#独立内存表所允许最大容量max_heap_table_size = 512M#用于索引块的缓冲区大小key_buffer_size = 64M#查询排序的缓冲区大小sort_buffer_size = 8M#读操作的缓冲区大小read_buffer_size = 8M#联表查询缓冲区大小join_buffer_size = 8M#批量数据插入缓存bulk_insert_buffer_size = 120M#保存索引以及原始数据的缓冲池（原则上最大为系统内存的 80%）innodb_buffer_pool_size = 2G#脏页比例，脏页占innodb_buffer_pool_size的比例时，触发刷脏页到磁盘（25~50）innodb_max_dirty_pages_pct = 30#事务提交 flushinnodb_flush_log_at_trx_commit = 1#1，（默认值）每一次提交刷新日志到磁盘#2，先写入缓存，由系统设置每秒刷新日志到磁盘（可能丢失1~2秒的数据）###多线程优化------#可重新被利用保存在缓存中的线程数量thread_cache_size = 300###其他配置------#占用内存过高调整以下参数配置#table_definition_cache = 400#open_files_limit = 2048#table_open_cache = 256#跳过密码表检查#skip-grant-tables\n\n修改了配置文件需要重启MySQL服务实例重新加载。\n内置数据库\nmysql：这个库很重要，他是mysql的核心数据库，负责存储数据库的用户、权限设置、关键字等mysql自己需要使用，控制和管理的信息。\n\ninformation_schema：这个数据库维护了数据库其他表的一些描述性信息，也称为元数据。比如，当前有哪\n\n\n些表，哪些视图，哪些触发器，哪些列等。\n\nperformation_schema：这个数据库用来存储mysql服务器运行过程中的一些状态信息，是做性能监控的。\n\n比如最近执行了什么sql语句，内存使用情况等\n\nsys：结合information_schema和performation_schema的数据，能更方便的了解mysql服务器的性能信\n\n息。\n\n2024.11.05\nwriteBy kaiven\n","slug":"mysql进阶","date":"2024-12-03T12:56:15.000Z","categories_index":"八股","tags_index":"mysql","author_index":"Ivan"},{"id":"76e26cf6d70a50daf8e75fb7d566964d","title":"面试官到底喜欢什么样的人？","content":"面试官到底喜欢什么样的人？在统一批次的面试中，可能就有好几百号人，无可否认的是，我们都喜欢优秀的人，都想和优秀的人共事，那怎么表现出我们的优秀呢？\n面试官喜欢爱学习、爱动脑、有技术广度和深度并且有实际经验的人。\n面试时间一般30分钟左右，我们必须通过自己的话术，去展现【爱学习、爱动脑、技术广度和深度以及实际经验】给他&#x2F;她看。\n建立正确的面试心态在这种大环境下，面试时间会被拉的很长，一面、二面、三面……面试的环节越多，那么你挂掉的概率也就越大，但没办法，就是这么卷。。。\n我们不需要唬住所有的面试官，因为在面试的过程中，面试官是用他最熟悉的东西去问题，有可能他熟悉的地方你并不是特别的熟悉，所以可能就会出现答得不好或者答不上来的情况，这很正常。。。\n我们做的事情，就是拿下我们能拿下的面试官。其实大部分面试官都是一边工作一边去面试的，所以八股的知识也就一般。比如说大厂的面试官，可能就会对原理性的东西进行深层次的拷打，如果你还只能回答出一些表面性的东西或者说大家都会说的一些东西，那么就不能体现出你的优势，面试挂掉的概率极大。当然，这些面试官也不是我们的菜。\n这小节最重要的一点就是：你对面试准备有多充分，就决定了你能找到什么样的工作！\n（不会说你随便糊弄了一下就能拿到一份很好的offer，而别人准备了大半年却颗粒无收，匹配机制嘛，找到符合自己目前口味的面试官，才是重点）\n如何把面试官拉倒坑里？上文也叙述过，其实大部分面试官的水平也一般，所以他其实也不知道自己该问些什么东西，如果你也没有对他进行相关的引导的话，他不就只能随便问了嘛。\n如何引导面试官？原理其实也比较简单：\n\n自我介绍阶段，突出描述自己擅长的部分\n回答问题的时候，为下一个问题做铺垫\n\n对于自我介绍，下文会进行详细的叙述。\n我们来说一下第二点，往往面试官问的问题都是层层递进的，会从你对某个问题的回答中捕风捉影，想好下一个要问你的问题。那是不是可以提前预判呢？把面试官引导上你准备好的问题链中去。\n还要一个比较重要的点就是拖延时间，或者说扩展描述，做到问一答三，因为你能回答出来的东西，那肯定是你提前准备好的，你给他暴露的信息越多，他问的点也就越多。但是，短短的半小时，他不可能什么都去问你，一定是从你的问答中挑他感兴趣的点，继续追问。你给他的选项，一定是你准备过的，每个点都这样的去扩展描述，一方面体现出你是一个【爱学习、爱动脑、有技术广度和深度并且有实际经验的人】，另一方面这样也将面试时间的主导权交到了自己的手上，你一直再说，面试官一直在听，问个两三个问题后，他可能就不会在问其他的了。\n（面试也要占用面试官的时间，谁不想休息啊，而且人家也有自己的事情要去做）\n面试的本质是什么？问题：面试是介绍你自己还是你的项目？\n答案：一定是介绍你自己。本质上来说，大多数的项目都是CRUD，没有什么特别的亮点。那和面试官对话的时候，就不要关注项目本身了，而是要去关注某个功能的实现，简单描述一下项目中的功能是怎么去实现的，然后重点叙述一下该方式存在什么样的不足，你会怎么去解决这个问题？\n场景：\n假设你现在的项目就是一个纯粹的后端管理系统，登录方式采用的是JavaWeb的Cookie + Session。\n针对该功能的叙述：\n由于我这个项目其实是一个学习项目，算不上真正意义上的生产级别的项目，所以登录功能只是采用了JavaWeb的 Cookie + Session 这样一种简单的形式。但是呢，这样做存在一些问题。比如说在分布式的环境中，多个JVM实例无法共享 Session ，就会出现明明用户已经登录了，但是后续的请求打在了其他机器上，导致用户会出现重复登录的情况，用户体验感不好。针对这个问题，需要我们去实现session的共享嘛，常见的实现方式就是将 Session 对象序列化放入 Redis 中进行共享，然后每一次的登录请求都去查询Redis。但是呢，这种方式也会出现一定的问题，。。。。。\n（你需要根据实际的场景去提前写好这些话术，你这一套话术下来，是不是达到了拖延时间的效果？你准备的这些话术中的内容的扩展问题你也回去准备的，是不是将面试官引入坑里面了？这一堆东西下来，是不是体现了你是一个【爱学习、爱动脑、有技术广度和深度并且有实际经验的人】？）\n公司招你肯定不是简单的让你做你熟悉的业务，而是想给你什么业务你都能够应对。\n你是一个厨师，业务需求就是食材，只会做几道菜的不叫做厨师。\n项目的亮点角度：架构、业务拆分、技术选型、大数据量处理\n如何写好简历避免已读不回？简历到底看什么？（校招）\n学历（至少全日制本科）\n专业排名（非科班成绩优异也可以，至少证明学习能力很强 &#x3D;&gt; 黑魔法）\n荣誉奖项（黑魔法，如果是大厂的话，斟酌一下，很有可能会让你提供证明材料）\n实习经历（大厂很加分，也可以黑魔法，但是不建议）\n\n学历这个东西确实没有办法，现在的大环境就是这样的，如果你是专科的同学，那么请先专升本，否则你可能会感慨世界的炎凉。（专升本你就写你本科的学历就好了，装傻）\n专业排名真的是最好造假的了，前20%？可以不？谁会去管呢？\n荣誉奖项也是，基本上不会查的，而且你也不会写什么特别高级的奖项，比如说 ACM金牌。。。（当然，如果是大厂的话，背景调查可能比较严格哦，请斟酌）\n实习经历也可以造假的，对，没错，只要你能唬住面试官。（大厂同样需要斟酌）\n如果是找实习的同学，那么肯定是没有实习经历这么一说的（除非你有过一段），那么重点在你的项目经历上。\n虽然说面试是介绍我们自己，但是前提是简历得入得了面试官的法眼，否则面试的资格都没有。\n一个项目的基本元素：\n项目名称（次要，但是不能太土）\n个人职责（在项目中负责什么，应届生次要）\n项目的线上地址（重要，增加项目的真实度）\n项目简介（重要，让面试官能够了解你这个项目的业务类型）\n项目的亮点（重要）\n\n对于项目简介，一定要言简意赅，主要是要让面试官知道你这个项目的大概业务有哪些。你做的那些项目基本上都能找到相似且开源的（大部分同学的项目也是根据这些开源的项目改的），所以没必要去过多的介绍。所以，这里你的项目名称最好是见名知意，比如说xx在线教育平台，面试官甚至都不用去读你的项目简介，就知道你这个项目的业务有哪些。\n对于项目的亮点，这个东西，得从实际的项目出发，体现出你的思考，还是那句话，可能项目真的没有什么亮点，就是一个很普通的CURD。但是，你可以通过引入一些其他的技术，去解决了什么问题，优化了什么东西。（无论是公司里面的大项目还是你的小项目，都会有bug和不足，不然为什么要持续的更新迭代，总会有问题的。）而且，你的亮点话术，要做到有针对性，而不是这些语句迁移到其他的项目上都能使用。\n(什么样的场景，通过什么方式，解决了什么问题或者优化了什么东西)\n如何做好自我介绍？（面试中最重要的环节）好的自我介绍有什么用？\n体现出你自己的价值和逻辑思维能力，快速让面试官对你感兴趣\n引导面试官对你进行提问\n\n什么是一份好的自我介绍？\n语言的流利程度，表达能力流畅的人，面试成功率会高很多。因为语言表达流利的话，证明了你的思维逻辑是流畅的，沟通能力是OK的。\n把自己相关的优势介绍清楚。\n能够讲清楚自己在项目中的职责，成果，并且有量化的数据支撑（人对数字是比较敏感的）。\n拉平和面试官之间的信息差，让面试官能够快速带入我们的项目中，能清楚他想要问的问题。\n\n很有必要去手写一份800字左右的自我介绍，在面试之前不断的打磨，这样才能在面试的时候流利的阐述。\n八股文怎么去准备怎么去回答？八股文这个东西是必须背的，你很难保证面试官不会去问，特别是对于应届生而言。\n八股文大概考什么？市面上的八股文这么多，动不动就几十万字的，没必要啊。这东西是有重点的：\n\njava基础：集合类、JVM、锁、多线程（这里会有实操，比如写代码实现三个线程交替打印“abc”）。\nJUC、AQS、线程池。线程池的核心参数，拒绝策略，队列有哪些。\nSpring、SpringMVC、SpringBoot：老演员了，问的也就那些东西（这里可以结合设计模式去讲，Spring中运用了大量的设计模式）。\nMySQL：。。。\nRedis：数据结构，一些机制。\n\n这里给鱼皮（B站搜索：程序员鱼皮）的面试鸭刷题网站打一个广告：https://www.mianshiya.com/\n这是一个专门为程序员提供的在线刷题平台，涵盖从IT各大学科的面试经典八股文，支持网页端和小程序端，目前（2024.10.20）永久会员只需要 129 元。\n（不要求每一道八股文你都能回答得很好，但是你必须有一两道八股文讲得非常出彩，结合自己的理解和实际的业务场景）\n总结总的来说，面试的宗旨就是：通过和面试官的沟通，去展示你的优秀，你是一个爱学习、爱动脑、有技术广度和深度并且有实际经验的人。\n","slug":"面试","date":"2024-12-03T12:35:49.000Z","categories_index":"","tags_index":"面试","author_index":"Ivan"},{"id":"e53aef447e609f6346cd88030af73ac8","title":"JDK8有哪些新特性？","content":"JDK8较为重要和平日里经常被问的特性如下：\n1)用元空间替代了永久代因为JDK8要把JRockit虚拟机和Hotspot虚拟机融合，而JRockit没有永久代，所以把Hotspot永久代给去了（本质也是永久代回收效率太低)\n2)引入了Lambda表达式Lambda表达式是Java8中引入的一个重要特性，它允许我们以更简洁和灵活的方式编写代码。Lambda表达式可以看作是匿名函数，它没有方法名，但可以包含参数和函数体。Lambda表达式可以用于简化代码，提高代码的可读性和可维护性。Lambda表达式的基本语法如下：\n123(parameters) -&gt; expression或(parameters) -&gt; &#123; statements; &#125;\n其中，parameters是参数列表，expression是函数体，statements是函数体的多条语句。Lambda表达式可以用于替换匿名内部类，使代码更加简洁和易读。例如，我们可以使用Lambda表达式来简化以下代码：\n1234567List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);Collections.sort(list, new Comparator&lt;String&gt;() &#123;    @Override    public int compare(String s1, String s2) &#123;        return s1.compareTo(s2);    &#125;&#125;);\n使用Lambda表达式可以简化为：\n12List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);Collections.sort(list, (s1, s2) -&gt; s1.compareTo(s2));\nLambda表达式还可以用于简化其他场景，例如线程的创建、集合的遍历等。\n3)引入了日期类、接口默认方法、静态方法Java8引入了新的日期和时间APl(位于java.time包中)，它们更加简洁和易于使用，解决了旧版日期时间AP!的许多问题。例如DateCalendar都是可变类且线程不安全。而新的日期类都是不可变的，一旦创建就不能修改，这样可以避免意外的修改，提升代码的安全性和可维护性。\n123LocalDate date =LocalDate.now();LocalTime time =LocalTime.now();LocalDateTime dateTime =LocalDateTime.now()\nDate本身不包含时区信息，必须使用Calendar类来处理时区，但使用起来非常复杂且容易出错。新API提供了专门的时区类（如ZonedDateTime,OffsetDateTimeZoneId等)，简化了时区处理，并且这些类的方法更加直观和易用。\n接口默认方法、静态默认方法允许在接口中定义方法的默认实现，这样接口的实现类不需要再实现这些方法。之所以提供静态方法，是为了将相关的方法内聚在接口中，而不必创建新的对象。\n4)新增Stream流式接口Stream API是Java8中引入的一个新特性，它提供了一种新的方式来处理数据集合。Stream API允许我们以声明式的方式处理数据，避免了传统的循环和条件语句，使代码更加简洁和易读。Stream API的基本语法如下：\n1Stream&lt;T&gt; stream = collection.stream();\n其中，collection是一个数据集合，可以是List、Set、Map等。stream是一个Stream对象，它表示一个数据流，可以通过一系列的操作来处理数据。Stream API提供了一系列的操作，包括过滤、映射、排序、聚合等。这些操作可以链式调用，使代码更加简洁和易读。例如，我们可以使用Stream API来过滤一个List中的偶数，并计算它们的和：\n123456List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6);int sum = list.stream()    .filter(n -&gt; n % 2 == 0)    .mapToInt(Integer::intValue)    .sum();System.out.println(sum); // 输出：12\n在上面的代码中，我们首先将List转换为一个Stream对象，然后使用filter操作过滤出偶数，再使用mapToInt操作将Stream中的元素转换为int类型，最后使用sum操作计算它们的和。整个操作链式调用，使代码更加简洁和易读。Stream API还提供了一些其他的操作，例如reduce、collect、forEach等，可以满足各种数据处理的需求。通过使用Stream API，我们可以更加高效地处理数据集合，使代码更加简洁和易读。\n5)引入Optional类Optional是Java8引入的一个容器类，用于表示可能为空的值。它通过提供更为清晰的AP!,来减少程序中出现nu11的情况，避免NullPointerException(空指针异常)的发生。Optional可以包含一个值，也可以为空，从而表示“值存在”或“值不存在”这两种状态。作用：\n\n减少NullPointerException:通过Optional提供的操作方法，避免 直接使用 null进行空值检查，从而降低空指针异常的风险。\n提高代码可读性：Optional 提供了一套简洁的API,例如isPresent() ifPresent()和orElse()，可以让代码更具表达性，清晰地展示处理空值的逻辑1234Optional&lt;String&gt; optional = Optional.of(&quot;Hello&quot;);if (optional.isPresent()) &#123;    System.out.println(optional.get());&#125;\n\n6)新增了CompletableFuture、StampedLock等并发实现类。CompletableFuture提供了一个新的异步编程模型，简化了异步任务的编写和管理。StampedLock是一个新的读写锁实现，它提供了一种新的方式来处理读写锁，避免了复杂的锁机制和锁竞争。\n如果你对HashMap、ConcurrentHashMap面试题有准备的话，这时候也可以抛出来，引导面试官来询问。比如：Java8修改了HashMap和ConcurrentHashMap的实现。\n\n","slug":"八股","date":"2024-11-13T04:14:48.000Z","categories_index":"八股","tags_index":"java","author_index":"Ivan"},{"id":"0f709ae9d76437c23b8e3099e047f571","title":"api开放平台前端登录","content":"\n\napi开放平台前端登录\n\n\n\n\n\n\n\n\n src&#x2F;pages&#x2F;User&#x2F;Login&#x2F;index.tsx原\n12345678910111213141516171819202122232425262728293031323334// 提交表单const handleSubmit = async (values: API.UserLoginRequest) =&gt; &#123;  try &#123;    // 登录    const msg = await userLoginUsingPost(&#123; ...values, &#125;);    if (msg.status === &#x27;ok&#x27;) &#123;      // 登录成功      const defaultLoginSuccessMessage = intl.formatMessage(&#123;        id: &#x27;pages.login.success&#x27;,        defaultMessage: &#x27;登录成功！&#x27;,      &#125;);      message.success(defaultLoginSuccessMessage);      // 获取用户信息      await fetchUserInfo();      // 获取跳转地址      const urlParams = new URL(window.location.href).searchParams;      // 跳转到指定地址      history.push(urlParams.get(&#x27;redirect&#x27;) || &#x27;/&#x27;);      return;    &#125;    console.log(msg);    // 如果失败去设置用户错误信息    setUserLoginState(msg);  &#125; catch (error) &#123;    // 登录失败    const defaultLoginFailureMessage = intl.formatMessage(&#123;      id: &#x27;pages.login.failure&#x27;,      defaultMessage: &#x27;登录失败，请重试！&#x27;,    &#125;);    console.log(error);    message.error(defaultLoginFailureMessage);  &#125;&#125;;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n app.tsx\n123456789101112131415161718192021222324252627282930313233343536373839404142// 导出一个异步函数，用于获取初始状态export async function getInitialState(): Promise&lt;&#123;  settings?: Partial&lt;LayoutSettings&gt;;  currentUser?: API.CurrentUser;  loading?: boolean;  fetchUserInfo?: () =&gt; Promise&lt;API.CurrentUser | undefined&gt;;&#125;&gt; &#123;  // 定义一个异步函数，用于获取当前用户信息  const fetchUserInfo = async () =&gt; &#123;    try &#123;      // 调用queryCurrentUser函数，获取当前用户信息      const msg = await queryCurrentUser(&#123;        skipErrorHandler: true,      &#125;);      // 返回当前用户信息      return msg.data;    &#125; catch (error) &#123;      // 如果发生错误，跳转到登录页面      history.push(loginPath);    &#125;    // 返回undefined    return undefined;  &#125;;  // 如果不是登录页面，执行  const &#123; location &#125; = history;  if (location.pathname !== loginPath) &#123;    // 调用fetchUserInfo函数，获取当前用户信息    const currentUser = await fetchUserInfo();    // 返回初始状态    return &#123;      fetchUserInfo,      currentUser,      settings: defaultSettings as Partial&lt;LayoutSettings&gt;,    &#125;;  &#125;  // 返回初始状态  return &#123;    fetchUserInfo,    settings: defaultSettings as Partial&lt;LayoutSettings&gt;,  &#125;;&#125;\n\n12345request?: (params: U &amp; &#123;    pageSize?: number;    current?: number;    keyword?: string;&#125;, sort: Record&lt;string, SortOrder&gt;, filter: Record&lt;string, (string | number)[] | null&gt;) =&gt; Promise&lt;Partial&lt;RequestData&lt;DataSource&gt;&gt;&gt;;\n","slug":"api用户平台","date":"2024-11-12T02:10:49.000Z","categories_index":"","tags_index":"项目","author_index":"Ivan"},{"id":"bc567916c4dc0d8169bd26d18e348d36","title":"test","content":"欢迎使用 Markdown 笔记这是首次使用 Markdown 笔记 自动生成的内容，包含 Markdown 语法和应用介绍\n表格 &amp; 文本样式\n\n\n样式\n语法\n示例\n\n\n\n加粗\n前后 ** 或  __\n加粗1 加粗2\n\n\n斜体\n前后 * 或  _\n斜体1 斜体2\n\n\n删除线\n前后 ~~\n删除线\n\n\n内联代码\n前后 &#96;\ncode\n\n\n下划线\n前 &lt;u&gt;  后 &lt;/u&gt;\n下划线\n\n\n高亮\n前后 ==\n&#x3D;&#x3D;高亮文本&#x3D;&#x3D;\n\n\n引用\n\n\n\n\n\n\n\n\nuTools 新一代效率工具平台\n链接鼠标右击 或 Ctrl 键 + 点击 系统默认浏览器打开链接\nuTools 官网  猿料社区\n图片拖放图片文件、粘贴截图可直接将图片源数据存储到笔记中\n\n图片可拖动为文件到任意窗口使用\n无序列表\n项目\n项目 1\n项目 A\n项目 B\n\n\n项目 2\n\n\n\n有序列表\n项目 1\n项目 A\n项目 B\n\n\n项目 2\n\n任务列表\n A 计划\n A1 计划\n A2 计划\n\n\n B 计划\n\n代码块代码块支持 168 种编程语言\n12345678910111213141516// javascript 冒泡排序function bubbleSort(array) &#123;  let swapped = true;  do &#123;    swapped = false;    for (let j = 0; j &lt; array.length; j++) &#123;      if (array[j] &gt; array[j + 1]) &#123;        let temp = array[j];        array[j] = array[j + 1];        array[j + 1] = temp;        swapped = true;      &#125;    &#125;  &#125; while (swapped);  return array;&#125;\n\nKaTeX 数学公式内联公式质能方程 $E&#x3D;mc^2$\n公式块$$\\displaystyle \\left( \\sum_{k&#x3D;1}^n a_k b_k \\right)^2 \\leq \\left( \\sum_{k&#x3D;1}^n a_k^2 \\right) \\left( \\sum_{k&#x3D;1}^n b_k^2 \\right)$$\n应用介绍特性\n极佳的 Markdown 编辑体验，实时预览、存储\n与传统富文本编辑方式结合，支持通用快捷键\n导出 MD、html、PDF、图片\n可快速搜索全部笔记(内容和标题)\n笔记名称可设置为 uTools 关键字，外部快速打开笔记\n\n使用技巧\n侧边栏文件夹或笔记，拖拽调整位置，鼠标右击 显示操作菜单\n当焦点未在编辑器，键盘上下方向键、 Tab 键切换笔记\n当焦点未在编辑器，Enter 进入编辑\nCommand/Ctrl+F 焦点切换到搜索\n编辑器中列表编辑时，按 Tab 变子项，Shift + Tab 恢复\n\n","slug":"test","date":"2024-11-09T02:38:44.000Z","categories_index":"","tags_index":"test","author_index":"Ivan"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post1$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server1$ hexo server\n\nMore info: Server\nGenerate static files1$ hexo generate\n\nMore info: Generating\nDeploy to remote sites1$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2024-11-07T16:24:53.067Z","categories_index":"","tags_index":"","author_index":"Ivan"}]